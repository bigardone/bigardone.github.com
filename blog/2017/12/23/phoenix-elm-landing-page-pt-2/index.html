<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8 lt-ie7" lang=en-us><![endif]--> <!--[if IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8" lang=en-us><![endif]--> <!--[if IE 8]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if IE 9]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if lt IE 10]><html class="no-js lt-ie10" lang=en-us><![endif]--> <!--[if !IE]>><![endif]--> <html class=no-js lang=en> <head> <title>Phoenix & Elm landing page (pt.2) - Code, Love & Boards</title> <meta charset=utf-8 content='text/html' http-equiv=content-type> <meta content='ie=edge,chrome=1' http-equiv=x-ua-compatible> <meta content='Building the landing page UI and the basic Elm subscription form' name=description> <meta content='Ricardo García Vega - http://twitter.com/bigardone' name=author> <meta content='elixir, phoenix, elm' name=keywords> <meta content='initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width' name=viewport> <link href='//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css' rel=stylesheet> <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Lora:400,700" media=screen rel=stylesheet /> <link href="../../../../../stylesheets/blog-ed6b1e0f.css" media=all rel=stylesheet /> <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/tomorrow.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js'></script> <link href='/images/apple-touch-icon-57x57-6e598dc4.png' rel=apple-touch-icon sizes=57x57> <link href='/images/apple-touch-icon-114x114-5be964ba.png' rel=apple-touch-icon sizes=114x114> <link href='/images/apple-touch-icon-72x72-70084a85.png' rel=apple-touch-icon sizes=72x72> <link href='/images/apple-touch-icon-144x144-1dbb56c1.png' rel=apple-touch-icon sizes=144x144> <link href='/images/apple-touch-icon-60x60-d05a5ea9.png' rel=apple-touch-icon sizes=60x60> <link href='/images/apple-touch-icon-120x120-5dafce59.png' rel=apple-touch-icon sizes=120x120> <link href='/images/apple-touch-icon-76x76-b2c0d784.png' rel=apple-touch-icon sizes=76x76> <link href='/images/apple-touch-icon-152x152-45595360.png' rel=apple-touch-icon sizes=152x152> <link href='/images/favicon-160x160-944ce76e.png' rel=icon sizes=160x160 type='image/png'> <link href='/images/favicon-96x96-b7e4e089.png' rel=icon sizes=96x96 type='image/png'> <link href='/images/favicon-32x32-b7f34a79.png' rel=icon sizes=32x32 type='image/png'> <link href='/images/favicon-16x16-2712c528.png' rel=icon sizes=16x16 type='image/png'> <meta content='#9f00a7' name=msapplication-TileColor> <meta content='/images/mstile-144x144-028d4c4c.png' name=msapplication-TileImage> <script>
  var _StatHat = _StatHat || [];
  _StatHat.push(['_setUser', 'NzIzMCDaNaL5bvEP1HQkMYwfYsQe']);
  (function() {
          var sh = document.createElement('script'); sh.type = 'text/javascript';
          sh.async = true;
          sh.src = '//www.stathat.com/javascripts/api.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(sh, s);
  })();
</script> </head> <body class=blog> <header id=main_header> <div class=main-logo> <a href="/"><img src="../../../../../images/logo-cd52bd68.png"/> </a> </div> <div class=container> <section class=center> <h1>Phoenix & Elm landing page (pt.2)</h1> <h3></h3> <div class=meta-data> <hr> posted Dec 23, 2017 on <a class=tag href="/blog/tags/elixir.html">elixir</a> <a class=tag href="/blog/tags/phoenix.html">phoenix</a> <a class=tag href="/blog/tags/elm.html">elm</a> </div> </section> </div> </header> <section id=main_content> <div class=container> <section> <article> <div class=index> <p>This post belongs to the <strong>Phoenix & Elm landing page</strong> series.</p> <ol> <li><a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/">Bootstrapping the project and the basic API functionality to save our first leads</a></li> <li><a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/">Building the landing page UI and the basic Elm subscription form</a></li> <li><a href="/blog/2018/01/06/phoenix-elm-landing-page-pt-3/">Adding Google reCAPTCHA support to avoid spambots</a></li> </ol> <a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target=_blank><i class="fa fa-github"></i> Source code</a> </div> <p>In the <a href="/blog/2017/12/01/phoenix-elm-landing-page-pt-1/">previous part</a> of the series we created the project for our brand new landing page, we generated the migration for the leads table, we implemented the logic for saving them into the database, and we also added some tests to ensure that everything was working fine. Now we can focus on the front-end side of the project, which consists of a <strong>Phoenix</strong> template, an <strong>Elm</strong> form, and some <strong>Sass</strong> love. Let&#39;s do this!</p> <h2>A little bit of clean up</h2> <p>Before going any further, let&#39;s do a clean up emptying or removing some of the files generated by <strong>Phoenix</strong>. These changes include:</p> <ul> <li>Removing <code>assets/css/phoenix.css</code>.</li> <li>Removing <code>assets/js/socket.js</code> as we are not using sockets this time.</li> <li>Removing <code>assets/static/images/phoenix.png</code>.</li> </ul> <p>Apart from removing these extra files that we do not need anymore, we are also going to edit some of the existing ones. First of all, let&#39;s update the main layout template and remove all the default <strong>Phoenix</strong> HTML elements:</p> <pre><code class="eex"># lib/landing_page_web/templates/layout/app.html.eex

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;
    &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt;

    &lt;title&gt;Hello Landing Page!&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= static_path(@conn, &quot;/css/app.css&quot;) %&gt;&quot;&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;%= render(@view_module, @view_template, assigns) %&gt;
    &lt;script src=&quot;&lt;%= static_path(@conn, &quot;/js/app.js&quot;) %&gt;&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre> <p>Next, we have to edit the <code>index.html</code> template to add the basic structure of the landing page:</p> <pre><code class="eex"># lib/landing_page_web/templates/page/index.html.eex

&lt;div class=&quot;main-wrapper&quot;&gt;
  &lt;div class=&quot;left&quot;&gt;
    &lt;div class=&quot;hero&quot;&gt;
      &lt;h1 class=&quot;title&quot;&gt;Phoenix &amp; Elm landing page&lt;/h1&gt;
      &lt;p class=&quot;subtitle&quot;&gt;
        Real use case of building a landing page using &lt;strong&gt;Phoenix&lt;/strong&gt; and &lt;strong&gt;Elm&lt;/strong&gt;,
        following some common patterns and best practices.
      &lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;scroll-to&quot;&gt;
      &lt;a class=&quot;icon&quot;&gt;
        &lt;i class=&quot;fa fa-chevron-down&quot;&gt;&lt;/i&gt;
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;right&quot; id=&quot;subscribe_form&quot;&gt;
    &lt;section class=&quot;section&quot;&gt;
      &lt;div class=&quot;container is-fluid&quot;&gt;
        &lt;div id=&quot;form_container&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/section&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre> <p>Having deleted all the extra files and the layout template ready, we are in a good position to add some styling.</p> <h2>Adding styles with Sass and Bulma</h2> <p>I have started using <a href="https://bulma.io/">Bulma</a> like a month ago, and I love the results so far. It is a pretty slick looking CSS framework, based on <strong>flexbox</strong> and which is very easy to customize using <strong>Sass</strong>. Let&#39;s install everything we need to use <strong>Bulma</strong> and <strong>Sass</strong> with <strong>Brunch</strong>:</p> <pre><code class="bash">$ cd assets
$ npm install node-sass sass-brunch --save-dev
...
...
$ npm install bulma normalize-scss --save
...
...
</code></pre> <p>After installing the needed modules, we have to edit Brunch&#39;s configuration file to add support for Sass:</p> <pre><code class="js">// assets/brunch-config.js

exports.config = {
  // See http://brunch.io/#documentation for docs.
  // ...

  // Configure your plugins
  plugins: {
    // ...

    sass: {
      mode: &#39;native&#39;,
      sourceMapEmbed: true,
      options: {
        includePaths: [
          &#39;node_modules/normalize-scss/sass/&#39;,
          &#39;node_modules/bulma/&#39;,
        ],
      },
    },
  },

//...
}
</code></pre> <p>Another tool that I often use to organize my styles files is <a href="https://github.com/jasonreece/css-burrito">css-burrito</a>, which generates a very convenient structure of <strong>Sass</strong> files to help you have a well and organized <strong>Sass</strong> architecture based on modules. I am not going to dive deeper into the implementation details, but here you can find the resulting files. After adding the style files, and restarting the <strong>Phoenix</strong> server, we can visit <a href="//localhost:4000">http://localhost:4000</a> and see the following:</p> <p><img src="/images/blog/phoenix-elm-landing-page/plain-html-01b2d8d8.jpg" alt="Navigation flow" style="background: #fff;"/></p> <p>Not looking bad at all! However, what about the subscription form?</p> <h2>Adding Elm support</h2> <p>Adding <strong>Elm</strong> to the project is pretty straightforward. Before going any further, make sure you visit <a href="//elm-lang.org/">Elm&#39;s official site</a> and follow the install instructions for your current platform. Once you have sorted that out, let&#39;s continue by adding <strong>Elm</strong>, and its <strong>Brunch</strong> support to the project:</p> <pre><code class="sh">$ cd assets
$ mkdir elm
$ cd elm
$ elm package install elm-lang/html -y
.
..
...
</code></pre> <p>The last command installs the basic <strong>Elm</strong> packages and generates the initial file structure and configuration file that we need to update to make it look like the following:</p> <pre><code class="json">// assets/elm/elm-package.json

{
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;summary&quot;: &quot;Repo for my Phoenix and Elm landing page series&quot;,
  &quot;repository&quot;: &quot;https://github.com/bigardone/phoenix-and-elm-landing-page.git&quot;,
  &quot;license&quot;: &quot;BSD3&quot;,
  &quot;source-directories&quot;: [&quot;src&quot;],
  &quot;exposed-modules&quot;: [],
  &quot;dependencies&quot;: {
    &quot;elm-lang/core&quot;: &quot;5.1.1 &lt;= v &lt; 6.0.0&quot;,
    &quot;elm-lang/html&quot;: &quot;2.0.0 &lt;= v &lt; 3.0.0&quot;
  },
  &quot;elm-version&quot;: &quot;0.18.0 &lt;= v &lt; 0.19.0&quot;
}
</code></pre> <p>We also need to install <strong>Brunch&#39;s Elm</strong> package:</p> <pre><code class="bash">$ cd assets
$ npm install --save-dev elm-brunch
</code></pre> <p>When working with <strong>Elm</strong>, something that I usually do is to create an src folder inside <code>assets/elm</code> where I put there all my <strong>Elm</strong> source files. The reason for this is that I sometimes install third-party libraries, and I like to separate them from my source files, so I place them in an <code>assets/elm/vendor</code> folder. Therefore, don&#39;t forget to change the <code>&quot;source-directories&quot;: [&quot;src&quot;]</code> line, otherwise your <strong>Elm</strong> files are not going to compile at all. We still have to make <strong>Brunch</strong> detect and build <strong>Elm</strong> files, so let&#39;s edit the <strong>Brunch</strong> configuration file once more:</p> <pre><code class="js">// assets/brunch-config.js

exports.config = {
  // See http://brunch.io/#documentation for docs.
  // ...

  // Phoenix paths configuration
  paths: {
    // Dependencies and current project directories to watch
    watched: [&#39;static&#39;, &#39;css&#39;, &#39;js&#39;, &#39;vendor&#39;, &#39;elm&#39;],
    // ...
  },

  // Configure your plugins
  plugins: {
    // ...

    elmBrunch: {
      mainModules: [&#39;src/Main.elm&#39;],
      elmFolder: &#39;elm&#39;,
      outputFolder: &#39;../js/elm&#39;,
      makeParameters: [&#39;--warn&#39;, &#39;--debug&#39;],
    },
  },

//...
}
</code></pre> <p>To test that everything is working fine, let&#39;s create simple main Elm module:</p> <pre><code class="elm">-- assets/elm/src/Main.elm

module Main exposing (main)

import Html exposing (Html)


main : Html msg
main =
    Html.text &quot;Hello, Elm&quot;
</code></pre> <p>Lastly, we have to embed the generated javascript by <strong>Elm</strong> in the <code>index.html</code> template, so let&#39;s edit the main <code>app.js</code> file:</p> <pre><code class="js">// assets/js/app.js

import Elm from &#39;./elm/main&#39;;

const elmContainer = document.querySelector(&#39;#form_container&#39;);

if (elmContainer) {
  const app = Elm.Main.embed(elmContainer);
}
</code></pre> <p>After <strong>Brunch</strong> finishes compiling the assets, we can see the <code>Hello, Elm!</code> message on the right section of the landing page, yay!</p> <p><img src="/images/blog/phoenix-elm-landing-page/hello-elm-4568c617.jpg" alt="Navigation flow" style="background: #fff;"/></p> <h2>The subscription form</h2> <p>The subscription form we need consists of two fields, one for the lead&#39;s full name and another one for the email. Knowing this, let&#39;s start by defining any <strong>Elm</strong> application core element, the model:</p> <pre><code class="elm">-- assets/elm/src/Model.elm

module Model exposing (..)

import Dict exposing (Dict)


type alias FormFields =
    { fullName : String
    , email : String
    }


type alias ValidationErrors =
    Dict String (List String)


type SubscribeForm
    = Editing FormFields
    | Saving FormFields
    | Invalid FormFields ValidationErrors
    | Errored FormFields String
    | Success


type alias Model =
    { subscribeForm : SubscribeForm }


extractFormFields : SubscribeForm -&gt; FormFields
extractFormFields subscribeForm =
    case subscribeForm of
        Editing ff -&gt;
            ff

        Saving ff -&gt;
            ff

        Invalid ff _ -&gt;
            ff

        Errored ff _ -&gt;
            ff

        Success -&gt;
            emptyFormFields


emptyFormFields : FormFields
emptyFormFields =
    { fullName = &quot;&quot;
    , email = &quot;&quot;
    }


extractValidationErrors : SubscribeForm -&gt; ValidationErrors
extractValidationErrors subscribeForm =
    case subscribeForm of
        Invalid _ validationErrors -&gt;
            validationErrors

        _ -&gt;
            emptyValidationErrors


emptyValidationErrors : ValidationErrors
emptyValidationErrors =
    Dict.empty


initialModel : Model
initialModel =
    { subscribeForm = Editing emptyFormFields }

</code></pre> <p><code>Model</code> consists of a record with a <code>subscribeForm</code> key, which is a <strong>union type</strong> representing the form&#39;s current state which can be one of the following:</p> <ul> <li><code>Editing</code> is the initial state when the user is typing on its controls.</li> <li><code>Saving</code> is when the user submits the form, and the Http request with the data is sent to the backend.</li> <li><code>Invalid</code> means that there are validation errors or something went wrong while saving the data.</li> <li><code>Errored</code> for the cases where there is an error not related to validation.</li> <li><code>Success</code> represents that everything went fine, and the lead&#39;s data has been saved into the database.</li> </ul> <p>Depending on the form&#39;s current state, <code>SubscribeForm</code> might have a <code>FormFields</code> record with the current values inserted by the user, and a <code>ValidationErrors</code> type, which consists of a <code>Dict</code> of validation errors by field, or a <code>String</code> containing an error message, which is the case of <code>Errored</code>. But why are we defining the model like this? If you are new to <strong>Elm</strong>, and not very familiar with <strong>union types</strong>, you might have probably defined the model something like:</p> <pre><code class="elm">type Status
    = Editing
    | Saving
    | Invalid
    | Errored
    | Success

type alias Model =
    { formFields : FormFields
    , validationErrors : Dict String (List String)
    , error: String
    , status : Status
    }
</code></pre> <p>This approach is completely fine, until you realize that it can drive to <strong>inconsistent states</strong>, like having a <code>Success</code> state with a nonempty <code>Dict</code> of <code>validationErrors</code> or with an error message string, and you have to make an extra effort to prevent the impossible states, or states that don&#39;t make sense at all. Union types are a very convenient way of avoiding these situations by making the model data depend on the type, <a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">making impossible states impossible</a>.</p> <p>Once the model is defined, let&#39;s continue by implementing the view to represent the model:</p> <pre><code class="elm">-- assets/elm/src/View.elm

module View exposing (view)

import Dict exposing (Dict)
import Html exposing (Html, form)
import Html.Attributes as Html
import Html.Events as Html
import Messages exposing (Msg(..))
import Model exposing (..)


view : Model -&gt; Html Msg
view { subscribeForm } =
    case subscribeForm of
        Success -&gt;
            Html.div
                [ Html.class &quot;success-message&quot; ]
                [ Html.div
                    [ Html.class &quot;icon is-large&quot; ]
                    [ Html.i
                        [ Html.class &quot;fa fa-3x fa-heart&quot; ]
                        []
                    ]
                , Html.h2
                    []
                    [ Html.text &quot;You have subscribed with success&quot; ]
                , Html.p
                    []
                    [ Html.text &quot;We will keep you updated with the latest news&quot; ]
                ]

        _ -&gt;
            formView subscribeForm


formView : SubscribeForm -&gt; Html Msg
formView subscribeForm =
    let
        { fullName, email } =
            extractFormFields subscribeForm

        saving =
            case subscribeForm of
                Saving _ -&gt;
                    True

                _ -&gt;
                    False

        invalid =
            case subscribeForm of
                Invalid _ _ -&gt;
                    True

                _ -&gt;
                    False

        buttonDisabled =
            fullName == &quot;&quot; || email == &quot;&quot; || saving || invalid
    in
        Html.div
            [ Html.class &quot;content&quot; ]
            [ Html.h3
                []
                [ Html.text &quot;Want to know more?&quot; ]
            , Html.p
                []
                [ Html.text &quot;Subscribe to stay updated&quot; ]
            , formError subscribeForm
            , form
                [ Html.onSubmit HandleFormSubmit ]
                [ Html.div
                    [ Html.class &quot;field&quot; ]
                    [ Html.div
                        [ Html.class &quot;control&quot; ]
                        [ Html.input
                            [ Html.classList
                                [ ( &quot;input is-medium&quot;, True )
                                ]
                            , Html.placeholder &quot;My name is...&quot;
                            , Html.required True
                            , Html.value fullName
                            , Html.onInput HandleFullNameInput
                            ]
                            []
                        ]
                    ]
                , Html.div
                    [ Html.class &quot;field&quot; ]
                    [ Html.div
                        [ Html.class &quot;control&quot; ]
                        [ Html.input
                            [ Html.classList
                                [ ( &quot;input is-medium&quot;, True )
                                ]
                            , Html.type_ &quot;email&quot;
                            , Html.placeholder &quot;My email address is...&quot;
                            , Html.required True
                            , Html.value email
                            , Html.onInput HandleEmailInput
                            ]
                            []
                        ]
                    ]
                , Html.div
                    [ Html.class &quot;field&quot; ]
                    [ Html.div
                        [ Html.class &quot;control&quot; ]
                        [ Html.button
                            [ Html.class &quot;button is-primary is-medium&quot;
                            , Html.disabled buttonDisabled
                            ]
                            [ Html.span
                                [ Html.class &quot;icon&quot; ]
                                [ Html.i
                                    [ Html.classList
                                        [ ( &quot;fa fa-check&quot;, not saving )
                                        , ( &quot;fa fa-circle-o-notch fa-spin&quot;, saving )
                                        ]
                                    ]
                                    []
                                ]
                            , Html.span
                                []
                                [ Html.text &quot;Subscribe me&quot; ]
                            ]
                        ]
                    ]
                ]
            ]


formError : SubscribeForm -&gt; Html Msg
formError subscribeForm =
    case subscribeForm of
        Errored _ message -&gt;
            Html.div
                [ Html.class &quot;notification is-danger fade-in&quot; ]
                [ Html.text message ]

        _ -&gt;
            Html.text &quot;&quot;

</code></pre> <p>The <code>view</code> function receives the <code>Model</code> and depending on the value of <code>subscribeForm</code> it renders a success message or the form using the <code>formView</code> function. This function starts by extracting the current <code>formFields</code> values and checking if the form is <code>saving</code> or <code>invalid</code>. With these four values, we define the <code>buttonDisabled</code> value, to disable the submit button if any of the fields are empty or the form is currently invalid or saving the data. Inside the <code>in</code> block, it renders the form, which has the following peculiarities which are worth mentioning:</p> <ul> <li>It sends a <code>HandleFormSubmit</code> message when submitted.</li> <li>It sends a <code>HandleFullNameInput</code> message when the <code>fullName</code> input changes.</li> <li>Same happens for the <code>email</code> input, but with a <code>HandleEmailInput</code> message.</li> <li>The submit button is styled and disabled depending on the current state of <code>subscribeForm</code>.</li> <li>The <code>formError</code> function renders a message box with the error when the form state happens to be <code>Errored</code>.</li> </ul> <p>We have not defined yet the messages that we are using in the view for handling input changes and the form submission, so let&#39;s go ahead and create the messages module to define them:</p> <pre><code class="elm">-- assets/elm/src/Messages.elm

module Messages exposing (Msg(..))

import Dict exposing (Dict)
import Http


type Msg
    = HandleFullNameInput String
    | HandleEmailInput String
    | HandleFormSubmit
</code></pre> <p>Next, let&#39;s create the update module, which handles messages updating the application model:</p> <pre><code class="elm">-- assets/elm/src/Update.elm

module Update exposing (update)

import Messages exposing (Msg(..))
import Model exposing (..)


update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    let
        subscribeForm =
            model.subscribeForm

        formFields =
            extractFormFields model.subscribeForm
    in
        case msg of
            HandleFullNameInput value -&gt;
                { model | subscribeForm = Editing { formFields | fullName = value } } ! []

            HandleEmailInput value -&gt;
                { model | subscribeForm = Editing { formFields | email = value } } ! []

            HandleFormSubmit -&gt;
                { model | subscribeForm = Saving formFields } ! []
</code></pre> <p>When the update function receives either a <code>HandleFullNameInput</code> or a <code>HandleEmailInput</code>, it sets the <code>subscribeForm</code> to <code>Editing</code> applying the current value of the corresponding input. This approach is going to be very convenient while dealing with validation errors as we are going to see in a minute. On the other hand, <code>HandleFormSubmit</code> sets the state to <code>Saving</code> which we are using in the <code>View</code> module to add a spinner and disable the submit button.</p> <p>Last but not least, let&#39;s change the main module to tie everything together:</p> <pre><code class="elm">-- assets/elm/src/Main.elm

module Main exposing (main)

import Html exposing (Html)
import Messages exposing (Msg(..))
import Model exposing (..)
import Update exposing (update)
import View exposing (view)


main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


init : ( Model, Cmd Msg )
init =
    initialModel ! []


subscriptions : Model -&gt; Sub Msg
subscriptions model =
    Sub.none
</code></pre> <p>Everything should be compiling successfully now, so jumping back to the browser we should see the subscription form rendering and ready to send leads subscriptions:</p> <p><img src="/images/blog/phoenix-elm-landing-page/subscription-form-aac366f2.gif" alt="Subscription form" style="background: #fff;"/></p> <h2>Form submission and error handling</h2> <p>The form is submitted using an HTTP request, and for that, we need to install <a href="//package.elm-lang.org/packages/elm-lang/http/latest">Elm&#39;s HTTP package</a>:</p> <pre><code class="sh">$ cd assets/elm
$ elm package install elm-lang/http -y
</code></pre> <p>As an HTTP request involves <strong>side effects</strong>, we have to manage them in Elm using <code>Commands</code>, so let&#39;s create the command for posting the form:</p> <pre><code class="elm">-- assets/elm/src/Commands.elm

import Http
import Json.Decode as JD
import Json.Encode as JE
import Decoders exposing (responseDecoder)
import Messages exposing (Msg(..))
import Model exposing (SubscribeForm(..), FormFields)


subscribe : SubscribeForm -&gt; Cmd Msg
subscribe subscribeForm =
    case subscribeForm of
        Saving formFields -&gt;
            Http.send SubscribeResponse (post formFields)

        _ -&gt;
            Cmd.none


post : FormFields -&gt; Http.Request Bool
post formFields =
    Http.request
        { method = &quot;POST&quot;
        , headers = []
        , url = &quot;/api/v1/leads&quot;
        , body = Http.jsonBody (encodeModel formFields)
        , expect = Http.expectJson responseDecoder
        , timeout = Nothing
        , withCredentials = False
        }


encodeModel : FormFields -&gt; JD.Value
encodeModel { fullName, email } =
    JE.object
        [ ( &quot;lead&quot;
          , JE.object
                [ ( &quot;full_name&quot;, JE.string fullName )
                , ( &quot;email&quot;, JE.string email )
                ]
          )
        ]
</code></pre> <p>In the <code>subscribe</code> function we can find another example of how convenient are union types. We want to post the data only when the form&#39;s status is <code>Saving</code> and not when there are validation errors for instance. <code>Http.send</code> receives the <code>SubscribeForm</code> message, used to handle the result and the post request. This request consists of a record that has all the details of the request, including the <code>JSON</code> body which is the encoded form fields, and the logic to handle the expected response in the expect field, in our case a <code>JSON</code> decoder <code>responseDecoder</code> that we have to create:</p> <pre><code class="elm">-- assets/elm/src/Decoders.elm

module Decoders exposing (..)

import Json.Decode as Decode
import Model exposing (ValidationErrors)


responseDecoder : Decode.Decoder Bool
responseDecoder =
    Decode.succeed True
</code></pre> <p>As we do not care about the payload that the <code>LeadController</code> is returning once the lead subscribes successfully, the <code>responseDecoder</code> function decodes anything received into a <code>True</code> value. Next step for handling the response is to add the <code>SubscribeResponse</code> message to the <code>Messages</code> module:</p> <pre><code class="elm">-- assets/elm/src/Messages.elm

module Messages exposing (Msg(..))

import Dict exposing (Dict)
import Http


type Msg
    = HandleFullNameInput String
    | HandleEmailInput String
    | HandleFormSubmit
    | SubscribeResponse (Result Http.Error Bool)
</code></pre> <p>And, of course, the necessary handle clause in the <code>Update.update</code> function:</p> <pre><code class="elm">-- assets/elm/src/Update.elm

module Update exposing (update)

-- ...

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    let
        subscribeForm =
            model.subscribeForm

        formFields =
            extractFormFields model.subscribeForm
    in
        case msg of
            -- ...

            SubscribeResponse (Ok result) -&gt;
                { model | subscribeForm = Success } ! []

            SubscribeResponse (Err (BadStatus response)) -&gt;
                case Decode.decodeString validationErrorsDecoder response.body of
                    Ok validationErrors -&gt;
                        { model | subscribeForm = Invalid formFields validationErrors } ! []

                    Err error -&gt;
                        { model | subscribeForm = Errored formFields &quot;Oops! Something went wrong!&quot; } ! []

            SubscribeResponse (Err error) -&gt;
                { model | subscribeForm = Errored formFields &quot;Oops! Something went wrong!&quot; } ! []
</code></pre> <p>The <code>Result</code> of the form post can be either an <code>Ok True</code>, meaning that everything went fine setting the <code>subscribeForm</code> to <code>Success</code>, or an <code>Http.Error</code>, which is another union type describing the reason for the error. In our case, we only want to handle validation errors, so it patterns matches against <code>BadStatus</code> response, using the <code>validationErrorsDecoder</code> to decode response which is the error list returned by the <code>LandingPageWeb.FallbackController</code> that we created in the previous part. If there is any other sort of error, it sets the form to <code>Errored</code> with a custom error message. To make it work properly, let&#39;s implement the missing <code>validationErrorsDecoder</code>:</p> <pre><code class="elm">-- assets/elm/src/Decoders.elm

module Decoders exposing (..)

import Json.Decode as Decode
import Model exposing (ValidationErrors)

-- ...

validationErrorsDecoder : Decode.Decoder ValidationErrors
validationErrorsDecoder =
    Decode.dict &lt;| Decode.list Decode.string
</code></pre> <p>The new decoder transforms the response into a <code>ValidationErrors</code> which is a <code>Dict</code> where its keys are field names, and the values are a list of errors, that we can now render in the view:</p> <pre><code class="elm">-- assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&gt; Html Msg
formView subscribeForm =
    let
        validationErrors =
            extractValidationErrors subscribeForm

        -- ...
    in
        -- ...

        , form
            [ Html.onSubmit HandleFormSubmit ]
            [ Html.div
                [ Html.class &quot;field&quot; ]
                [ Html.div
                    [ Html.class &quot;control&quot; ]
                    [ Html.input
                        [ Html.classList
                            [ ( &quot;input is-medium&quot;, True )
                            , ( &quot;is-danger&quot;, Dict.member &quot;full_name&quot; validationErrors )
                            ]
                        , Html.placeholder &quot;My name is...&quot;
                        , Html.required True
                        , Html.value fullName
                        , Html.onInput HandleFullNameInput
                        ]
                        []
                    , validationErrorView &quot;full_name&quot; validationErrors
                    ]
                ]
            , Html.div
                [ Html.class &quot;field&quot; ]
                [ Html.div
                    [ Html.class &quot;control&quot; ]
                    [ Html.input
                                [ Html.classList
                                    [ ( &quot;input is-medium&quot;, True )
                                    , ( &quot;is-danger&quot;, Dict.member &quot;email&quot; validationErrors )
                                    ]
                                , Html.type_ &quot;email&quot;
                                , Html.placeholder &quot;My email address is...&quot;
                                , Html.required True
                                , Html.value email
                                , Html.onInput HandleEmailInput
                                ]
                                []
                            , validationErrorView &quot;email&quot; validationErrors
                            ]
                      ]

                      -- ...


validationErrorView : String -&gt; ValidationErrors -&gt; Html Msg
validationErrorView key validationErrors =
    case Dict.get key validationErrors of
        Just error -&gt;
            error
                |&gt; List.map Html.text
                |&gt; Html.p
                    [ Html.class &quot;help is-danger&quot; ]

        Nothing -&gt;
            Html.text &quot;&quot;
</code></pre> <p>Using the <code>extractValidationErrors</code> helper function from the <code>Model</code> module, it gets the possible <code>validationErrors</code> and not only sets an is-danger class to the fields when it happens to have errors but calls <code>validationErrorView</code> to render them.</p> <h2>The final result</h2> <p>It is time to test out our work so far. Let&#39;s jump back to the browser and try to subscribe using valid values:</p> <p><img src="/images/blog/phoenix-elm-landing-page/success-message-23c4501c.gif" alt="Success message" style="background: #fff;"/></p> <p>Submitting the form returns a <code>200</code> success message which changes the <code>subscribeForm</code> to <code>Success</code>, displaying the success message. Next, let&#39;s try subscribing again using the same email:</p> <p><img src="/images/blog/phoenix-elm-landing-page/validation-error-92641ea0.gif" alt="Validation errors" style="background: #fff;"/></p> <p>This time the server returns a <code>422</code> unprocessable entity status, with an error message for the <code>email</code> field, as it is already taken, cool! Finally, let&#39;s try to stop the Phoenix server and submit the form once more to simulate an unexpected response:</p> <p><img src="/images/blog/phoenix-elm-landing-page/unknown-error-2bf4071b.gif" alt="Unknown error" style="background: #fff;"/></p> <p>As the server is down, the request fails, rendering the generic error message that we have previously set for nonvalidation errors.</p> <p>Our new landing page is looking pretty good so far, though we haven&#39;t finished yet. In the next episode, we are going to add some protection against spam bots using <a href="https://developers.google.com/recaptcha/">Googles reCAPTCHA</a>, which not only implies using an external javascript library from our Elm code but consuming a third party API from our backend. In the meantime, you can check out the source code of the part <a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-2">here</a>.</p> <p>Merry Christmas and Happy New Coding Year!</p> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'codeloveandboards'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <noscript> Please enable JavaScript to view the <a href='//disqus.com/?ref_noscript'>comments powered by Disqus.</a> </noscript> <a class=dsq-brlink href='//disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </section> </div> </section> <footer id=main_footer> <ul class=article-nav> <li class=previous> <a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"><h4>previous post</h4> <h3> Phoenix & Elm landing page (pt.1) </h3> <div class=meta-data> <hr> posted Dec 2, 2017 on elixir, phoenix, elm </div> </a> </li> <li class=next> <a href="/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"><h4>next post</h4> <h3> Phoenix & Elm landing page (pt.3) </h3> <div class=meta-data> <hr> posted Jan 6, 2018 on elixir, phoenix, elm </div> </a> </li> </ul> <section> <div class=container> <div class=center> <ul> <li> <a href='/blog'>Archives</a> </li> <li> <a href='//feeds.feedburner.com/CodeLoveAndBoards' target=_blank>RSS</a> </li> </ul> Copyright © 2018 - Ricardo García Vega - Code, Love & Boards! </div> </div> </section> </footer> <script src="../../../../../javascripts/blog-5ddb0520.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-37802122-1', 'codeloveandboards.com');
  ga('send', 'pageview');
</script> <script>
  _StatHat.push(["_trackCount", "g2pcD9xou7DlR0DtndiwvSBBYU5k", 1.0]);
</script> </body> </html>
<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8 lt-ie7" lang=en-us><![endif]--> <!--[if IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8" lang=en-us><![endif]--> <!--[if IE 8]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if IE 9]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if lt IE 10]><html class="no-js lt-ie10" lang=en-us><![endif]--> <!--[if !IE]>><![endif]--> <html class=no-js lang=en> <head> <title>Trello tribute with Phoenix and React (pt.3) - Code, Love & Boards</title> <meta charset=utf-8 content='text/html' http-equiv=content-type> <meta content='ie=edge,chrome=1' http-equiv=x-ua-compatible> <meta content='Defining the User model and adding JWT authentication to our Phoenix Trello clone.' name=description> <meta content='Ricardo García Vega - http://twitter.com/bigardone' name=author> <meta content='elixir, phoenix, ecto' name=keywords> <meta content='initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width' name=viewport> <link href='//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css' rel=stylesheet> <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Lora:400,700" media=screen rel=stylesheet /> <link href="../../../../../stylesheets/blog-82c14d7c.css" media=all rel=stylesheet /> <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elixir.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elm.min.js'></script> <link href='/images/apple-touch-icon-57x57-6e598dc4.png' rel=apple-touch-icon sizes=57x57> <link href='/images/apple-touch-icon-114x114-5be964ba.png' rel=apple-touch-icon sizes=114x114> <link href='/images/apple-touch-icon-72x72-70084a85.png' rel=apple-touch-icon sizes=72x72> <link href='/images/apple-touch-icon-144x144-1dbb56c1.png' rel=apple-touch-icon sizes=144x144> <link href='/images/apple-touch-icon-60x60-d05a5ea9.png' rel=apple-touch-icon sizes=60x60> <link href='/images/apple-touch-icon-120x120-5dafce59.png' rel=apple-touch-icon sizes=120x120> <link href='/images/apple-touch-icon-76x76-b2c0d784.png' rel=apple-touch-icon sizes=76x76> <link href='/images/apple-touch-icon-152x152-45595360.png' rel=apple-touch-icon sizes=152x152> <link href='/images/favicon-160x160-944ce76e.png' rel=icon sizes=160x160 type='image/png'> <link href='/images/favicon-96x96-b7e4e089.png' rel=icon sizes=96x96 type='image/png'> <link href='/images/favicon-32x32-b7f34a79.png' rel=icon sizes=32x32 type='image/png'> <link href='/images/favicon-16x16-2712c528.png' rel=icon sizes=16x16 type='image/png'> <meta content='#9f00a7' name=msapplication-TileColor> <meta content='/images/mstile-144x144-028d4c4c.png' name=msapplication-TileImage> <script>
  var _StatHat = _StatHat || [];
  _StatHat.push(['_setUser', 'NzIzMCDaNaL5bvEP1HQkMYwfYsQe']);
  (function() {
          var sh = document.createElement('script'); sh.type = 'text/javascript';
          sh.async = true;
          sh.src = '//www.stathat.com/javascripts/api.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(sh, s);
  })();
</script> <link href='https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-3' rel=canonical> <link href='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js'></script> <script>
  window.addEventListener("load", function(){
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#252e39"
      },
      "button": {
        "background": "#217dbb"
      }
    },
    "theme": "classic",
    "position": "bottom-right"
  })});
</script> </head> <body class=blog> <header id=main_header> <div class=main-logo> <a href="/"><img src="../../../../../images/logo-cd52bd68.png"/> </a> </div> <div class=container> <section class=center> <h1>Trello tribute with Phoenix and React (pt.3)</h1> <h3></h3> <div class=meta-data> <hr> posted Jan 12, 2016 on <a class=tag href="/blog/tags/elixir.html">elixir</a> <a class=tag href="/blog/tags/phoenix.html">phoenix</a> <a class=tag href="/blog/tags/ecto.html">ecto</a> </div> </section> </div> </header> <section id=main_content> <div class=container> <section> <article> <div class=index> <p>This post belongs to the <strong>Trello tribute with Phoenix Framework and React</strong> series.</p> <ol> <li><a href="/blog/2016/01/04/trello-tribute-with-phoenix-and-react-pt-1">Intro and selected stack</a></li> <li><a href="/blog/2016/01/11/trello-tribute-with-phoenix-and-react-pt-2">Phoenix Framework project setup</a></li> <li><a href="/blog/2016/01/12/trello-tribute-with-phoenix-and-react-pt-3">The User model and JWT auth</a></li> <li><a href="/blog/2016/01/14/trello-tribute-with-phoenix-and-react-pt-4/">Front-end for sign up with React and Redux</a></li> <li><a href="/blog/2016/01/18/trello-tribute-with-phoenix-and-react-pt-5/">Database seeding and sign in controller</a></li> <li><a href="/blog/2016/01/20/trello-tribute-with-phoenix-and-react-pt-6/">Front-end authentication with React and Redux</a></li> <li><a href="/blog/2016/01/25/trello-tribute-with-phoenix-and-react-pt-7/">Sockets and channels</a></li> <li><a href="/blog/2016/01/28/trello-tribute-with-phoenix-and-react-pt-8/">Listing and creating boards</a></li> <li><a href="/blog/2016/02/04/trello-tribute-with-phoenix-and-react-pt-9/">Adding new board members</a></li> <li><a href="/blog/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/">Tracking connected board members</a></li> <li><a href="/blog/2016/02/24/trello-tribute-with-phoenix-and-react-pt-11/">Adding lists and cards</a></li> <li><a href="/blog/2016/03/04/trello-tribute-with-phoenix-and-react-pt-12/">Deploying our application on Heroku</a></li> </ol> <a href="https://phoenix-trello.herokuapp.com/"><i class="fa fa-cloud"></i> Live demo</a> | <a href="https://github.com/bigardone/phoenix-trello"><i class="fa fa-github"></i> Source code</a> </div> <h2>User sign up</h2> <p>Now that we have our <a title="Part 2" href="/blog/2016/01/11/trello-tribute-with-phoenix-and-react-pt-2">project all set up</a>, we are ready to create the <code>User</code> database migration and model. In this post we will see how to do this and also how to let a visitor create a new user account.</p> <h3>The User migration and model</h3> <p><strong>Phoenix</strong> uses <a title=Ecto href="https://github.com/elixir-lang/ecto">Ecto</a> for wrapping any interaction needed with the database. If we were using <strong>Rails</strong> we could say that <strong>Ecto</strong> would be something similar to <strong>ActiveRecord</strong> although it separates all the similar functionality into different modules.</p> <p>Before continuing we have to create the database by running:</p> <pre><code class="bash">$ mix ecto.create
</code></pre> <p>Now let&#39;s create the new <strong>Ecto</strong> migration and model. The model generation task receives as parameters the module name, its plural form for the schema name and the fields it&#39;s going to have using a <code>name:type</code> syntax, so let&#39;s run it:</p> <pre><code class="bash">$ mix phoenix.gen.model User users first_name:string last_name:string email:string encrypted_password:string
</code></pre> <p>If we take a look to the migration file just created we can notice instantly its similarities with a <strong>Rails</strong> migration file:</p> <pre><code class="elixir"># priv/repo/migrations/20151224075404_create_user.exs

defmodule PhoenixTrello.Repo.Migrations.CreateUser do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :first_name, :string, null: false
      add :last_name, :string, null: false
      add :email, :string, null: false
      add :encrypted_password, :string, null: false

      timestamps
    end

    create unique_index(:users, [:email])
  end
end

</code></pre> <p>I&#39;ve added <code>null</code> restrictions to the fields and even a unique index to the email. This is because I like the database to be responsible for the data integrity instead of relying on the application to do so as many other developers do. It&#39;s just a matter of personal preferences I guess.</p> <p>Now that the migration file is ready, let&#39;s run it to create the <code>users</code> database table:</p> <pre><code class="bash">$ mix ecto.migrate
</code></pre> <p>Now it&#39;s time to take a closer look to the <code>User</code> model:</p> <pre><code class="elixir"># web/models/user.ex

defmodule PhoenixTrello.User do
  use Ecto.Schema
  import Ecto.Changeset

  schema &quot;users&quot; do
    field :first_name, :string
    field :last_name, :string
    field :email, :string
    field :encrypted_password, :string

    timestamps
  end

  @required_fields ~w(first_name last_name email)
  @optional_fields ~w(encrypted_password)

  def changeset(model, params \\ %{}) do
    model
    |&gt; cast(params, @required_fields, @optional_fields)
  end
end
</code></pre> <p>Here can find two main different sections:</p> <ul> <li>The <strong>schema block</strong> where we have all the metadata regarding table fields.</li> <li>The <strong>changeset</strong> function, where we can define all validations and transformations applied to the data before being ready to use it in our application.</li> </ul> <h3>Changeset validations and transformations</h3> <p>So when a user signs up we want to add some validations to the process because we have previously added null restrictions to the table fields, and a unique constraint to the email. We have to reflect this on the <code>User</code> model in order to handle possible runtime errors caused by invalid data. We also want to encrypt the <code>encrypted_password</code> field so even though we will use plain strings to specify a user&#39;s password, it will be inserted in a secure way.</p> <p>Let&#39;s update the model and add some validations first:</p> <pre><code class="elixir"># web/models/user.ex

defmodule PhoenixTrello.User do
  # ...

  schema &quot;users&quot; do
    # ...
    field :password, :string, virtual: true
    # ...
  end

  @required_fields ~w(first_name last_name email password)
  @optional_fields ~w(encrypted_password)

  def changeset(model, params \\ %{}) do
    model
    |&gt; cast(params, @required_fields, @optional_fields)
    |&gt; validate_format(:email, ~r/@/)
    |&gt; validate_length(:password, min: 5)
    |&gt; validate_confirmation(:password, message: &quot;Password does not match&quot;)
    |&gt; unique_constraint(:email, message: &quot;Email already taken&quot;)
  end
end
</code></pre> <p>Basically we&#39;ve done the following modifications:</p> <ul> <li>Added a new virtual <code>password</code> field which will not be inserted into the database but can be used as any other field for any other purpose. In our case it will be populated from the sign up form.</li> <li>Make the <code>password</code> field required.</li> <li>Added a validation to check the <code>email</code> format.</li> <li>Added a validation to check if the <code>password</code> length is at least 5 chars long and also a it will check in the params if the <code>password_confirmation</code> has the same value.</li> <li>Added a unique constraint to check if the <code>email</code> already exists.</li> </ul> <p>With all these changes we have our validations covered. But we also need to fill the <code>encrypted_password</code> field before saving the data. To do so, let&#39;s use the <a title=Comeonin href="https://github.com/elixircnx/comeonin">comeonin</a> password hashing library by adding it to the <code>mix.exs</code> file as an application and dependency:</p> <pre><code class="elixir"># mix.exs

defmodule PhoenixTrello.Mixfile do
  use Mix.Project
  # ...

  def application do
    [mod: {PhoenixTrello, []},
     applications: [
       # ...
       :comeonin
       ]
     ]
  end

  #...

  defp deps do
    [
      # ...
      {:comeonin, &quot;~&gt; 2.5.3&quot;},
      # ...
    ]
  end
end
</code></pre> <p>Don&#39;t forget to install by running:</p> <pre><code class="bash">$ mix deps.get

</code></pre> <p>Now that we have <strong>comeonin</strong> installed let&#39;s get back to the <code>User</code> model and add a new step in the <strong>changeset</strong> pipeline to generate the <code>encrypted_password</code> field:</p> <pre><code class="elixir"># web/models/user.ex

defmodule PhoenixTrello.User do
  # ...

  def changeset(model, params \\ %{}) do
    model
    # ... other validations and contraints
    |&gt; generate_encrypted_password
  end

  defp generate_encrypted_password(current_changeset) do
    case current_changeset do
      %Ecto.Changeset{valid?: true, changes: %{password: password}} -&gt;
        put_change(current_changeset, :encrypted_password, Comeonin.Bcrypt.hashpwsalt(password))
      _ -&gt;
        current_changeset
    end
  end
end
</code></pre> <p>In this new method we first check if the changeset is valid and if the <code>password</code> has changed. If so, we encrypt the password using <strong>comeonin</strong> and put it in the <code>encrypted_password</code> field of the changeset, otherwise we just return the changeset.</p> <h3>The router</h3> <p>Now that our <code>User</code> model is ready let&#39;s continue implementing the sign up process by modifying the <code>router.ex</code> file to create the <code>:api</code> pipeline and our first route:</p> <pre><code class="elixir"># web/router.ex

defmodule PhoenixTrello.Router do
  use PhoenixTrello.Web, :router

  #...

  pipeline :api do
    plug :accepts, [&quot;json&quot;]
  end

  scope &quot;/api&quot;, PhoenixTrello do
    pipe_through :api

    scope &quot;/v1&quot; do
      post &quot;/registrations&quot;, RegistrationController, :create
    end
  end

  #...
end

</code></pre> <p>So any <code>POST</code> request to <code>/api/v1/registrations</code> will be processed by the <code>create</code> action of the <code>RegistrationController</code> accepting <strong>json</strong>... quite self explanatory :)</p> <h3>The controller</h3> <p>Before implementing the controller let&#39;s think about what we need. The visitor will visit the sign up page, fill the form and submit it. If the data received by the controller is valid then we want to insert a new <code>User</code> into the database, sign it into the system and return its data along with the <a title=JWT href="https://en.wikipedia.org/wiki/JSON_Web_Token">jwt</a> authentication token resulting of the signing process as <strong>json</strong> to the front-end. This token is the one we are going to need not only to send it in every request to authenticate the user, but also for allowing the user to access the private screens of the application.</p> <p>To handle this authentication and <strong>jwt</strong> generation we are going to use the <a title=Guardian href="https://github.com/ueberauth/guardian">Guardian</a> library which works really well. Just add it to the <code>mix.exs</code> file:</p> <pre><code class="elixir"># mix.exs

defmodule PhoenixTrello.Mixfile do
  use Mix.Project

  #...

  defp deps do
    [
      # ...
      {:guardian, &quot;~&gt; 0.13.0&quot;},
      # ...
    ]
  end
end
</code></pre> <p>After running <code>mix deps.get</code> we need to configure it in the <code>config.exs</code> file:</p> <pre><code class="elixir"># config/confg.exs

#...

config :guardian, Guardian,
  issuer: &quot;PhoenixTrello&quot;,
  ttl: { 3, :days },
  verify_issuer: true,
  secret_key: &lt;your guardian secret key&gt;,
  serializer: PhoenixTrello.GuardianSerializer
</code></pre> <p>We also need to create the <code>GuardianSerializer</code> that will tell <strong>Guardian</strong> how to encode and decode the user into and out of the token:</p> <pre><code class="elixir"># lib/phoenix_trello/guardian_serializer.ex

defmodule PhoenixTrello.GuardianSerializer do
  @behaviour Guardian.Serializer

  alias PhoenixTrello.{Repo, User}

  def for_token(user = %User{}), do: { :ok, &quot;User:#{user.id}&quot; }
  def for_token(_), do: { :error, &quot;Unknown resource type&quot; }

  def from_token(&quot;User:&quot; &lt;&gt; id), do: { :ok, Repo.get(User, String.to_integer(id)) }
  def from_token(_), do: { :error, &quot;Unknown resource type&quot; }
end

</code></pre> <p>Now that everything is ready let&#39;s implement the <code>RegistrationController</code>:</p> <pre><code class="elixir"># web/controllers/api/v1/registration_controller.ex

defmodule PhoenixTrello.RegistrationController  do
  use PhoenixTrello.Web, :controller

  alias PhoenixTrello.{Repo, User}

  plug :scrub_params, &quot;user&quot; when action in [:create]

  def create(conn, %{&quot;user&quot; =&gt; user_params}) do
    changeset = User.changeset(%User{}, user_params)

    case Repo.insert(changeset) do
      {:ok, user} -&gt;
        {:ok, jwt, _full_claims} = Guardian.encode_and_sign(user, :token)

        conn
        |&gt; put_status(:created)
        |&gt; render(PhoenixTrello.SessionView, &quot;show.json&quot;, jwt: jwt, user: user)

      {:error, changeset} -&gt;
        conn
        |&gt; put_status(:unprocessable_entity)
        |&gt; render(PhoenixTrello.RegistrationView, &quot;error.json&quot;, changeset: changeset)
    end
  end
end

</code></pre> <p>Thanks to <strong>Elixir</strong>&#39;s <a href="//elixir-lang.org/getting-started/pattern-matching.html">pattern matching</a> the <code>create</code> action expects a <code>&quot;user&quot;</code> key inside the params. With these params we will create a new <code>User</code> changeset and insert it. If everything goes ok we use <strong>Guardian</strong> to <code>encode_and_sign</code> the new user retrieving the <code>jwt</code> token and render it with the user as <strong>json</strong>. Otherwise, if the changeset is invalid, we will render the errors as <strong>json</strong> so we can show them to the user in the registration form.</p> <h3>JSON serialization</h3> <p><strong>Phoenix</strong> uses <a title=Poison href="https://github.com/devinus/poison">Poison</a> as its default <strong>JSON</strong> library. As it&#39;s one of <strong>Phoenix</strong>&#39;s dependencies we don&#39;t have to do anything special to install it. What we have to do is to update the <code>User</code> model to specify which fields we need to serialize:</p> <pre><code class="elixir"># web/models/user.ex

defmodule PhoenixTrello.User do
  use PhoenixTrello.Web, :model
  # ...

   @derive {Poison.Encoder, only: [:id, :first_name, :last_name, :email]}

   # ...
 end
</code></pre> <p>From now on when we render a user, or list of users, as the response of a controller action or channel it will just return those specified fields. Easy as pie!</p> <p>Having our back-end ready for registering new users in the next post we will move to our front-end and code some <strong>React</strong> and <strong>Redux</strong> fun stuff to finish the sign up process. Meanwhile, don&#39;t forget to check out the live demo and final source code:</p> <div class=btn-wrapper> <a href="https://phoenix-trello.herokuapp.com/" target=_blank class=btn><i class="fa fa-cloud"></i> Live demo</a> <a href="https://github.com/bigardone/phoenix-trello" target=_blank class=btn><i class="fa fa-github"></i> Source code</a> </div> <p>Happy coding!</p> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'codeloveandboards'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <noscript> Please enable JavaScript to view the <a href='//disqus.com/?ref_noscript'>comments powered by Disqus.</a> </noscript> <a class=dsq-brlink href='//disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </section> </div> </section> <footer id=main_footer> <ul class=article-nav> <li class=previous> <a href="/blog/2016/01/11/trello-tribute-with-phoenix-and-react-pt-2/"><h4>previous post</h4> <h3> Trello tribute with Phoenix and React (pt.2) </h3> <div class=meta-data> <hr> posted Jan 11, 2016 on elixir, phoenix, react, webpack, redux </div> </a> </li> <li class=next> <a href="/blog/2016/01/14/trello-tribute-with-phoenix-and-react-pt-4/"><h4>next post</h4> <h3> Trello tribute with Phoenix and React (pt.4) </h3> <div class=meta-data> <hr> posted Jan 14, 2016 on elixir, phoenix, react, redux </div> </a> </li> </ul> <section> <div class=container> <div class=center> <ul> <li> <a href='/blog'>Archives</a> </li> <li> <a href='//feeds.feedburner.com/CodeLoveAndBoards' target=_blank>RSS</a> </li> </ul> Copyright © 2020 - Ricardo García Vega - Code, Love & Boards! </div> </div> </section> </footer> <script src="../../../../../javascripts/blog-5ddb0520.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-37802122-1', 'codeloveandboards.com');
  ga('send', 'pageview');
</script> <script>
  _StatHat.push(["_trackCount", "g2pcD9xou7DlR0DtndiwvSBBYU5k", 1.0]);
</script> </body> </html>
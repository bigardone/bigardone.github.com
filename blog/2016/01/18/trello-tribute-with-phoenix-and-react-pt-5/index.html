<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8 lt-ie7" lang=en-us><![endif]--> <!--[if IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8" lang=en-us><![endif]--> <!--[if IE 8]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if IE 9]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if lt IE 10]><html class="no-js lt-ie10" lang=en-us><![endif]--> <!--[if !IE]>><![endif]--> <html class=no-js lang=en> <head> <title>Trello tribute with Phoenix and React (pt.5) - Code, Love & Boards</title> <meta charset=utf-8 content='text/html' http-equiv=content-type> <meta content='ie=edge,chrome=1' http-equiv=x-ua-compatible> <meta content='Seeding the database and creating the sign in controller for the Phoenix Trello Clone.' name=description> <meta content='Ricardo García Vega - http://twitter.com/bigardone' name=author> <meta content='elixir, phoenix, ecto' name=keywords> <meta content='initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width' name=viewport> <link href='//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css' rel=stylesheet> <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Lora:400,700" media=screen rel=stylesheet /> <link href="../../../../../stylesheets/blog-82c14d7c.css" media=all rel=stylesheet /> <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elixir.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elm.min.js'></script> <link href='/images/apple-touch-icon-57x57-6e598dc4.png' rel=apple-touch-icon sizes=57x57> <link href='/images/apple-touch-icon-114x114-5be964ba.png' rel=apple-touch-icon sizes=114x114> <link href='/images/apple-touch-icon-72x72-70084a85.png' rel=apple-touch-icon sizes=72x72> <link href='/images/apple-touch-icon-144x144-1dbb56c1.png' rel=apple-touch-icon sizes=144x144> <link href='/images/apple-touch-icon-60x60-d05a5ea9.png' rel=apple-touch-icon sizes=60x60> <link href='/images/apple-touch-icon-120x120-5dafce59.png' rel=apple-touch-icon sizes=120x120> <link href='/images/apple-touch-icon-76x76-b2c0d784.png' rel=apple-touch-icon sizes=76x76> <link href='/images/apple-touch-icon-152x152-45595360.png' rel=apple-touch-icon sizes=152x152> <link href='/images/favicon-160x160-944ce76e.png' rel=icon sizes=160x160 type='image/png'> <link href='/images/favicon-96x96-b7e4e089.png' rel=icon sizes=96x96 type='image/png'> <link href='/images/favicon-32x32-b7f34a79.png' rel=icon sizes=32x32 type='image/png'> <link href='/images/favicon-16x16-2712c528.png' rel=icon sizes=16x16 type='image/png'> <meta content='#9f00a7' name=msapplication-TileColor> <meta content='/images/mstile-144x144-028d4c4c.png' name=msapplication-TileImage> <script>
  var _StatHat = _StatHat || [];
  _StatHat.push(['_setUser', 'NzIzMCDaNaL5bvEP1HQkMYwfYsQe']);
  (function() {
          var sh = document.createElement('script'); sh.type = 'text/javascript';
          sh.async = true;
          sh.src = '//www.stathat.com/javascripts/api.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(sh, s);
  })();
</script> <link href='https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-5' rel=canonical> <link href='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js'></script> <script>
  window.addEventListener("load", function(){
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#252e39"
      },
      "button": {
        "background": "#217dbb"
      }
    },
    "theme": "classic",
    "position": "bottom-right"
  })});
</script> </head> <body class=blog> <header id=main_header> <div class=main-logo> <a href="/"><img src="../../../../../images/logo-cd52bd68.png"/> </a> </div> <div class=container> <section class=center> <h1>Trello tribute with Phoenix and React (pt.5)</h1> <h3></h3> <div class=meta-data> <hr> posted Jan 18, 2016 on <a class=tag href="/blog/tags/elixir.html">elixir</a> <a class=tag href="/blog/tags/phoenix.html">phoenix</a> <a class=tag href="/blog/tags/ecto.html">ecto</a> </div> </section> </div> </header> <section id=main_content> <div class=container> <section> <article> <div class=index> <p>This post belongs to the <strong>Trello tribute with Phoenix Framework and React</strong> series.</p> <ol> <li><a href="/blog/2016/01/04/trello-tribute-with-phoenix-and-react-pt-1">Intro and selected stack</a></li> <li><a href="/blog/2016/01/11/trello-tribute-with-phoenix-and-react-pt-2">Phoenix Framework project setup</a></li> <li><a href="/blog/2016/01/12/trello-tribute-with-phoenix-and-react-pt-3">The User model and JWT auth</a></li> <li><a href="/blog/2016/01/14/trello-tribute-with-phoenix-and-react-pt-4/">Front-end for sign up with React and Redux</a></li> <li><a href="/blog/2016/01/18/trello-tribute-with-phoenix-and-react-pt-5/">Database seeding and sign in controller</a></li> <li><a href="/blog/2016/01/20/trello-tribute-with-phoenix-and-react-pt-6/">Front-end authentication with React and Redux</a></li> <li><a href="/blog/2016/01/25/trello-tribute-with-phoenix-and-react-pt-7/">Sockets and channels</a></li> <li><a href="/blog/2016/01/28/trello-tribute-with-phoenix-and-react-pt-8/">Listing and creating boards</a></li> <li><a href="/blog/2016/02/04/trello-tribute-with-phoenix-and-react-pt-9/">Adding new board members</a></li> <li><a href="/blog/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/">Tracking connected board members</a></li> <li><a href="/blog/2016/02/24/trello-tribute-with-phoenix-and-react-pt-11/">Adding lists and cards</a></li> <li><a href="/blog/2016/03/04/trello-tribute-with-phoenix-and-react-pt-12/">Deploying our application on Heroku</a></li> </ol> <a href="https://phoenix-trello.herokuapp.com/"><i class="fa fa-cloud"></i> Live demo</a> | <a href="https://github.com/bigardone/phoenix-trello"><i class="fa fa-github"></i> Source code</a> </div> <h2>User sign in</h2> <p>In the last <a title="Part 3" href="/blog/2016/01/12/trello-tribute-with-phoenix-and-react-pt-3">two</a> <a title="Part 4" href="/blog/2n016/01/14/trello-tribute-with-phoenix-and-react-pt-4">posts</a> we prepared everything so that visitors could sign up and create new user accounts. In this part we are going to see how to seed the database with some predefined users. We are also going to create the necessary functionality to let visitors sign in using their email and password. Finally we will create a mechanism to retrieve the users data from their authentication token.</p> <h3>Seeding the database</h3> <p>If you have any previous experience with <strong>Rails</strong> then you will find that seeding the database in <strong>Phoenix</strong> is very similar. To do so, we just need to have a <code>seedx.exs</code> file:</p> <pre><code class="elixir"># priv/repo/seeds.exs

alias PhoenixTrello.{Repo, User}

[
  %{
    first_name: &quot;John&quot;,
    last_name: &quot;Doe&quot;,
    email: &quot;john@phoenix-trello.com&quot;,
    password: &quot;12345678&quot;
  },
]
|&gt; Enum.map(&amp;User.changeset(%User{}, &amp;1))
|&gt; Enum.each(&amp;Repo.insert!(&amp;1))

</code></pre> <p>In this file we basically insert into the database all the necessary data we want our application to have as initial data. If you want to have any other user just add it to the list and run the seed file like this:</p> <pre><code>$ mix run priv/repo/seeds.exs
</code></pre> <h3>The sign in controller</h3> <p>Before creating the controller we need to make some modifications to the <code>router.ex</code> file:</p> <pre><code class="ruby"># web/router.ex

defmodule PhoenixTrello.Router do
  use PhoenixTrello.Web, :router

  #...

  pipeline :api do
    # ...

    plug Guardian.Plug.VerifyHeader
    plug Guardian.Plug.LoadResource
  end

  scope &quot;/api&quot;, PhoenixTrello do
    pipe_through :api

    scope &quot;/v1&quot; do
      # ...

      post &quot;/sessions&quot;, SessionController, :create
      delete &quot;/sessions&quot;, SessionController, :delete

      # ...
    end
  end

  #...
end

</code></pre> <p>Our first change is to add two new <a href="//www.phoenixframework.org/docs/understanding-plug">plugs</a> to the <code>:api</code> pipeline:</p> <ul> <li><strong>VerifyHeader</strong>: this plug just looks for the token in the <code>Authorization</code> header.</li> <li><strong>LoadResource</strong>: makes the current resource available through <code>Guardian.Plug.current_resource(conn)</code> if the token is present.</li> </ul> <p>We also need to add two more routes to the <code>/api/v1</code> scope for creating and destroying the user&#39;s session, both processed by the <code>SessionController</code>. Let&#39;s begin with the <code>create</code> action:</p> <pre><code class="ruby"># web/controllers/api/v1/session_controller.ex

defmodule PhoenixTrello.SessionController do
  use PhoenixTrello.Web, :controller

  plug :scrub_params, &quot;session&quot; when action in [:create]

  def create(conn, %{&quot;session&quot; =&gt; session_params}) do
    case PhoenixTrello.Session.authenticate(session_params) do
      {:ok, user} -&gt;
        {:ok, jwt, _full_claims} = user |&gt; Guardian.encode_and_sign(:token)

        conn
        |&gt; put_status(:created)
        |&gt; render(&quot;show.json&quot;, jwt: jwt, user: user)

      :error -&gt;
        conn
        |&gt; put_status(:unprocessable_entity)
        |&gt; render(&quot;error.json&quot;)
    end
  end

  # ...
end
</code></pre> <p>We are going to use the <code>PhoenixTrello.Session</code> helper module to authenticate the user with the parameters we are receiving. If everything goes <code>:ok</code> then we will encode and sign in the user. This will give us the <code>jwt</code> token so we can return it along with the <code>user</code> data as <strong>JSON</strong>. Let&#39;s take a look to the <code>Session</code> helper module before continuing any further:</p> <pre><code class="ruby"># web/helpers/session.ex

defmodule PhoenixTrello.Session do
  alias PhoenixTrello.{Repo, User}

  def authenticate(%{&quot;email&quot; =&gt; email, &quot;password&quot; =&gt; password}) do
    user = Repo.get_by(User, email: String.downcase(email))

    case check_password(user, password) do
      true -&gt; {:ok, user}
      _ -&gt; :error
    end
  end

  defp check_password(user, password) do
    case user do
      nil -&gt; false
      _ -&gt; Comeonin.Bcrypt.checkpw(password, user.encrypted_password)
    end
  end
end

</code></pre> <p>It tries to find the user by his email and check if the given password matches the user&#39;s encrypted one. If the user exists and the password is correct it returns a <a title="Elixir tuples" href="//elixir-lang.org/getting-started/basic-types.html#tuples">tuple</a> containing <code>{:ok, user}</code>. On the other hand, if no user is found or the password doesn&#39;t happen to match it just return the <a title="Elixir atoms" href="//elixir-lang.org/getting-started/basic-types.html#atoms">atom</a> <code>:error</code>.</p> <p>Going back to the <code>SessionController</code> note it renders the <code>error.json</code> template when the result of authenticating the user is the previous <code>:error</code> atom. Finally we have to create the <code>SessionView</code> module for rendering both results:</p> <pre><code class="elixir"># web/views/session_view.ex

defmodule PhoenixTrello.SessionView do
  use PhoenixTrello.Web, :view

  def render(&quot;show.json&quot;, %{jwt: jwt, user: user}) do
    %{
      jwt: jwt,
      user: user
    }
  end

  def render(&quot;error.json&quot;, _) do
    %{error: &quot;Invalid email or password&quot;}
  end
end

</code></pre> <h3>Already signed users</h3> <p>The reason for also returning the user&#39;s <strong>JSON</strong> representation while signing into the application is that we might need it for multiple purposes like, for instance, showing his name in the application&#39;s header. This is fulfilled with what we&#39;ve done so far. But what if the user refreshes the browser once in the root route view? Simple, our application state managed by <strong>Redux</strong> would be reseted and we wouldn&#39;t have that information available anymore possibly causing unwanted errors. And we don&#39;t want that, so to prevent it we can create a new controller which will be responsible for returning the authenticated user&#39;s data when needed.</p> <p>Let&#39;s add a new route in the <code>router.ex</code> file:</p> <pre><code class="ruby"># web/router.ex

defmodule PhoenixTrello.Router do
  use PhoenixTrello.Web, :router

  #...

  scope &quot;/api&quot;, PhoenixTrello do
    pipe_through :api

    scope &quot;/v1&quot; do
      # ...

      get &quot;/current_user&quot;, CurrentUserController, :show

      # ...
    end
  end

  #...
end
</code></pre> <p>Now we need the <code>CurrentUserController</code> which looks like this:</p> <pre><code class="ruby"># web/controllers/api/v1/current_user_controller.ex

defmodule PhoenixTrello.CurrentUserController do
  use PhoenixTrello.Web, :controller

  plug Guardian.Plug.EnsureAuthenticated, handler: PhoenixTrello.SessionController

  def show(conn, _) do
    user = Guardian.Plug.current_resource(conn)

    conn
    |&gt; put_status(:ok)
    |&gt; render(&quot;show.json&quot;, user: user)
  end
end

</code></pre> <p>The <code>Guardian.Plug.EnsureAuthenticated</code> checks if there is a previously verified token and if not it will handle the request with the <code>:unauthenticated</code> function of the <code>SessionController</code>. This is the way we are going to protect the private controllers, so if we want certain routes to be accessible only by authenticated users we only have to add this <strong>plug</strong> to their controllers. The rest of the functionality is pretty simple. After ensuring there is an authenticated token, it will render the <code>current_resource</code> which in our case would be the user.</p> <p>Finally we have to add the <code>unauthenticated</code> handler to the <code>SessionController</code>:</p> <pre><code class="elixir"># web/controllers/api/v1/session_controller.ex

defmodule PhoenixTrello.SessionController do
  use PhoenixTrello.Web, :controller

  # ...

  def unauthenticated(conn, _params) do
    conn
    |&gt; put_status(:forbidden)
    |&gt; render(PhoenixTrello.SessionView, &quot;forbidden.json&quot;, error: &quot;Not Authenticated&quot;)
  end
end
</code></pre> <p>It will return a <code>403</code> forbidden status code along with a simple <strong>JSON</strong> error string. With this we have finished all the back-end functionality related to the user <strong>sign in</strong> and subsequent <strong>authentications</strong>. In the next post we&#39;ll cover how to handle it in our front-end application and how to connect to the <strong>UserSocket</strong>, the core of all the real-time sugar. Meanwhile, don&#39;t forget to check out the live demo and final source code:</p> <div class=btn-wrapper> <a href="https://phoenix-trello.herokuapp.com/" target=_blank class=btn><i class="fa fa-cloud"></i> Live demo</a> <a href="https://github.com/bigardone/phoenix-trello" target=_blank class=btn><i class="fa fa-github"></i> Source code</a> </div> <p>Happy coding!</p> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'codeloveandboards'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <noscript> Please enable JavaScript to view the <a href='//disqus.com/?ref_noscript'>comments powered by Disqus.</a> </noscript> <a class=dsq-brlink href='//disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </section> </div> </section> <footer id=main_footer> <ul class=article-nav> <li class=previous> <a href="/blog/2016/01/14/trello-tribute-with-phoenix-and-react-pt-4/"><h4>previous post</h4> <h3> Trello tribute with Phoenix and React (pt.4) </h3> <div class=meta-data> <hr> posted Jan 14, 2016 on elixir, phoenix, react, redux </div> </a> </li> <li class=next> <a href="/blog/2016/01/20/trello-tribute-with-phoenix-and-react-pt-6/"><h4>next post</h4> <h3> Trello tribute with Phoenix and React (pt.6) </h3> <div class=meta-data> <hr> posted Jan 20, 2016 on elixir, phoenix, react, redux </div> </a> </li> </ul> <section> <div class=container> <div class=center> <ul> <li> <a href='/blog'>Archives</a> </li> <li> <a href='//feeds.feedburner.com/CodeLoveAndBoards' target=_blank>RSS</a> </li> </ul> Copyright © 2019 - Ricardo García Vega - Code, Love & Boards! </div> </div> </section> </footer> <script src="../../../../../javascripts/blog-5ddb0520.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-37802122-1', 'codeloveandboards.com');
  ga('send', 'pageview');
</script> <script>
  _StatHat.push(["_trackCount", "g2pcD9xou7DlR0DtndiwvSBBYU5k", 1.0]);
</script> </body> </html>
<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8 lt-ie7" lang=en-us><![endif]--> <!--[if IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8" lang=en-us><![endif]--> <!--[if IE 8]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if IE 9]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if lt IE 10]><html class="no-js lt-ie10" lang=en-us><![endif]--> <!--[if !IE]>><![endif]--> <html class=no-js lang=en> <head> <title>Trello tribute with Phoenix and React (pt.9) - Code, Love & Boards</title> <meta charset=utf-8 content='text/html' http-equiv=content-type> <meta content='ie=edge,chrome=1' http-equiv=x-ua-compatible> <meta content='Adding new board members and broadcasting results through channels' name=description> <meta content='Ricardo GarcÃ­a Vega - http://twitter.com/bigardone' name=author> <meta content='elixir, phoenix, react, redux' name=keywords> <meta content='initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width' name=viewport> <link href='//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css' rel=stylesheet> <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Lora:400,700" media=screen rel=stylesheet /> <link href="../../../../../stylesheets/blog-82c14d7c.css" media=all rel=stylesheet /> <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elixir.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elm.min.js'></script> <link href='/images/apple-touch-icon-57x57-6e598dc4.png' rel=apple-touch-icon sizes=57x57> <link href='/images/apple-touch-icon-114x114-5be964ba.png' rel=apple-touch-icon sizes=114x114> <link href='/images/apple-touch-icon-72x72-70084a85.png' rel=apple-touch-icon sizes=72x72> <link href='/images/apple-touch-icon-144x144-1dbb56c1.png' rel=apple-touch-icon sizes=144x144> <link href='/images/apple-touch-icon-60x60-d05a5ea9.png' rel=apple-touch-icon sizes=60x60> <link href='/images/apple-touch-icon-120x120-5dafce59.png' rel=apple-touch-icon sizes=120x120> <link href='/images/apple-touch-icon-76x76-b2c0d784.png' rel=apple-touch-icon sizes=76x76> <link href='/images/apple-touch-icon-152x152-45595360.png' rel=apple-touch-icon sizes=152x152> <link href='/images/favicon-160x160-944ce76e.png' rel=icon sizes=160x160 type='image/png'> <link href='/images/favicon-96x96-b7e4e089.png' rel=icon sizes=96x96 type='image/png'> <link href='/images/favicon-32x32-b7f34a79.png' rel=icon sizes=32x32 type='image/png'> <link href='/images/favicon-16x16-2712c528.png' rel=icon sizes=16x16 type='image/png'> <meta content='#9f00a7' name=msapplication-TileColor> <meta content='/images/mstile-144x144-028d4c4c.png' name=msapplication-TileImage> <script>
  var _StatHat = _StatHat || [];
  _StatHat.push(['_setUser', 'NzIzMCDaNaL5bvEP1HQkMYwfYsQe']);
  (function() {
          var sh = document.createElement('script'); sh.type = 'text/javascript';
          sh.async = true;
          sh.src = '//www.stathat.com/javascripts/api.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(sh, s);
  })();
</script> <link href='https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-9' rel=canonical> <link href='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js'></script> <script>
  window.addEventListener("load", function(){
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#252e39"
      },
      "button": {
        "background": "#217dbb"
      }
    },
    "theme": "classic",
    "position": "bottom-right"
  })});
</script> </head> <body class=blog> <header id=main_header> <div class=main-logo> <a href="/"><img src="../../../../../images/logo-cd52bd68.png"/> </a> </div> <div class=container> <section class=center> <h1>Trello tribute with Phoenix and React (pt.9)</h1> <h3></h3> <div class=meta-data> <hr> posted Feb 4, 2016 on <a class=tag href="/blog/tags/elixir.html">elixir</a> <a class=tag href="/blog/tags/phoenix.html">phoenix</a> <a class=tag href="/blog/tags/react.html">react</a> <a class=tag href="/blog/tags/redux.html">redux</a> </div> </section> </div> </header> <section id=main_content> <div class=container> <section> <article> <div class=index> <p>This post belongs to the <strong>Trello tribute with Phoenix Framework and React</strong> series.</p> <ol> <li><a href="/blog/2016/01/04/trello-tribute-with-phoenix-and-react-pt-1">Intro and selected stack</a></li> <li><a href="/blog/2016/01/11/trello-tribute-with-phoenix-and-react-pt-2">Phoenix Framework project setup</a></li> <li><a href="/blog/2016/01/12/trello-tribute-with-phoenix-and-react-pt-3">The User model and JWT auth</a></li> <li><a href="/blog/2016/01/14/trello-tribute-with-phoenix-and-react-pt-4/">Front-end for sign up with React and Redux</a></li> <li><a href="/blog/2016/01/18/trello-tribute-with-phoenix-and-react-pt-5/">Database seeding and sign in controller</a></li> <li><a href="/blog/2016/01/20/trello-tribute-with-phoenix-and-react-pt-6/">Front-end authentication with React and Redux</a></li> <li><a href="/blog/2016/01/25/trello-tribute-with-phoenix-and-react-pt-7/">Sockets and channels</a></li> <li><a href="/blog/2016/01/28/trello-tribute-with-phoenix-and-react-pt-8/">Listing and creating boards</a></li> <li><a href="/blog/2016/02/04/trello-tribute-with-phoenix-and-react-pt-9/">Adding new board members</a></li> <li><a href="/blog/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/">Tracking connected board members</a></li> <li><a href="/blog/2016/02/24/trello-tribute-with-phoenix-and-react-pt-11/">Adding lists and cards</a></li> <li><a href="/blog/2016/03/04/trello-tribute-with-phoenix-and-react-pt-12/">Deploying our application on Heroku</a></li> </ol> <a href="https://phoenix-trello.herokuapp.com/"><i class="fa fa-cloud"></i> Live demo</a> | <a href="https://github.com/bigardone/phoenix-trello"><i class="fa fa-github"></i> Source code</a> </div> <h2>Adding board members</h2> <p>On the <a title="Part 8" href="/blog/2016/01/28/trello-tribute-with-phoenix-and-react-pt-8/">last part</a> we created the boards table, the <code>Board</code> model and we also generated the controller which will be in charge of listing and creating new boards for the authenticated users. We also coded the front-end so the boards and the creation form could be displayed. Recalling where we left it, after receiving the successful response from the controller while creating a new board, we wanted to redirect the user to its view so he could see all the details and add more existing users as members. Let&#39;s do this!</p> <h3>The React view component</h3> <p>Before continuing let&#39;s take a look at the <strong>React</strong> routes:</p> <pre><code class="javascript">// web/static/js/routes/index.js

import { IndexRoute, Route }        from &#39;react-router&#39;;
import React                        from &#39;react&#39;;
import MainLayout                   from &#39;../layouts/main&#39;;
import AuthenticatedContainer       from &#39;../containers/authenticated&#39;;;
import BoardsShowView               from &#39;../views/boards/show&#39;;
// ...

export default (
  &lt;Route component={MainLayout}&gt;
    ...

    &lt;Route path=&quot;/&quot; component={AuthenticatedContainer}&gt;
      &lt;IndexRoute component={HomeIndexView} /&gt;

      ...

      &lt;Route path=&quot;/boards/:id&quot; component={BoardsShowView}/&gt;
    &lt;/Route&gt;
  &lt;/Route&gt;
);
</code></pre> <p>The <code>/boards/:id</code> route is going to be handled by the <code>BoardsShowView</code> component that we need to create:</p> <pre><code class="javascript">// web/static/js/views/boards/show.js

import React, {PropTypes}   from &#39;react&#39;;
import { connect }          from &#39;react-redux&#39;;

import Actions              from &#39;../../actions/current_board&#39;;
import Constants            from &#39;../../constants&#39;;
import { setDocumentTitle } from &#39;../../utils&#39;;
import BoardMembers           from &#39;../../components/boards/members&#39;;


class BoardsShowView extends React.Component {
  componentDidMount() {
    const { socket } = this.props;

    if (!socket) {
      return false;
    }

    this.props.dispatch(Actions.connectToChannel(socket, this.props.params.id));
  }

  componentWillUnmount() {
    this.props.dispatch(Actions.leaveChannel(this.props.currentBoard.channel));
  }

  _renderMembers() {
    const { connectedUsers, showUsersForm, channel, error } = this.props.currentBoard;
    const { dispatch } = this.props;
    const members = this.props.currentBoard.members;
    const currentUserIsOwner = this.props.currentBoard.user.id === this.props.currentUser.id;

    return (
      &lt;BoardMembers
        dispatch={dispatch}
        channel={channel}
        currentUserIsOwner={currentUserIsOwner}
        members={members}
        connectedUsers={connectedUsers}
        error={error}
        show={showUsersForm} /&gt;
    );
  }


  render() {
    const { fetching, name } = this.props.currentBoard;

    if (fetching) return (
      &lt;div className=&quot;view-container boards show&quot;&gt;
        &lt;i className=&quot;fa fa-spinner fa-spin&quot;/&gt;
      &lt;/div&gt;
    );

    return (
      &lt;div className=&quot;view-container boards show&quot;&gt;
        &lt;header className=&quot;view-header&quot;&gt;
          &lt;h3&gt;{name}&lt;/h3&gt;
          {::this._renderMembers()}
        &lt;/header&gt;
        &lt;div className=&quot;canvas-wrapper&quot;&gt;
          &lt;div className=&quot;canvas&quot;&gt;
            &lt;div className=&quot;lists-wrapper&quot;&gt;
              {::this._renderAddNewList()}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}

const mapStateToProps = (state) =&gt; ({
  currentBoard: state.currentBoard,
  socket: state.session.socket,
  currentUser: state.session.currentUser,
});

export default connect(mapStateToProps)(BoardsShowView);
</code></pre> <p>When it mounts it will connect to the board&#39;s channel using the user socket we already created on <a title="Socket and channels" href="/blog/2016/01/25/trello-tribute-with-phoenix-and-react-pt-7/">part 7</a>. When rendering it will first check if the <code>fetching</code> attribute is set to <code>true</code>, if so it will render a spinner while the board&#39;s data is still being fetched. As we can see it takes its props from the <code>currentBoard</code> element in the state which is created by the following reducer.</p> <h3>The reducer and actions creator</h3> <p>As a starting point of the current board state we will only need to store the <code>board</code> data, the <code>channel</code> and the <code>fetching</code> flag:</p> <pre><code class="javascript">// web/static/js/reducers/current_board.js

import Constants  from &#39;../constants&#39;;

const initialState = {
  channel: null,
  fetching: true,
};

export default function reducer(state = initialState, action = {}) {
  switch (action.type) {
    case Constants.CURRENT_BOARD_FETHING:
      return { ...state, fetching: true };

    case Constants.BOARDS_SET_CURRENT_BOARD:
      return { ...state, fetching: false, ...action.board };

    case Constants.CURRENT_BOARD_CONNECTED_TO_CHANNEL:
      return { ...state, channel: action.channel };

    default:
      return state;
  }
}
</code></pre> <p>Let&#39;s take a look to the <code>current_board</code> actions creator to check how do we connect to the channel and dispatch all the necessary data:</p> <pre><code class="javascript">// web/static/js/actions/current_board.js

import Constants  from &#39;../constants&#39;;

const Actions = {
  connectToChannel: (socket, boardId) =&gt; {
    return dispatch =&gt; {
      const channel = socket.channel(`boards:${boardId}`);

      dispatch({ type: Constants.CURRENT_BOARD_FETHING });

      channel.join().receive(&#39;ok&#39;, (response) =&gt; {
        dispatch({
          type: Constants.BOARDS_SET_CURRENT_BOARD,
          board: response.board,
        });

        dispatch({
          type: Constants.CURRENT_BOARD_CONNECTED_TO_CHANNEL,
          channel: channel,
        });
      });
    };
  },

  // ...
};

export default Actions;

</code></pre> <p>Just as with the <code>UserChannel</code>, we use the socket to create a new channel identified as <code>boards:${boardId}</code> and we join it, receiving as response the <strong>JSON</strong> representation of the board, which will be dispatched to the store along with the <code>BOARDS_SET_CURRENT_BOARD</code> action. From now on it will be connected to the channel receiving any change done to the board by any member, refreshing automatically those updates in the screen thanks to <strong>React</strong> and <strong>Redux</strong>. But first we need to create the <code>BoardChannel</code>.</p> <h3>The BoardChannel</h3> <p>Although almost all of the remaining functionality is going to be placed in this module, we are now going to just create a very simple version of it:</p> <pre><code class="ruby"># web/channels/board_channel.ex

defmodule PhoenixTrello.BoardChannel do
  use PhoenixTrello.Web, :channel
  alias PhoenixTrello.Board

  def join(&quot;boards:&quot; &lt;&gt; board_id, _params, socket) do
    board = get_current_board(socket, board_id)

    {:ok, %{board: board}, assign(socket, :board, board)}
  end

  defp get_current_board(socket, board_id) do
    socket.assigns.current_user
    |&gt; assoc(:boards)
    |&gt; Repo.get(board_id)
  end
end
</code></pre> <p>The <code>join</code> method gets the current board from the assigned user in the socket, returns it and assigns it to the socket so its available for future messages.</p> <p><img src="/images/blog/trello_tribute_pt_9/board_1-70174a4f.jpg"/></p> <h3>Board members</h3> <p>Once the board is displayed to the user, the following step is to allow him to add other existing users as members so they can work together on it. To associate boards with other users we have to create a new table to store this relation. Let&#39;s jump to the console and run:</p> <pre><code>$ mix phoenix.gen.model UserBoard user_boards user_id:references:users board_id:references:boards
</code></pre> <p>We need to update a bit the resulting migration file:</p> <pre><code class="ruby"># priv/repo/migrations/20151230081546_create_user_board.exs

defmodule PhoenixTrello.Repo.Migrations.CreateUserBoard do
  use Ecto.Migration

  def change do
    create table(:user_boards) do
      add :user_id, references(:users, on_delete: :delete_all), null: false
      add :board_id, references(:boards, on_delete: :delete_all), null: false

      timestamps
    end

    create index(:user_boards, [:user_id])
    create index(:user_boards, [:board_id])
    create unique_index(:user_boards, [:user_id, :board_id])
  end
end
</code></pre> <p>Apart from the null constraints, we are going to add a unique index for the <code>user_id</code> and the <code>board_id</code> so a <code>User</code> can&#39;t be added twice to the same <code>Board</code>. After running the necessary <code>mix ecto.migrate</code> lets head to the <code>UserBoard</code> model:</p> <pre><code class="elixir"># web/models/user_board.ex

defmodule PhoenixTrello.UserBoard do
  use PhoenixTrello.Web, :model

  alias PhoenixTrello.{User, Board}

  schema &quot;user_boards&quot; do
    belongs_to :user, User
    belongs_to :board, Board

    timestamps
  end

  @required_fields ~w(user_id board_id)
  @optional_fields ~w()

  def changeset(model, params \\ %{}) do
    model
    |&gt; cast(params, @required_fields, @optional_fields)
    |&gt; unique_constraint(:user_id, name: :user_boards_user_id_board_id_index)
  end
end
</code></pre> <p>Nothing unusual about it, but we also need to add this new relationships to the <code>User</code> model:</p> <pre><code class="elixir"># web/models/user.ex

defmodule PhoenixTrello.User do
  use PhoenixTrello.Web, :model
  # ...

  schema &quot;users&quot; do
    # ...

    has_many :user_boards, UserBoard
    has_many :boards, through: [:user_boards, :board]

    # ...
  end

  # ...
end
</code></pre> <p>We have two more relationships, but the one that matters the most to us is the <code>:boards</code> one, which we are going to use for security checks. Let&#39;s also add the collection to the <code>Board</code> model:</p> <pre><code class="elixir"># web/models/board.ex

defmodule PhoenixTrello.Board do
  # ...

  schema &quot;boards&quot; do
    # ...

    has_many :user_boards, UserBoard
    has_many :members, through: [:user_boards, :user]

    timestamps
  end
end
</code></pre> <p>By doing these changes now we can differentiate between boards created by a user and boards where the user has been invited to. This is very important because when a user is in the board&#39;s view we only want to show the members form if he is the original creator. We also want to automatically add the creator as a member so he gets listed by default, therefore we have to make a small change in the <code>BoardController</code>:</p> <pre><code class="ruby"># web/controllers/api/v1/board_controller.ex

defmodule PhoenixTrello.BoardController do
  use PhoenixTrello.Web, :controller
  #...

  def create(conn, %{&quot;board&quot; =&gt; board_params}) do
    current_user = Guardian.Plug.current_resource(conn)

    changeset = current_user
      |&gt; build_assoc(:owned_boards)
      |&gt; Board.changeset(board_params)

    if changeset.valid? do
      board = Repo.insert!(changeset)

      board
      |&gt; build_assoc(:user_boards)
      |&gt; UserBoard.changeset(%{user_id: current_user.id})
      |&gt; Repo.insert!

      conn
      |&gt; put_status(:created)
      |&gt; render(&quot;show.json&quot;, board: board )
    else
      conn
      |&gt; put_status(:unprocessable_entity)
      |&gt; render(&quot;error.json&quot;, changeset: changeset)
    end
  end
end
</code></pre> <p>Note how we build the new <code>UserBoard</code> association and insert it after previously checking if the board is valid.</p> <h3>The board members component</h3> <p>This component will display all the board&#39;s members avatars and the form to add new ones:</p> <p><img src="/images/blog/trello_tribute_pt_9/board_3-91641691.jpg"/></p> <p>As you can see, thanks to the previous change in the <code>BoardController</code>, the owner will be displayed as the only member for now. Let&#39;s see how this component will look like:</p> <pre><code class="javascript">// web/static/js/components/boards/members.js

import React, {PropTypes}       from &#39;react&#39;;
import ReactGravatar            from &#39;react-gravatar&#39;;
import classnames               from &#39;classnames&#39;;
import PageClick                from &#39;react-page-click&#39;;
import Actions                  from &#39;../../actions/current_board&#39;;

export default class BoardMembers extends React.Component {
  _renderUsers() {
    return this.props.members.map((member) =&gt; {
      const index = this.props.connectedUsers.findIndex((cu) =&gt; {
        return cu === member.id;
      });

      const classes = classnames({ connected: index != -1 });

      return (
        &lt;li className={classes} key={member.id}&gt;
          &lt;ReactGravatar className=&quot;react-gravatar&quot; email={member.email} https/&gt;
        &lt;/li&gt;
      );
    });
  }

  _renderAddNewUser() {
    if (!this.props.currentUserIsOwner) return false;

    return (
      &lt;li&gt;
        &lt;a onClick={::this._handleAddNewClick} className=&quot;add-new&quot; href=&quot;#&quot;&gt;&lt;i className=&quot;fa fa-plus&quot;/&gt;&lt;/a&gt;
        {::this._renderForm()}
      &lt;/li&gt;
    );
  }

  _renderForm() {
    if (!this.props.show) return false;

    return (
      &lt;PageClick onClick={::this._handleCancelClick}&gt;
        &lt;ul className=&quot;drop-down active&quot;&gt;
          &lt;li&gt;
            &lt;form onSubmit={::this._handleSubmit}&gt;
              &lt;h4&gt;Add new members&lt;/h4&gt;
              {::this._renderError()}
              &lt;input ref=&quot;email&quot; type=&quot;email&quot; required={true} placeholder=&quot;Member email&quot;/&gt;
              &lt;button type=&quot;submit&quot;&gt;Add member&lt;/button&gt; or &lt;a onClick={::this._handleCancelClick} href=&quot;#&quot;&gt;cancel&lt;/a&gt;
            &lt;/form&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/PageClick&gt;
    );
  }

  _renderError() {
    const { error } = this.props;

    if (!error) return false;

    return (
      &lt;div className=&quot;error&quot;&gt;
        {error}
      &lt;/div&gt;
    );
  }

  _handleAddNewClick(e) {
    e.preventDefault();

    this.props.dispatch(Actions.showMembersForm(true));
  }

  _handleCancelClick(e) {
    e.preventDefault();

    this.props.dispatch(Actions.showMembersForm(false));
  }

  _handleSubmit(e) {
    e.preventDefault();

    const { email } = this.refs;
    const { dispatch, channel } = this.props;

    dispatch(Actions.addNewMember(channel, email.value));
  }

  render() {
    return (
      &lt;ul className=&quot;board-users&quot;&gt;
        {::this._renderUsers()}
        {::this._renderAddNewUser()}
      &lt;/ul&gt;
    );
  }
}
</code></pre> <p>Basically it will loop through its <code>members</code> prop displaying their avatars. It will also display the <em>add new</em> button if the current user happens to be the owner of the board. When clicking this button the form will be shown, prompting the user to enter a member email and calling the <code>addNewMember</code> action creator when the form is submitted.</p> <h3>The addNewMember action creator</h3> <p>From now on, instead of using controllers to create and retrieve the necessary data for our <strong>React</strong> front-end we will move this responsibility into the <code>BoardChannel</code> so any change can be broadcasted to every joined user. Having this in mind let&#39;s add the necessary action creators:</p> <pre><code class="javascript">// web/static/js/actions/current_board.js

import Constants  from &#39;../constants&#39;;

const Actions = {
  // ...

  showMembersForm: (show) =&gt; {
    return dispatch =&gt; {
      dispatch({
        type: Constants.CURRENT_BOARD_SHOW_MEMBERS_FORM,
        show: show,
      });
    };
  },

  addNewMember: (channel, email) =&gt; {
    return dispatch =&gt; {
      channel.push(&#39;members:add&#39;, { email: email })
      .receive(&#39;error&#39;, (data) =&gt; {
        dispatch({
          type: Constants.CURRENT_BOARD_ADD_MEMBER_ERROR,
          error: data.error,
        });
      });
    };
  },

  // ...

}

export default Actions;
</code></pre> <p>The <code>showMembersForm</code> will make the form show or hide, easy as pie. The tricky part comes when we want to add the new member with the email provided by the user. Instead of making the typical http request we&#39;ve been doing so far, we push the message <code>members:add</code> to the <code>channel</code> with the email as parameter. If we receiver an error we will dispatch it so it&#39;s displayed in the screen. Why aren&#39;t we handling the case for a success response? Because we are going to take a different approach, broadcasting the result to all the connected members.</p> <h3>The BoardChannel</h3> <p>Having this said let&#39;s add the underlying message handler to the <code>BoardChannel</code></p> <pre><code class="elixir"># web/channels/board_channel.ex

defmodule PhoenixTrello.BoardChannel do
  # ...

  def handle_in(&quot;members:add&quot;, %{&quot;email&quot; =&gt; email}, socket) do
    try do
      board = socket.assigns.board
      user = User
        |&gt; Repo.get_by(email: email)

      changeset = user
      |&gt; build_assoc(:user_boards)
      |&gt; UserBoard.changeset(%{board_id: board.id})

      case Repo.insert(changeset) do
        {:ok, _board_user} -&gt;
          broadcast! socket, &quot;member:added&quot;, %{user: user}

          PhoenixTrello.Endpoint.broadcast_from! self(), &quot;users:#{user.id}&quot;, &quot;boards:add&quot;, %{board: board}

          {:noreply, socket}
        {:error, _changeset} -&gt;
          {:reply, {:error, %{error: &quot;Error adding new member&quot;}}, socket}
      end
    catch
      _, _-&gt; {:reply, {:error, %{error: &quot;User does not exist&quot;}}, socket}
    end
  end

  # ...
end
</code></pre> <p><strong>Phoenix</strong> channels handle incoming messages using the <code>handle_in</code> function and <strong>Elixir</strong>&#39;s powerful pattern matching to handle incoming messages. In our case the message name will be <code>members:add</code>, and it will be also be expecting an email parameter which will be matched to the corresponding variable. It will get the assigned board in the channel, find the user by his email and create a new <code>UserBoard</code> with both of them. If everything goes fine it will <code>broadcast</code> the message <code>member:added</code> to all the available connections passing the added user. Now let&#39;s take a closer look to this:</p> <pre><code class="elixir">PhoenixTrello.Endpoint.broadcast_from! self(), &quot;users:#{user.id}&quot;, &quot;boards:add&quot;, %{board: board}
</code></pre> <p>By doing this, it will be broadcasting the message <code>boards:add</code> along with the board to the <code>UserChannel</code> of the added member so the board suddenly appears in his invited boards list. This means we can broadcast any message to any channel from anywhere, which is awesome and brings a new bunch of possibilities and fun.</p> <p>To handle the <code>member:added</code> message in the front-end we have to add a new handler to the channel where it will dispatch the added member to the store:</p> <pre><code class="javascript">// web/static/js/actions/current_board.js

import Constants  from &#39;../constants&#39;;

const Actions = {
  // ...

  connectToChannel: (socket, boardId) =&gt; {
    return dispatch =&gt; {
      const channel = socket.channel(`boards:${boardId}`);

      // ...

      channel.on(&#39;member:added&#39;, (msg) =&gt; {
        dispatch({
          type: Constants.CURRENT_BOARD_MEMBER_ADDED,
          user: msg.user,
        });
      });

      // ...
    }
  },
};

export default Actions;
</code></pre> <p>And we have to do exactly the same for the <code>boards:add</code>, but dispatching the board:</p> <pre><code class="javascript">// web/static/js/actions/sessions.js

export function setCurrentUser(dispatch, user) {
  channel.on(&#39;boards:add&#39;, (msg) =&gt; {
    // ...

    dispatch({
      type: Constants.BOARDS_ADDED,
      board: msg.board,
    });
  });
};
</code></pre> <p>Finally, we need to update the reducers so both the new member and the new board are added into the application state:</p> <pre><code class="javascript">// web/static/js/reducers/current_board.js

export default function reducer(state = initialState, action = {}) {
  // ...

  case Constants.CURRENT_BOARD_MEMBER_ADDED:
    const { members } = state;
    members.push(action.user);

    return { ...state, members: members, showUsersForm: false };
  }

  // ...
}
</code></pre> <pre><code class="javascript">// web/static/js/reducers/boards.js

export default function reducer(state = initialState, action = {}) {
  // ...

  switch (action.type) {
    case Constants.BOARDS_ADDED:
      const { invitedBoards } = state;

      return { ...state, invitedBoards: [action.board].concat(invitedBoards) };
  }

  // ...
}
</code></pre> <p>Now the new member&#39;s avatar will appear in the list, and he will have access to the board and the necessary permissions to add and update new lists and cards.</p> <p><img src="/images/blog/trello_tribute_pt_9/board_4-933d1b88.jpg"/></p> <p>If we recall the <code>BoardMembers</code> component we previously described, the <code>className</code> of the avatar depends on wether the member id exists in the <code>connectedUsers</code> list prop or not. This list stores all the ids of the currently connected members to the board&#39;s channel. To create and handle this list we will be using a longtime running stateful <strong>Elixir</strong> process, but we will do this on the next part. Meanwhile, don&#39;t forget to check out the live demo and final source code:</p> <div class=btn-wrapper> <a href="https://phoenix-trello.herokuapp.com/" target=_blank class=btn><i class="fa fa-cloud"></i> Live demo</a> <a href="https://github.com/bigardone/phoenix-trello" target=_blank class=btn><i class="fa fa-github"></i> Source code</a> </div> <p>Happy coding!</p> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'codeloveandboards'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <noscript> Please enable JavaScript to view the <a href='//disqus.com/?ref_noscript'>comments powered by Disqus.</a> </noscript> <a class=dsq-brlink href='//disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </section> </div> </section> <footer id=main_footer> <ul class=article-nav> <li class=previous> <a href="/blog/2016/01/29/integration-tests-fun-with-phoenix-and-react/"><h4>previous post</h4> <h3> Integration tests fun with Phoenix and React </h3> <div class=meta-data> <hr> posted Jan 29, 2016 on elixir, phoenix, react, redux, tests </div> </a> </li> <li class=next> <a href="/blog/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/"><h4>next post</h4> <h3> Trello tribute with Phoenix and React (pt.10) </h3> <div class=meta-data> <hr> posted Feb 15, 2016 on elixir, phoenix, genserver, react, redux </div> </a> </li> </ul> <section> <div class=container> <div class=center> <ul> <li> <a href='/blog'>Archives</a> </li> <li> <a href='//feeds.feedburner.com/CodeLoveAndBoards' target=_blank>RSS</a> </li> </ul> Copyright Â© 2018 - Ricardo GarcÃ­a Vega - Code, Love & Boards! </div> </div> </section> </footer> <script src="../../../../../javascripts/blog-5ddb0520.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-37802122-1', 'codeloveandboards.com');
  ga('send', 'pageview');
</script> <script>
  _StatHat.push(["_trackCount", "g2pcD9xou7DlR0DtndiwvSBBYU5k", 1.0]);
</script> </body> </html>
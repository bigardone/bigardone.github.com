<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8 lt-ie7" lang=en-us><![endif]--> <!--[if IE 7]><html class="no-js lt-ie10 lt-ie9 lt-ie8" lang=en-us><![endif]--> <!--[if IE 8]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if IE 9]><html class="no-js lt-ie10 lt-ie9" lang=en-us><![endif]--> <!--[if lt IE 10]><html class="no-js lt-ie10" lang=en-us><![endif]--> <!--[if !IE]>><![endif]--> <html class=no-js lang=en> <head> <title>Trello tribute with Phoenix and React (pt.11) - Code, Love & Boards</title> <meta charset=utf-8 content='text/html' http-equiv=content-type> <meta content='ie=edge,chrome=1' http-equiv=x-ua-compatible> <meta content='Adding lists and cards and broadcasting them through the board channel' name=description> <meta content='Ricardo GarcÃ­a Vega - http://twitter.com/bigardone' name=author> <meta content='elixir, phoenix, react, redux' name=keywords> <meta content='initial-scale=1.0,user-scalable=no,maximum-scale=1,width=device-width' name=viewport> <link href='//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css' rel=stylesheet> <link href="//fonts.googleapis.com/css?family=Montserrat:400,700|Lora:400,700" media=screen rel=stylesheet /> <link href="../../../../../stylesheets/blog-82c14d7c.css" media=all rel=stylesheet /> <link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elixir.min.js'></script> <script src='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/elm.min.js'></script> <link href='/images/apple-touch-icon-57x57-6e598dc4.png' rel=apple-touch-icon sizes=57x57> <link href='/images/apple-touch-icon-114x114-5be964ba.png' rel=apple-touch-icon sizes=114x114> <link href='/images/apple-touch-icon-72x72-70084a85.png' rel=apple-touch-icon sizes=72x72> <link href='/images/apple-touch-icon-144x144-1dbb56c1.png' rel=apple-touch-icon sizes=144x144> <link href='/images/apple-touch-icon-60x60-d05a5ea9.png' rel=apple-touch-icon sizes=60x60> <link href='/images/apple-touch-icon-120x120-5dafce59.png' rel=apple-touch-icon sizes=120x120> <link href='/images/apple-touch-icon-76x76-b2c0d784.png' rel=apple-touch-icon sizes=76x76> <link href='/images/apple-touch-icon-152x152-45595360.png' rel=apple-touch-icon sizes=152x152> <link href='/images/favicon-160x160-944ce76e.png' rel=icon sizes=160x160 type='image/png'> <link href='/images/favicon-96x96-b7e4e089.png' rel=icon sizes=96x96 type='image/png'> <link href='/images/favicon-32x32-b7f34a79.png' rel=icon sizes=32x32 type='image/png'> <link href='/images/favicon-16x16-2712c528.png' rel=icon sizes=16x16 type='image/png'> <meta content='#9f00a7' name=msapplication-TileColor> <meta content='/images/mstile-144x144-028d4c4c.png' name=msapplication-TileImage> <script>
  var _StatHat = _StatHat || [];
  _StatHat.push(['_setUser', 'NzIzMCDaNaL5bvEP1HQkMYwfYsQe']);
  (function() {
          var sh = document.createElement('script'); sh.type = 'text/javascript';
          sh.async = true;
          sh.src = '//www.stathat.com/javascripts/api.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(sh, s);
  })();
</script> <link href='https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-11' rel=canonical> <link href='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css' rel=stylesheet> <script src='//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js'></script> <script>
  window.addEventListener("load", function(){
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#252e39"
      },
      "button": {
        "background": "#217dbb"
      }
    },
    "theme": "classic",
    "position": "bottom-right"
  })});
</script> </head> <body class=blog> <header id=main_header> <div class=main-logo> <a href="/"><img src="../../../../../images/logo-cd52bd68.png"/> </a> </div> <div class=container> <section class=center> <h1>Trello tribute with Phoenix and React (pt.11)</h1> <h3></h3> <div class=meta-data> <hr> posted Feb 24, 2016 on <a class=tag href="/blog/tags/elixir.html">elixir</a> <a class=tag href="/blog/tags/phoenix.html">phoenix</a> <a class=tag href="/blog/tags/react.html">react</a> <a class=tag href="/blog/tags/redux.html">redux</a> </div> </section> </div> </header> <section id=main_content> <div class=container> <section> <article> <div class=index> <p>This post belongs to the <strong>Trello tribute with Phoenix Framework and React</strong> series.</p> <ol> <li><a href="/blog/2016/01/04/trello-tribute-with-phoenix-and-react-pt-1">Intro and selected stack</a></li> <li><a href="/blog/2016/01/11/trello-tribute-with-phoenix-and-react-pt-2">Phoenix Framework project setup</a></li> <li><a href="/blog/2016/01/12/trello-tribute-with-phoenix-and-react-pt-3">The User model and JWT auth</a></li> <li><a href="/blog/2016/01/14/trello-tribute-with-phoenix-and-react-pt-4/">Front-end for sign up with React and Redux</a></li> <li><a href="/blog/2016/01/18/trello-tribute-with-phoenix-and-react-pt-5/">Database seeding and sign in controller</a></li> <li><a href="/blog/2016/01/20/trello-tribute-with-phoenix-and-react-pt-6/">Front-end authentication with React and Redux</a></li> <li><a href="/blog/2016/01/25/trello-tribute-with-phoenix-and-react-pt-7/">Sockets and channels</a></li> <li><a href="/blog/2016/01/28/trello-tribute-with-phoenix-and-react-pt-8/">Listing and creating boards</a></li> <li><a href="/blog/2016/02/04/trello-tribute-with-phoenix-and-react-pt-9/">Adding new board members</a></li> <li><a href="/blog/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/">Tracking connected board members</a></li> <li><a href="/blog/2016/02/24/trello-tribute-with-phoenix-and-react-pt-11/">Adding lists and cards</a></li> <li><a href="/blog/2016/03/04/trello-tribute-with-phoenix-and-react-pt-12/">Deploying our application on Heroku</a></li> </ol> <a href="https://phoenix-trello.herokuapp.com/"><i class="fa fa-cloud"></i> Live demo</a> | <a href="https://github.com/bigardone/phoenix-trello"><i class="fa fa-github"></i> Source code</a> </div> <h2>Adding lists and cards</h2> <p>In the <a title="Part 10" href="/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/">last part</a> we created a simple, yet useful, mechanism for tracking connected members to a board&#39;s channel with the help of <strong>OTP</strong> and the <strong>GenServer</strong> behaviour. We also learned how to broadcast this list through the channel so every member could see who else is viewing the board at the the same time. Now it&#39;s time to let the members add some lists and cards while the changes appear in their screens in realtime... Lets do this!</p> <p><img src="/images/blog/trello_tribute_pt_11/no_lists-21eeb4dd.jpg"/></p> <h3>Migrations and models</h3> <p>A <code>Board</code> can have multiple <strong>lists</strong>, which in turn may have multiple <strong>cards</strong> as well, so having this in mind lets start by generating the <code>List</code> model using the following <code>mix</code> task from the console:</p> <pre><code>$ mix phoenix.gen.model List lists board_id:references:board name:string
...
...
$ mix ecto.migrate
</code></pre> <p>This will generate the <code>lists</code> table in the database and the model:</p> <pre><code class="elixir"># web/models/list.ex

defmodule PhoenixTrello.List do
  use PhoenixTrello.Web, :model

  alias PhoenixTrello.{Board, List}

  @derive {Poison.Encoder, only: [:id, :board_id, :name]}

  schema &quot;lists&quot; do
    field :name, :string
    belongs_to :board, Board

    timestamps
  end

  @required_fields ~w(name)
  @optional_fields ~w()

  def changeset(model, params \\ %{}) do
    model
    |&gt; cast(params, @required_fields, @optional_fields)
  end
end
</code></pre> <p>Generating the <code>Card</code> model is going to be pretty similar:</p> <pre><code>$ mix phoenix.gen.model Card cards list_id:references:lists name:string
...
...
$ mix ecto.migrate
</code></pre> <p>The resulting model will be something similar to this:</p> <pre><code class="elixir"># web/models/card.ex

defmodule PhoenixTrello.Card do
  use PhoenixTrello.Web, :model

  alias PhoenixTrello.{Repo, List, Card}

  @derive {Poison.Encoder, only: [:id, :list_id, :name]}

  schema &quot;cards&quot; do
    field :name, :string
    belongs_to :list, List

    timestamps
  end

  @required_fields ~w(name list_id)
  @optional_fields ~w()

  def changeset(model, params \\ %{}) do
    model
    |&gt; cast(params, @required_fields, @optional_fields)
  end
end
</code></pre> <p>Don&#39;t forget to add the collection of cards to the <code>lists</code> schema:</p> <pre><code class="elixir"># web/models/list.ex

defmodule PhoenixTrello.List do
  # ...

  @derive {Poison.Encoder, only: [:id, :board_id, :name, :cards]}

  # ...

  schema &quot;lists&quot; do
    # ..

    has_many :cards, Card
  end

  # ...
end
</code></pre> <p>Now we can move forward to the front-end and create the necessary components.</p> <h3>The list form component</h3> <p>Before continuing, lets recall the <code>render</code> function of the <code>BoardsShowView</code> component:</p> <pre><code class="javascript">// web/static/js/views/boards/show.js

//...
//...
_renderLists() {
  const { lists, channel, id, addingNewCardInListId } = this.props.currentBoard;

  return lists.map((list) =&gt; {
    return (
      &lt;ListCard
        key={list.id}
        boardId={id}
        dispatch={this.props.dispatch}
        channel={channel}
        isAddingNewCard={addingNewCardInListId === list.id}
        {...list} /&gt;
    );
  });
}

render() {
    const { fetching, name } = this.props.currentBoard;

    if (fetching) return (
      &lt;div className=&quot;view-container boards show&quot;&gt;
        &lt;i className=&quot;fa fa-spinner fa-spin&quot;/&gt;
      &lt;/div&gt;
    );

    return (
      &lt;div className=&quot;view-container boards show&quot;&gt;
        &lt;header className=&quot;view-header&quot;&gt;
          &lt;h3&gt;{name}&lt;/h3&gt;
          {::this._renderMembers()}
        &lt;/header&gt;
        &lt;div className=&quot;canvas-wrapper&quot;&gt;
          &lt;div className=&quot;canvas&quot;&gt;
            &lt;div className=&quot;lists-wrapper&quot;&gt;
              {::this._renderLists()}
              {::this._renderAddNewList()}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        {this.props.children}
      &lt;/div&gt;
    );
  }

</code></pre> <p>Apart from the <code>BoardMembers</code> component we created the last time, we need to render all the lists belonging to the board as well. For the time being we don&#39;t have any lists, therefore lets move on to the <code>_renderAddNewList</code> function:</p> <pre><code class="javascript">// web/static/js/views/boards/show.js

// ...

  _renderAddNewList() {
    const { dispatch, formErrors, currentBoard } = this.props;

    if (!currentBoard.showForm) return this._renderAddButton();

    return (
      &lt;ListForm
        dispatch={dispatch}
        errors={formErrors}
        channel={currentBoard.channel}
        onCancelClick={::this._handleCancelClick} /&gt;
    );
  }

  _renderAddButton() {
    return (
      &lt;div className=&quot;list add-new&quot; onClick={::this._handleAddNewClick}&gt;
        &lt;div className=&quot;inner&quot;&gt;
          Add new list...
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }

  _handleAddNewClick() {
    const { dispatch } = this.props;

    dispatch(Actions.showForm(true));
  }

  _handleCancelClick() {
    this.props.dispatch(Actions.showForm(false));
  }

// ...

</code></pre> <p>The <code>_renderAddNewList</code> function first checks if the <code>currentBoard.showForm</code> property is set to <code>true</code> so it renders the <em>Add new list...</em> button instead of the <code>ListForm</code> component.</p> <p>When the user clicks the button, an action will be dispatched to the store and will set its property <code>showForm</code> to <code>true</code> making form to be displayed. Now lets create the form component:</p> <pre><code class="javascript">// web/static/js/components/lists/form.js

import React, { PropTypes } from &#39;react&#39;;
import Actions              from &#39;../../actions/lists&#39;;

export default class ListForm extends React.Component {
  componentDidMount() {
    this.refs.name.focus();
  }

  _handleSubmit(e) {
    e.preventDefault();

    const { dispatch, channel } = this.props;
    const { name } = this.refs;

    const data = {
      name: name.value,
    };

    dispatch(Actions.save(channel, data));
  }

  _handleCancelClick(e) {
    e.preventDefault();

    this.props.onCancelClick();
  }

  render() {
    return (
      &lt;div className=&quot;list form&quot;&gt;
        &lt;div className=&quot;inner&quot;&gt;
          &lt;form id=&quot;new_list_form&quot; onSubmit={::this._handleSubmit}&gt;
            &lt;input ref=&quot;name&quot; id=&quot;list_name&quot; type=&quot;text&quot; placeholder=&quot;Add a new list...&quot; required=&quot;true&quot;/&gt;
            &lt;button type=&quot;submit&quot;&gt;Save list&lt;/button&gt; or &lt;a href=&quot;#&quot; onClick={::this._handleCancelClick}&gt;cancel&lt;/a&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre> <p><img src="/images/blog/trello_tribute_pt_11/list_form-6ccaac88.jpg"/></p> <p>This is a very simple component with a form containing a text input for the name of the list, a submit button and a cancel link, which will dispatch the same action we have previously described but setting the <code>showForm</code> property to false to remove the form. When the form is submitted it will dispatch the <code>save</code> action creator with the name the user has provided, which will push it to the <code>lists:create</code> topic of the <code>BoardChannel</code>:</p> <pre><code class="javascript">// web/static/js/actions/lists.js

import Constants from &#39;../constants&#39;;

const Actions = {
  save: (channel, data) =&gt; {
    return dispatch =&gt; {
      channel.push(&#39;lists:create&#39;, { list: data });
    };
  },
};

export default Actions;
</code></pre> <h3>The BoardChannel</h3> <p>The following step will be making the <code>BoardChannel</code> handle the <code>lists:create</code> message, so lets do it:</p> <pre><code class="elixir"># web/channels/board_channel.ex

defmodule PhoenixTrello.BoardChannel do
  # ...

  def handle_in(&quot;lists:create&quot;, %{&quot;list&quot; =&gt; list_params}, socket) do
    board = socket.assigns.board

    changeset = board
      |&gt; build_assoc(:lists)
      |&gt; List.changeset(list_params)

    case Repo.insert(changeset) do
      {:ok, list} -&gt;
        list = Repo.preload(list, [:cards])

        broadcast! socket, &quot;list:created&quot;, %{list: list}

        {:noreply, socket}
      {:error, _changeset} -&gt;
        {:reply, {:error, %{error: &quot;Error creating list&quot;}}, socket}
    end
  end

  # ...
end
</code></pre> <p>Using the board assigned to the channel, it will build a <code>List</code> changeset with the received params and insert it. If everything goes <code>:ok</code> it will broadcast the created list through the channel to <strong>all connected members</strong>, including the creator, thus we don&#39;t really need to reply anything and we just return a <code>:noreply</code>. If by any chance there&#39;s been an error while inserting the new list, it will return an error message <strong>just to the creator</strong>, so he knows that something went wrong.</p> <h3>The reducer</h3> <p>Regarding lists we&#39;re almost done. The channel is broadcasting the created list, so let&#39;s add a handler in the front-end for it in the current board actions creator where the channel was joined:</p> <pre><code class="javascript">// web/static/js/actions/current_board.js

import Constants  from &#39;../constants&#39;;

const Actions = {
  // ...

  connectToChannel: (socket, boardId) =&gt; {
    return dispatch =&gt; {
      const channel = socket.channel(`boards:${boardId}`);
      // ...

      channel.on(&#39;list:created&#39;, (msg) =&gt; {
        dispatch({
          type: Constants.CURRENT_BOARD_LIST_CREATED,
          list: msg.list,
        });
      });
    };
  },
  // ...
}
</code></pre> <p>Finally we need to update the board reducer to append the list to the new state version it returns:</p> <pre><code class="javascript">// web/static/js/reducers/current_board.js

import Constants  from &#39;../constants&#39;;

export default function reducer(state = initialState, action = {}) {

  switch (action.type) {
    //...

    case Constants.CURRENT_BOARD_LIST_CREATED:
      const lists = [...state.lists];

      lists.push(action.list);

      return { ...state, lists: lists, showForm: false };

    // ...
  }
}
</code></pre> <p>We also set the <code>showForm</code> attribute to <code>false</code> so the form automatically hides, displaying again the <em>Add new list...</em> button and the recently created list:</p> <p><img src="/images/blog/trello_tribute_pt_11/new_list-ccbd11fc.jpg"/></p> <h3>The List component</h3> <p>Now that we have at least one list in the board we can create the <code>List</code> component we will use to render them:</p> <pre><code class="javascript">// /web/static/js/components/lists/card.js

import React, {PropTypes}       from &#39;react&#39;;
import Actions                  from &#39;../../actions/current_board&#39;;
import CardForm                 from &#39;../../components/cards/form&#39;;
import Card                     from &#39;../../components/cards/card&#39;;

export default class ListCard extends React.Component {
  // ...

  _renderForm() {
    const { isAddingNewCard } = this.props;
    if (!isAddingNewCard) return false;

    let { id, dispatch, formErrors, channel } = this.props;

    return (
      &lt;CardForm
        listId={id}
        dispatch={dispatch}
        errors={formErrors}
        channel={channel}
        onCancelClick={::this._hideCardForm}
        onSubmit={::this._hideCardForm}/&gt;
    );
  }

  _renderAddNewCard() {
    const { isAddingNewCard } = this.props;
    if (isAddingNewCard) return false;

    return (
      &lt;a className=&quot;add-new&quot; href=&quot;#&quot; onClick={::this._handleAddClick}&gt;Add a new card...&lt;/a&gt;
    );
  }

  _handleAddClick(e) {
    e.preventDefault();

    const { dispatch, id } = this.props;

    dispatch(Actions.showCardForm(id));
  }

  _hideCardForm() {
    const { dispatch } = this.props;

    dispatch(Actions.showCardForm(null));
  }

  render() {
    const { id, connectDragSource, connectDropTarget, connectCardDropTarget, isDragging } = this.props;

    const styles = {
      display: isDragging ? &#39;none&#39; : &#39;block&#39;,
    };

    return (
      &lt;div id={`list_${id}`} className=&quot;list&quot; style={styles}&gt;
        &lt;div className=&quot;inner&quot;&gt;
          &lt;header&gt;
            &lt;h4&gt;{this.props.name}&lt;/h4&gt;
          &lt;/header&gt;
          &lt;div className=&quot;cards-wrapper&quot;&gt;
            {::this._renderCards()}
          &lt;/div&gt;
          &lt;footer&gt;
            {::this._renderForm()}
            {::this._renderAddNewCard()}
          &lt;/footer&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre> <p>Just as we did with the lists, lets first focus on rendering the cards form. Basically we take the same approach of rendering or not the form using a <code>prop</code> passed by the main board component, and dispatching an action to change that state property.</p> <p><img src="/images/blog/trello_tribute_pt_11/card_form-e128ed4a.jpg"/></p> <h3>The card form component</h3> <p>This component is going to be very similar to the <code>ListForm</code> one:</p> <pre><code class="javascript">// /web/static/js/components/cards/form.js

import React, { PropTypes } from &#39;react&#39;;
import Actions              from &#39;../../actions/lists&#39;;
import PageClick            from &#39;react-page-click&#39;;

export default class CardForm extends React.Component {
  _handleSubmit(e) {
    e.preventDefault();

    let { dispatch, channel } = this.props;
    let { name }              = this.refs;

    let data = {
      list_id: this.props.listId,
      name: name.value,
    };

    dispatch(Actions.createCard(channel, data));
    this.props.onSubmit();
  }

  componentDidMount() {
    this.refs.name.focus();
  }

  _handleCancelClick(e) {
    e.preventDefault();

    this.props.onCancelClick();
  }

  render() {
    return (
      &lt;PageClick onClick={::this._handleCancelClick}&gt;
        &lt;div className=&quot;card form&quot;&gt;
          &lt;form id=&quot;new_card_form&quot; onSubmit={::this._handleSubmit}&gt;
            &lt;textarea ref=&quot;name&quot; id=&quot;card_name&quot; type=&quot;text&quot; required=&quot;true&quot; rows={5}/&gt;
            &lt;button type=&quot;submit&quot;&gt;Add&lt;/button&gt; or &lt;a href=&quot;#&quot; onClick={::this._handleCancelClick}&gt;cancel&lt;/a&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/PageClick&gt;
    );
  }
}

</code></pre> <p>Just as we previously did, on submitting the form we&#39;ll dispatch an action to create the card with name provided by the user. The action creator for this, will push a new message to the board channel:</p> <pre><code class="javascript">// /web/static/js/actions/lists.js

import Constants from &#39;../constants&#39;;

const Actions = {
  // ...

  createCard: (channel, data) =&gt; {
    return dispatch =&gt; {
      channel.push(&#39;cards:create&#39;, { card: data });
    };
  },
};

// ...
</code></pre> <p>Let&#39;s add the handler to the <code>BoardChannel</code>:</p> <pre><code class="elixir">  # web/channels/board_channel.ex

  def handle_in(&quot;cards:create&quot;, %{&quot;card&quot; =&gt; card_params}, socket) do
    board = socket.assigns.board
    changeset = board
      |&gt; assoc(:lists)
      |&gt; Repo.get!(card_params[&quot;list_id&quot;])
      |&gt; build_assoc(:cards)
      |&gt; Card.changeset(card_params)

    case Repo.insert(changeset) do
      {:ok, card} -&gt;
        broadcast! socket, &quot;card:created&quot;, %{card: card}

        {:noreply, socket}
      {:error, _changeset} -&gt;
        {:reply, {:error, %{error: &quot;Error creating card&quot;}}, socket}
    end
  end

</code></pre> <p>In the same way we did when creating the list, the new <code>Card</code> will be created associating it to the board assigned on the channel and the list passed as parameter. If the creation succeed it will be again dispatched to all connected members on the channel. Finally we have to add the callback to the <strong>js</strong> channel:</p> <pre><code class="javascript">  // web/static/js/actions/current_board.js
  //...

  channel.on(&#39;card:created&#39;, (msg) =&gt; {
    dispatch({
      type: Constants.CURRENT_BOARD_CARD_CREATED,
      card: msg.card,
    });
  });

  // ...
</code></pre> <p>And add the new card to the state via the reducer:</p> <pre><code class="javascript">  // web/static/js/reducers/current_board.js

  // ...

  case Constants.CURRENT_BOARD_CARD_CREATED:
    lists = [...state.lists];
    const { card } = action;

    const listIndex = lists.findIndex((list) =&gt; { return list.id == card.list_id; });
    lists[listIndex].cards.push(card);

    return { ...state, lists: lists };

  // ...
</code></pre> <p>And that&#39;s it! The card will appear on every connected member screen.</p> <p><img src="/images/blog/trello_tribute_pt_11/new_card-59842aa2.jpg"/></p> <h3>Now what?</h3> <p>With this part we have covered the basic functionality we need for letting users register, sign in, create boards, invite people to them and collaborate in realtime adding lists and cards. The final version in the repository has a lot more features like editing lists, sorting lists and cards by dragging them around, showing the card details where you can also assign members to them and even adding comments and color tags, but we are not going to talk about any of them here otherwise this would be the never-ending tutorial :D</p> <p>But don&#39;t worry, there&#39;s still one more part left where we&#39;ll talk about sharing the final result with the world by deploying it on <strong>Heroku</strong>. Meanwhile, don&#39;t forget to check out the live demo and final source code:</p> <div class=btn-wrapper> <a href="https://phoenix-trello.herokuapp.com/" target=_blank class=btn><i class="fa fa-cloud"></i> Live demo</a> <a href="https://github.com/bigardone/phoenix-trello" target=_blank class=btn><i class="fa fa-github"></i> Source code</a> </div> <p>Happy coding!</p> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'codeloveandboards'; // required: replace example with your forum shortname
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <noscript> Please enable JavaScript to view the <a href='//disqus.com/?ref_noscript'>comments powered by Disqus.</a> </noscript> <a class=dsq-brlink href='//disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </section> </div> </section> <footer id=main_footer> <ul class=article-nav> <li class=previous> <a href="/blog/2016/02/15/trello-tribute-with-phoenix-and-react-pt-10/"><h4>previous post</h4> <h3> Trello tribute with Phoenix and React (pt.10) </h3> <div class=meta-data> <hr> posted Feb 15, 2016 on elixir, phoenix, genserver, react, redux </div> </a> </li> <li class=next> <a href="/blog/2016/03/04/trello-tribute-with-phoenix-and-react-pt-12/"><h4>next post</h4> <h3> Trello tribute with Phoenix and React (pt.12) </h3> <div class=meta-data> <hr> posted Mar 4, 2016 on elixir, phoenix, heroku </div> </a> </li> </ul> <section> <div class=container> <div class=center> <ul> <li> <a href='/blog'>Archives</a> </li> <li> <a href='//feeds.feedburner.com/CodeLoveAndBoards' target=_blank>RSS</a> </li> </ul> Copyright Â© 2019 - Ricardo GarcÃ­a Vega - Code, Love & Boards! </div> </div> </section> </footer> <script src="../../../../../javascripts/blog-5ddb0520.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-37802122-1', 'codeloveandboards.com');
  ga('send', 'pageview');
</script> <script>
  _StatHat.push(["_trackCount", "g2pcD9xou7DlR0DtndiwvSBBYU5k", 1.0]);
</script> </body> </html>
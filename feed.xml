<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code, Love &amp; Boards</title>
  <subtitle>A blog about coding web apps, loving life and board sports</subtitle>
  <id>http://codeloveandboards.com/blog</id>
  <link href="http://codeloveandboards.com/blog"/>
  <link href="http://codeloveandboards.com/feed.xml" rel="self"/>
  <updated>2019-03-28T07:00:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Concurrent ant farm with Elixir and Phoenix LiveView</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2019/03/28/concurrent-ant-farm-with-elixir-and-phoenix-liveview/"/>
    <id>http://codeloveandboards.com/blog/2019/03/28/concurrent-ant-farm-with-elixir-and-phoenix-liveview/</id>
    <published>2019-03-28T07:00:00Z</published>
    <updated>2019-05-11T09:04:33+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;A couple of years ago, I worked on an &lt;strong&gt;Elixir&lt;/strong&gt; personal project which consisted of a virtual ant farm, where every ant was a GenServer process, simulating a basic AI behavior. What initially was going to be something straightforward; it ended up being much bigger and not working as planned, and eventually forgotten. When Chris Maccord announced &lt;a href="https://github.com/phoenixframework/phoenix_live_view"&gt;Phoenix LiveView&lt;/a&gt;, I thought to myself that I wouldn&amp;#39;t use it for now, because I enjoy too much writing front-end in &lt;strong&gt;Elm&lt;/strong&gt;. However, I also love &lt;strong&gt;Elixir&lt;/strong&gt; and &lt;strong&gt;Phoenix&lt;/strong&gt;, so I couldn&amp;#39;t resist giving it a try, and giving the ant farm another go, this time using &lt;strong&gt;Elixir&lt;/strong&gt; only, and trying to invest the less time possible. So I rolled up my sleeves, and surprisingly, four or five hours later I had the ant farm working, and this is how I did it:&lt;/p&gt;

&lt;h3&gt;Disclaimer&lt;/h3&gt;

&lt;p&gt;Before continuing, take this small experiment with a grain of salt. I don&amp;#39;t know anything about AI behaviors, nor SVG animations, so there is plenty of room for improvement. However, this is what worked fine after the first try, and I didn&amp;#39;t want to expend more than an evening on it. This being said, let&amp;#39;s get cracking!&lt;/p&gt;

&lt;h3&gt;Setting up the project with LiveView&lt;/h3&gt;

&lt;p&gt;Creating the project and adding &lt;strong&gt;LiveView&lt;/strong&gt; was pretty straight forward. There are already several tutorials over the Internet about how to add &lt;strong&gt;LiveView&lt;/strong&gt; to a &lt;strong&gt;Phoenix&lt;/strong&gt; application, so I jumped into &lt;a href="https://elixirschool.com/blog/phoenix-live-view/"&gt;this great post&lt;/a&gt; from &lt;a href="https://elixirschool.com/blog"&gt;Elixir School Blog&lt;/a&gt;and followed the instructions, which are very clear and easy to implement. Some minutes later, I had the project up and running.&lt;/p&gt;

&lt;h3&gt;Bringing ants to life&lt;/h3&gt;

&lt;p&gt;After having all the necessary project boilerplate, I started by defining what an ant is, and creating a simple module to define the data structure to represent its state:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant/state.ex

defmodule AntFarm.Ant.State do
  alias __MODULE__

  @type position :: {integer, integer}
  @type velocity :: {integer, integer}
  @type state :: :walking | :resting | :panicking

  @type t :: %State{
          id: String.t(),
          position: position,
          velocity: velocity,
          focus: non_neg_integer,
          state: state,
          speed: float
        }

  defstruct [:id, :position, :velocity, :focus, :state, :speed]

  def new(id) do
    state = random_state()

    %State{
      id: id,
      position: random_position(),
      velocity: random_velocity(),
      focus: random_focus(state),
      state: state,
      speed: @speed
    }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It has the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; to identify uniquely every ant.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;position&lt;/code&gt; which represents its current &lt;code&gt;{X, Y}&lt;/code&gt; coordinates.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;velocity&lt;/code&gt; which represents its movement direction, being &lt;code&gt;{1 | 0 | -1, 1 | 0 | -1}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;focus&lt;/code&gt; which determines when it gets bored with its current behavior.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt; which represents its current behavior, and can be one of &lt;code&gt;:walking&lt;/code&gt;, &lt;code&gt;:resting&lt;/code&gt; or &lt;code&gt;:panicking&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;speed&lt;/code&gt; which represents its current speed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I also added a &lt;code&gt;new/1&lt;/code&gt; helper function which returns a state struct with random values.&lt;/p&gt;

&lt;p&gt;Having this state defined, I moved on to creating the ant process definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant.ex

defmodule AntFarm.Ant do
  use GenServer

  alias __MODULE__.{State, Behaviour}
  @timeout 60

  @doc false
  def start_link(opts) do
    id = Keyword.fetch!(opts, :id)

    GenServer.start_link(__MODULE__, id, name: name(id))
  end

  def get_state(pid), do: GenServer.call(pid, :get_state)

  @impl true
  def init(id) do
    schedule()
    {:ok, State.new(id)}
  end

  @impl true
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  @impl true
  def handle_info(:perform_actions, state) do
    state = Behaviour.process(state)
    schedule()

    {:noreply, state}
  end

  defp name(id), do: String.to_atom(&amp;quot;ant::&amp;quot; &amp;lt;&amp;gt; id)

  defp schedule do
    Process.send_after(self(), :perform_actions, @timeout)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a basic &lt;code&gt;GenServer&lt;/code&gt; implementation that starts a new named process, which state is a &lt;code&gt;AntFarm.Ant.State&lt;/code&gt; struct. To emulate some random behavior, every 60 milliseconds it processes its state with the &lt;code&gt;AntFarm.Ant.Behaviour.process/1&lt;/code&gt; function, which returns the new state to set.&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant/behaviour.ex

defmodule AntFarm.Ant.Behaviour do
  alias AntFarm.Ant.State

  @max_width Application.get_env(:ant_farm, :colony)[:width]
  @max_height Application.get_env(:ant_farm, :colony)[:height]

  def process(%State{state: :resting, focus: 0} = state) do
    State.start_walking(state)
  end

  def process(%State{state: :resting} = state) do
    State.keep_resting(state)
  end

  def process(%State{state: :walking, focus: 0} = state) do
    State.start_resting(state)
  end

  def process(%State{state: :walking, speed: speed, position: {x, y}} = state) do
    {vx, vy} = velocity = calculate_velocity(state)
    position = {x + vx * speed, y + vy * speed}

    state
    |&amp;gt; State.keep_walking()
    |&amp;gt; State.set_velocity(velocity)
    |&amp;gt; State.set_position(position)
  end

  # ...
  # ...
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;process/1&lt;/code&gt; function receives an ant state, and returns a new one depending on its current properties and applying some of the following logic:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the current &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;:resting&lt;/code&gt; and &lt;code&gt;focus&lt;/code&gt; is 0, it forces the ant to start walking.&lt;/li&gt;
&lt;li&gt;On the other hand, if &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;:resting&lt;/code&gt; but it is still focusing on resting, then the ant keeps resting (which subtracts 1 to the current &lt;code&gt;focus&lt;/code&gt; value).&lt;/li&gt;
&lt;li&gt;If the current &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;:walking&lt;/code&gt; and &lt;code&gt;focus&lt;/code&gt; is 0, the ant gets tired and starts resting.&lt;/li&gt;
&lt;li&gt;But if &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;:walking&lt;/code&gt; and it is still focusing on it, then it keeps walking calculating its new velocity (in case it hits the ant farm boundaries) and position.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is just an example of how to implement some basic logic to emulate behavior depending on a current state. To see all the details check out the &lt;a href="https://github.com/bigardone/phoenix-liveview-ant-farm/blob/master/lib/ant_farm/ant/behaviour.ex"&gt;AntFarm.Ant.Behaviour&lt;/a&gt; source code.&lt;/p&gt;

&lt;p&gt;At this point I had defined an ant&amp;#39;s structure and behavior, so the next thing I needed was a way to spawn new ants on demand, and &lt;strong&gt;Elixir&lt;/strong&gt;&amp;#39;s &lt;a href="https://hexdocs.pm/elixir/DynamicSupervisor.html"&gt;DynamicSupervisor&lt;/a&gt; was the right tool for it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant/supervisor.ex

defmodule AntFarm.Ant.Supervisor do
  use DynamicSupervisor

  alias AntFarm.Ant

  def start_link(arg) do
    DynamicSupervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  def start_child do
    spec = {Ant, id: generate_id()}
    DynamicSupervisor.start_child(__MODULE__, spec)
  end

  def populate(count \\ 1) do
    for _ &amp;lt;- 1..count, do: start_child()
  end

  def ants do
    __MODULE__
    |&amp;gt; DynamicSupervisor.which_children()
    |&amp;gt; Task.async_stream(&amp;amp;get_ant_state/1)
    |&amp;gt; Enum.map(fn {:ok, state} -&amp;gt; state end)
  end

  @impl true
  def init(_arg) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  # ...
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;start_child&lt;/code&gt; function makes the supervisor spawn a new &lt;code&gt;Ant&lt;/code&gt; process with a random &lt;code&gt;id&lt;/code&gt;. I also added an &lt;code&gt;ants&lt;/code&gt; function which returns all its children state. Last but not least, the &lt;code&gt;populate/1&lt;/code&gt; function spawns a given number of ant processes, which is going to become handy to spawn some ants once the application starts. For this purpose, I also created a small populator module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant/supervisor/populator.ex

defmodule AntFarm.Ant.Supervisor.Populator do
  alias AntFarm.Ant.Supervisor, as: AntSupervisor

  @population Application.get_env(:ant_farm, :colony)[:population]

  def child_spec(opts) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [opts]},
      type: :worker,
      restart: :permanent,
      shutdown: 500
    }
  end

  def start_link(_opts \\ []) do
    AntSupervisor.populate(@population)
    :ignore
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To spawn the ants once the application starts, and moreover, once the &lt;code&gt;AntFarm.Ant.Supervisor&lt;/code&gt; has started, we only need to add it to the main supervision tree like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/application.ex

defmodule AntFarm.Application do
  use Application

  def start(_type, _args) do
    children = [
      AntFarm.Ant.Supervisor,
      AntFarm.Ant.Supervisor.Populator,
      AntFarmWeb.Endpoint
    ]

    opts = [strategy: :one_for_one, name: AntFarm.Supervisor]
    Supervisor.start_link(children, opts)
  end

  def config_change(changed, _new, removed) do
    AntFarmWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the application looked like the first time I started it, spawning only ten ant processes:&lt;/p&gt;

&lt;p&gt;&lt;img class="center" src="/images/blog/liveview-ant-farm/tree.jpg"/&gt;&lt;/p&gt;

&lt;h3&gt;Rendering the ant farm&lt;/h3&gt;

&lt;p&gt;Now that I had a bunch of ants doing their ant things, it was time for some &lt;strong&gt;LiveView&lt;/strong&gt; fun, and displaying them in the browser. The first step was to render the basic template from the main controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm_web/templates/page/index.html.eex

&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;header class=&amp;quot;main-header&amp;quot;&amp;gt;
    &amp;lt;h1&amp;gt;Phoenix LiveView Ant Farm&amp;lt;/h1&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;%= live_render(@conn, AntFarmWeb.AntFarmLiveView, session: nil) %&amp;gt;
  &amp;lt;p&amp;gt;
    Crafted with ♥ by &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;https://github.com/bigardone&amp;quot;&amp;gt;bigardone&amp;lt;/a&amp;gt; |
    Check out the &amp;lt;a target=&amp;quot;_blank&amp;quot; href=&amp;quot;https://github.com/bigardone/phoenix-liveview-ant-farm&amp;quot;&amp;gt;source code&amp;lt;/a&amp;gt;
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here comes the tricky part. Calling &lt;code&gt;live_render/3&lt;/code&gt; renders the &lt;strong&gt;LiveView&lt;/strong&gt;, which is the content that is going to be changing periodically to animate the ants. Let&amp;#39;s take a look at the &lt;code&gt;AntFarmWeb.AntFarmLiveView&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm_web/live/ant_farm_live_view.ex

defmodule AntFarmWeb.AntFarmLiveView do
  use Phoenix.LiveView

  alias AntFarm.Ant.Supervisor, as: Colony

  @timeout 60

  @impl true
  def mount(_session, socket) do
    if connected?(socket), do: schedule()
    ants = Colony.ants()
    {:ok, assign(socket, ants: ants)}
  end

  @impl true
  def render(assigns) do
    AntFarmWeb.PageView.render(&amp;quot;ant_farm.html&amp;quot;, assigns)
  end

  def handle_info(:tick, socket) do
    schedule()
    ants = Colony.ants()
    {:noreply, assign(socket, ants: ants)}
  end

  defp schedule do
    Process.send_after(self(), :tick, @timeout)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When rendering the template for the first time, the &lt;code&gt;mount/2&lt;/code&gt; function gets called, assigning the existing ants to the connection, rendering the first static HTML and making the JS client connect to the socket. Only then, it creates the stateful view, invoking &lt;code&gt;mount/2&lt;/code&gt; again with the signed session, and calling the private &lt;code&gt;schedule/0&lt;/code&gt; function, which sends the tick message to the &lt;strong&gt;LiveView&lt;/strong&gt; process every sixty milliseconds, retrieving the new ant states and assigning it to the socket forcing a new render of the &lt;code&gt;ant_farm.html&lt;/code&gt; template.&lt;/p&gt;

&lt;p&gt;The only thing left was creating the &lt;code&gt;ant_farm.html&lt;/code&gt; template:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm_web/templates/page/ant_farm.html.leex

&amp;lt;div class=&amp;quot;main-content&amp;quot;&amp;gt;
  &amp;lt;h2&amp;gt;Rendering &amp;lt;%= length(@ants) %&amp;gt; concurrent ants&amp;lt;/h2&amp;gt;
  &amp;lt;svg viewbox=&amp;quot;0 0 1024 600&amp;quot;&amp;gt;
    &amp;lt;rect width=&amp;quot;1024&amp;quot; height=&amp;quot;600&amp;quot; fill=&amp;quot;#00b349&amp;quot;/&amp;gt;
    &amp;lt;%= for %{position: {x, y}} &amp;lt;- @ants do %&amp;gt;
      &amp;lt;rect width=&amp;quot;2&amp;quot; height=&amp;quot;2&amp;quot; fill=&amp;quot;#000000&amp;quot; x=&amp;quot;&amp;lt;%= x %&amp;gt;&amp;quot; y=&amp;quot;&amp;lt;%= y %&amp;gt;&amp;quot;/&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;/svg&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is what I saw when I went to the browser:&lt;/p&gt;

&lt;p&gt;&lt;img class="center" src="/images/blog/liveview-ant-farm/ants.gif"/&gt;&lt;/p&gt;

&lt;p&gt;My ants were finally alive, yay!&lt;/p&gt;

&lt;h3&gt;Do not tap on glass&lt;/h3&gt;

&lt;p&gt;After having all the ants walking around the screen, I wanted to add some interactivity with them, and the most reasonable to me was clicking on the farm box. &lt;strong&gt;LiveView&lt;/strong&gt; comes with some event handling support out of the box, so I went back to the documentation and implemented the &lt;code&gt;phx-click&lt;/code&gt; binding in the &lt;code&gt;ant_farm.html&lt;/code&gt; template:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm_web/templates/page/ant_farm.html.leex

# ...
# ...

  &amp;lt;svg class=&amp;quot;panic&amp;lt;%= @panic %&amp;gt;&amp;quot; phx-click=&amp;quot;tap&amp;quot; viewbox=&amp;quot;0 0 1024 600&amp;quot;&amp;gt;
    # ...
    # ...
  &amp;lt;/svg&amp;gt;

# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding the &lt;code&gt;phx-click=&amp;quot;tap&amp;quot;&lt;/code&gt; attribute, makes the &lt;strong&gt;LiveView&lt;/strong&gt; JS client send a &lt;code&gt;tap&lt;/code&gt; message through the socket every time a user clicks on the &lt;code&gt;svg&lt;/code&gt; element. Therefore, the &lt;code&gt;AntFarmWeb.AntFarmLiveView&lt;/code&gt; needs to handle it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm_web/live/ant_farm_live_view.ex

defmodule AntFarmWeb.AntFarmLiveView do
  use Phoenix.LiveView

  # ...

  @impl true
  def mount(_session, socket) do
    if connected?(socket), do: schedule()
    ants = Colony.ants()
    {:ok, assign(socket, panic: false, ants: ants)}
  end

  # ...

  @impl true
  def handle_event(&amp;quot;tap&amp;quot;, _value, socket) do
    Colony.panic()
    Process.send_after(self(), :chill, 1000)
    {:noreply, assign(socket, panic: true)}
  end

  def handle_info(:chill, socket) do
    {:noreply, assign(socket, panic: false)}
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tap event handler calls &lt;code&gt;Colony.panick/0&lt;/code&gt; which makes all ants go crazy, sets its assign &lt;code&gt;panic&lt;/code&gt; value to &lt;code&gt;true&lt;/code&gt; and after a second sends a &lt;code&gt;:chill&lt;/code&gt; message, which sets the &lt;code&gt;panic&lt;/code&gt; assign value back to &lt;code&gt;false&lt;/code&gt;. This is a trick I did, to toggle a particular class to the SVG DOM element, which adds a vibration animation. Let&amp;#39;s take a look at the &lt;code&gt;Colony.panic/0&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant/supervisor.ex

defmodule AntFarm.Ant.Supervisor do
  use DynamicSupervisor

  # ...

  def panic do
    __MODULE__
    |&amp;gt; DynamicSupervisor.which_children()
    |&amp;gt; Enum.each(&amp;amp;do_panic/1)
  end

  defp do_panic({_, pid, _, _}), do: Ant.panic(pid)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes all of its children PIDs and calls &lt;code&gt;Ant.panic/1&lt;/code&gt; with each of them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/ant_farm/ant.ex

defmodule AntFarm.Ant do
  use GenServer

  # ...

  def panic(pid), do: GenServer.cast(pid, :panic)

  # ...

  @impl true
  def handle_cast(:panic, %State{state: :panicking} = state) do
    {:noreply, state}
  end

  def handle_cast(:panic, state) do
    {:noreply, State.start_panicking(state)}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;panic/1&lt;/code&gt; function sends a &lt;code&gt;:panic&lt;/code&gt; message to the given PID, which takes the current &lt;code&gt;state&lt;/code&gt; and makes the ant go crazy for a random number of ticks, only if it&amp;#39;s not already panicking though. The result is quite nice as you can see in &lt;a href="https://phoenix-liveview-ant-farm.herokuapp.com"&gt;the demo&lt;/a&gt; :)&lt;/p&gt;

&lt;p&gt;And, this is pretty much it. In a single evening, I managed to code the project and deploy it into Heroku. I was amazed about how easy was adding &lt;strong&gt;LiveView&lt;/strong&gt; to the project, how well it worked and the overall result. I&amp;#39;m definitely keeping an eye on &lt;strong&gt;LiveView&lt;/strong&gt; updates and how it evolves to use it in future projects. Don&amp;#39;t forget to check out the demo and the final repository in the links below.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://phoenix-liveview-ant-farm.herokuapp.com/" target="_blank" class="btn"&gt;&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; Live demo&lt;/a&gt;
  &lt;a href="https://github.com/bigardone/phoenix-liveview-ant-farm" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Elm and Web Components</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/09/09/elm-and-web-components/"/>
    <id>http://codeloveandboards.com/blog/2018/09/09/elm-and-web-components/</id>
    <published>2018-09-09T08:35:00Z</published>
    <updated>2018-09-09T18:13:14+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;One of my favorite talks from &lt;a href="https://2018.elmeurope.org/"&gt;Elm Europe 2018&lt;/a&gt; conference was the one about &lt;a href="https://www.youtube.com/watch?v=tyFe9Pw6TVE"&gt;When and how to use Web Components with Elm&lt;/a&gt; by &lt;a href="https://github.com/lukewestby"&gt;Luke Westby&lt;/a&gt;, creator of the popular &lt;strong&gt;Elm&lt;/strong&gt; live editor &lt;a href="https://ellie-app.com/new"&gt;Ellie&lt;/a&gt;. In this fun and enlightening talk, he suggests an alternative way of using external JS libraries in &lt;strong&gt;Elm&lt;/strong&gt;, rather than relying on ports. Ports, although being the standard way of communicating with external JS in &lt;strong&gt;Elm&lt;/strong&gt;, might not be the right tool for some particular situations, especially when your application grows and you need to handle a significant amount of them. The alternative way he exposes is using &lt;a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components"&gt;Web Components&lt;/a&gt;, which is &lt;em&gt;a suite of different technologies allowing you to create reusable custom elements — with their functionality encapsulated away from the rest of your code — and utilize them in your web apps&lt;/em&gt;. This solution blew up my mind, so I couldn&amp;#39;t resist trying it out myself, and I had the perfect project for it :)&lt;/p&gt;

&lt;h3&gt;Revisiting Phoenix &amp;amp; Elm landing page&lt;/h3&gt;

&lt;p&gt;Some months ago I did a small tutorial about &lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1"&gt;creating a landing page with Phoenix and Elm&lt;/a&gt;, in which we added &lt;a href="https://developers.google.com/recaptcha/"&gt;Google reCAPTCHA&lt;/a&gt; to add security to the subscription form. Both the initialization and passing the response token are handled using ports, which makes it the perfect candidate for being a custom Web Component. Let&amp;#39;s add the definition of the custom element:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// assets/js/components/recaptcha.

export default class Recaptcha extends HTMLElement {
  constructor() {
    const self = super();

    self._grecaptcha = null;
    self._token = null;

    return self;
  }

  connectedCallback() {
    this._grecaptcha = grecaptcha.render(this, {
      hl: &amp;#39;en&amp;#39;,
      sitekey: &amp;#39;your-recaptcha-site-key&amp;#39;,
      callback: (token) =&amp;gt; {
        this._token = token;
        this.dispatchEvent(new CustomEvent(&amp;#39;gotToken&amp;#39;));
      },
    });
  }

  set token(token) {
    this._token = token;

    if (this._grecaptcha !== null &amp;amp;&amp;amp; token === null) grecaptcha.reset(this._grecaptcha);
  }

  get token() {
    return this._token;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are defining the &lt;code&gt;Recaptcha&lt;/code&gt; class which extends &lt;code&gt;HTMLElement&lt;/code&gt; and has the following functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;constructor&lt;/code&gt;, in which we define the internal properties of the component. In our case, we have &lt;code&gt;_grecaptcha&lt;/code&gt; to store the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; plugin instance, and &lt;code&gt;_token&lt;/code&gt; to store the token received from Google while validating the user.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connetedCallback&lt;/code&gt; is one of the &lt;a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks"&gt;lifecycle callbacks&lt;/a&gt; of any custom element, and in which we initialize the internal &lt;strong&gt;reCAPTCHA&lt;/strong&gt; plugin, and dispatches a custom &lt;code&gt;gotToken&lt;/code&gt; event with the value received from Google.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set token()&lt;/code&gt; and &lt;code&gt;get token()&lt;/code&gt; which are the getter and setter functions for the &lt;code&gt;token&lt;/code&gt; property.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we have defined the &lt;code&gt;Recaptcha&lt;/code&gt; custom element, let&amp;#39;s edit the main &lt;code&gt;app.js&lt;/code&gt; file to remove use it and also remove the unnecessary port&amp;#39;s functionality that we don&amp;#39;t need anymore:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// assets/js/app.

import Elm from &amp;#39;./elm/main&amp;#39;;
import Recaptcha from &amp;#39;./components/recaptcha&amp;#39;;

window.customElements.define(&amp;#39;g-recaptcha&amp;#39;, Recaptcha);

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    Elm.Main.embed(formContainer);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We register the custom element using &lt;code&gt;window.customElements.define&lt;/code&gt; which takes the &lt;code&gt;name&lt;/code&gt; (requires a dash on it) of the HTML node and the component definition, in our case &lt;code&gt;Recaptcha&lt;/code&gt;. From now on, we can add  our new &lt;code&gt;Recaptcha&lt;/code&gt; custom element by adding a &lt;code&gt;&amp;lt;g-recaptacha&amp;gt;&amp;lt;/g-recaptcha&amp;gt;&lt;/code&gt; tag, so let&amp;#39;s edit them Elm view module to remove the old div we were using to render the &lt;code&gt;reCAPTCHA&lt;/code&gt; component, and add the new tag:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
        let
            { fullName, email, recaptchaToken } =
                    extractFormFields subscribeForm
        -- ...
        in
        -- ...
            , Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.node &amp;quot;g-recaptcha&amp;quot;
                    [ Html.id &amp;quot;recaptcha&amp;quot;
                    , Html.property &amp;quot;token&amp;quot; &amp;lt;| encodeRecaptchaToken recaptchaToken
                    , Html.on &amp;quot;gotToken&amp;quot; decodeGotToken
                    ]
                    []
                , validationErrorView &amp;quot;recaptcha_token&amp;quot; validationErrors
                ]
                        , -- ...



encodeRecaptchaToken : Maybe String -&amp;gt; Encode.Value
encodeRecaptchaToken maybeRecaptchaToken =
    case maybeRecaptchaToken of
        Just recaptchaToken -&amp;gt;
            Encode.string recaptchaToken

        Nothing -&amp;gt;
            Encode.null


decodeGotToken : Decode.Decoder Msg
decodeGotToken =
    Decode.map SetRecaptchaToken &amp;lt;| Decode.at [ &amp;quot;target&amp;quot;, &amp;quot;token&amp;quot; ] &amp;lt;| Decode.string

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make the custom element work we need to do the following:
- Define the new &lt;code&gt;g-recaptcha&lt;/code&gt; node using &lt;code&gt;Html.node&lt;/code&gt;.
- Set the &lt;code&gt;token&lt;/code&gt; property with &lt;code&gt;Html.property&lt;/code&gt; which in the component uses internally the &lt;code&gt;set token(token)&lt;/code&gt; setter function we have defined previously.
- Handle the custom &lt;code&gt;gotToken&lt;/code&gt; event we have also defined previously, which sets the token in the model after getting it back from the custom element in its &lt;code&gt;decodeGotToken&lt;/code&gt; decoder.&lt;/p&gt;

&lt;p&gt;And, that&amp;#39;s it! If we run the application, everything should be working as before, yay!&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/final-result.gif"
alt="Final result" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;After watching Luke&amp;#39;s talk, I was looking forward to spending some free time playing around with &lt;strong&gt;Web Components&lt;/strong&gt; and checking by myself how they work and how they play with &lt;strong&gt;Elm&lt;/strong&gt;. After implementing the solution, and reviewing the code while writing this post, I have to admit that I  like a lot final result. Having all the functionality related to the component encapsulated in its own definition, and simply rendering it and managing messages using events as with any other HTML node is really cool, and this separation of concerns makes your &lt;strong&gt;Elm&lt;/strong&gt; code cleaner and easier to understand and maintain. Although it surely has some drawbacks like browser compatibility (which you can fix using a proper polyfill), I&amp;#39;m going to start using this solution in my current and future projects to explore its benefits and possible limitations more deeply. If you are curious about the final result, &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/commit/4e9e88037ba7679e6b20fbb942b1b5379db6f418"&gt;here is the commit&lt;/a&gt; with the needed changes.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir and Phoenix basic passwordless and databaseless authentication (pt. 3)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/08/31/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3/"/>
    <id>http://codeloveandboards.com/blog/2018/08/31/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3/</id>
    <published>2018-08-31T07:00:00Z</published>
    <updated>2018-09-09T10:36:43+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Elixir and Phoenix basic passwordless and databaseless authentication&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;Project setup and the initial functionality for storing and verifying authentication tokens&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2"&gt;Sending authentication link emails and the user socket connection&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/09/01/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3"&gt;Setting up webpack as our asset bundler and the Elm single-page application&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2"&gt;previous part&lt;/a&gt; of the series, we covered all the back-end logic regarding sending authentication emails and using the generated tokens to authenticate the connection of a &lt;strong&gt;Phoenix&lt;/strong&gt; socket. In this part, we are going to focus on the front-end, building the &lt;strong&gt;Elm&lt;/strong&gt; single page application skeleton, and using the websockect authentication to hide some parts of it to unauthenticated users. Let&amp;#39;s get cracking!&lt;/p&gt;

&lt;h2&gt;Front-end setup&lt;/h2&gt;

&lt;p&gt;I&amp;#39;ve been using &lt;strong&gt;Elixir&lt;/strong&gt; and &lt;strong&gt;Phoenix&lt;/strong&gt; in the back-end, and &lt;strong&gt;Elm&lt;/strong&gt; in the front-end, for almost three years already, and I&amp;#39;m delighted with the result. I tend to use Phoenix&amp;#39;s default asset bundler, &lt;a href="https://brunch.io/"&gt;Brunch&lt;/a&gt;, but I&amp;#39;ve been having some issues lately with it, especially while using its &lt;strong&gt;Elm&lt;/strong&gt; and &lt;strong&gt;SASS&lt;/strong&gt; plugins. Therefore, for this particular experiment, I wanted to test out other alternatives, replacing Brunch with &lt;a href="https://webpack.js.org/"&gt;webpack&lt;/a&gt; and &lt;strong&gt;SASS&lt;/strong&gt; with &lt;a href="https://tailwindcss.com/"&gt;Tailwind CSS&lt;/a&gt;, which I&amp;#39;m starting to like a lot and seems like the first strong candidate to replace &lt;strong&gt;SASS&lt;/strong&gt; in my front-end stack. Recalling the &lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;first part&lt;/a&gt; of the series, we created the project using the --no-brunch flag, which doesn&amp;#39;t install Brunch so that we can add &lt;strong&gt;webpack&lt;/strong&gt; directly. For that, I followed &lt;a href="http://www.schmitty.me/stack-setup-phoenix-elm-graphql-tailwindcss/"&gt;this great article&lt;/a&gt; from &lt;a href="https://twitter.com/_GazD"&gt;@_GazD&lt;/a&gt;, taking the parts that I needed and making some small changes to add &lt;strong&gt;Elm&lt;/strong&gt; support.&lt;/p&gt;

&lt;h3&gt;Adding webpack to the project&lt;/h3&gt;

&lt;p&gt;This being said, let&amp;#39;s start by adding a &lt;code&gt;package.json&lt;/code&gt; file to the &lt;code&gt;passwordless_auth_web&lt;/code&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;// apps/passwordless_auth_web/assets/package.json

{
  &amp;quot;repository&amp;quot;: {},
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;deploy&amp;quot;: &amp;quot;webpack --mode production&amp;quot;,
    &amp;quot;watch&amp;quot;: &amp;quot;webpack --mode development --watch&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;phoenix&amp;quot;: &amp;quot;file:../../../deps/phoenix&amp;quot;,
    &amp;quot;phoenix_html&amp;quot;: &amp;quot;file:../../../deps/phoenix_html&amp;quot;
  },
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;autoprefixer&amp;quot;: &amp;quot;^8.6.0&amp;quot;,
    &amp;quot;babel-core&amp;quot;: &amp;quot;^6.26.0&amp;quot;,
    &amp;quot;babel-loader&amp;quot;: &amp;quot;^7.1.3&amp;quot;,
    &amp;quot;babel-preset-env&amp;quot;: &amp;quot;^1.6.1&amp;quot;,
    &amp;quot;copy-webpack-plugin&amp;quot;: &amp;quot;^4.5.0&amp;quot;,
    &amp;quot;css-loader&amp;quot;: &amp;quot;^0.28.10&amp;quot;,
    &amp;quot;elm&amp;quot;: &amp;quot;^0.18.0&amp;quot;,
    &amp;quot;elm-webpack-loader&amp;quot;: &amp;quot;^4.5.0&amp;quot;,
    &amp;quot;mini-css-extract-plugin&amp;quot;: &amp;quot;^0.4.0&amp;quot;,
    &amp;quot;optimize-css-assets-webpack-plugin&amp;quot;: &amp;quot;^4.0.0&amp;quot;,
    &amp;quot;postcss-loader&amp;quot;: &amp;quot;^2.1.5&amp;quot;,
    &amp;quot;style-loader&amp;quot;: &amp;quot;^0.21.0&amp;quot;,
    &amp;quot;tailwindcss&amp;quot;: &amp;quot;^0.5.3&amp;quot;,
    &amp;quot;uglifyjs-webpack-plugin&amp;quot;: &amp;quot;^1.2.4&amp;quot;,
    &amp;quot;webpack&amp;quot;: &amp;quot;^4.10.0&amp;quot;,
    &amp;quot;webpack-cli&amp;quot;: &amp;quot;^3.0.0&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are all the necessary dependencies that we need to add support for &lt;strong&gt;webpack&lt;em&gt;,&lt;/em&gt; **Elm&lt;/strong&gt; and &lt;strong&gt;Tailwind CSS&lt;/strong&gt;, although bear in mind that package versions might be outdated since I wrote this part. We can continue by adding the necessary configuration files:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ curl https://raw.githubusercontent.com/phoenixframework/phoenix/master/installer/templates/phx_assets/webpack/webpack.config.js &amp;gt; apps/passwordless_auth_web/assets/webpack.config.js
$ curl https://raw.githubusercontent.com/phoenixframework/phoenix/master/installer/templates/phx_assets/webpack/babelrc &amp;gt; apps/passwordless_auth_web/assets/.babelrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s continue by installing all the necessary dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ cd apps/passwordless_auth_web/assets &amp;amp;&amp;amp; npm install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want &lt;strong&gt;Phoenix&lt;/strong&gt; to update the changes we make while developing, so let&amp;#39;s add the convenient watcher for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/config/dev.exs

use Mix.Config

config :passwordless_auth_web, PasswordlessAuthWeb.Endpoint,
  http: [port: 4000],
  debug_errors: true,
  code_reloader: true,
  check_origin: false,
  watchers: [
    node: [
      &amp;quot;node_modules/webpack/bin/webpack.js&amp;quot;,
      &amp;quot;--mode&amp;quot;,
      &amp;quot;development&amp;quot;,
      &amp;quot;--watch-stdin&amp;quot;,
      cd: Path.expand(&amp;quot;../assets&amp;quot;, __DIR__)
    ]
  ]

# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Configuring Tailwind CSS&lt;/h3&gt;

&lt;p&gt;To generate Tailwind&amp;#39;s configuration file, we have to do the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ cd apps/passwordless_auth_web/assets &amp;amp;&amp;amp; ./node_modules/.bin/tailwind init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to make &lt;strong&gt;webpack&lt;/strong&gt; process &lt;strong&gt;CSS&lt;/strong&gt; and &lt;strong&gt;Tailwind&lt;/strong&gt; using &lt;strong&gt;postcss&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// apps/passwordless_auth_web/assets/webpack.config.js

const path = require(&amp;#39;path&amp;#39;);
const MiniCssExtractPlugin = require(&amp;#39;mini-css-extract-plugin&amp;#39;);
const UglifyJsPlugin = require(&amp;#39;uglifyjs-webpack-plugin&amp;#39;);
const OptimizeCSSAssetsPlugin = require(&amp;#39;optimize-css-assets-webpack-plugin&amp;#39;);
const CopyWebpackPlugin = require(&amp;#39;copy-webpack-plugin&amp;#39;);

module.exports = (env, options) =&amp;gt; ({
  optimization: {
    minimizer: [
      new UglifyJsPlugin({ cache: true, parallel: true, sourceMap: false }),
      new OptimizeCSSAssetsPlugin({}),
    ],
  },
  entry: &amp;#39;./js/app.js&amp;#39;,
  output: {
    filename: &amp;#39;app.js&amp;#39;,
    path: path.resolve(__dirname, &amp;#39;../priv/static/js&amp;#39;),
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: &amp;#39;babel-loader&amp;#39;,
        },
      },
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, &amp;#39;css-loader&amp;#39;, &amp;#39;postcss-loader&amp;#39;],
      }
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({ filename: &amp;#39;../css/app.css&amp;#39; }),
    new CopyWebpackPlugin([{ from: &amp;#39;static/&amp;#39;, to: &amp;#39;../&amp;#39; }]),
  ],
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// apps/passwordless_auth_web/assets/postcss.config.js

module.exports = {
  plugins: [
    require(&amp;#39;tailwindcss&amp;#39;)(&amp;#39;./tailwind.js&amp;#39;),
    require(&amp;#39;autoprefixer&amp;#39;)
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we need to import the main &lt;strong&gt;CSS&lt;/strong&gt; file in the main javascript file and add all the necessary &lt;strong&gt;Tailwind&lt;/strong&gt; hooks:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// apps/passwordless_auth_web/assets/js/app.js

import css from &amp;quot;../css/app.css&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="css"&gt;/* apps/passwordless_auth_web/assets/css/app.css */

@tailwind preflight;
@tailwind components;
@tailwind utilities;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Adding Elm support&lt;/h3&gt;

&lt;p&gt;To make &lt;strong&gt;Elm&lt;/strong&gt; work with &lt;strong&gt;webpack&lt;/strong&gt;, we need to edit its configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// apps/passwordless_auth_web/assets/webpack.config.js

// ...

module.exports = (env, options) =&amp;gt; ({
  // ...

  module: {
    rules: [
      // ...
      {
        test: /\.elm$/,
        exclude: [&amp;#39;/elm-stuff/&amp;#39;, &amp;#39;/node_modules&amp;#39;],
        loader: &amp;#39;elm-webpack-loader&amp;#39;,
        options: {
          debug: true,
          warn: true,
          cwd: path.resolve(__dirname, &amp;#39;elm&amp;#39;),
        },
      },
    ],
    noParse: [/.elm$/],
  },
  plugins: [
    new MiniCssExtractPlugin({ filename: &amp;#39;../css/app.css&amp;#39; }),
    new CopyWebpackPlugin([{ from: &amp;#39;static/&amp;#39;, to: &amp;#39;../&amp;#39; }]),
  ],
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To install all the necessary &lt;strong&gt;Elm&lt;/strong&gt; packages let&amp;#39;s add the following file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;// apps/passwordless_auth_web/assets/elm/elm-package.json

{
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;summary&amp;quot;: &amp;quot;helpful summary of your project, less than 80 characters&amp;quot;,
    &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/user/project.git&amp;quot;,
    &amp;quot;license&amp;quot;: &amp;quot;BSD3&amp;quot;,
    &amp;quot;source-directories&amp;quot;: [
        &amp;quot;./src&amp;quot;,
        &amp;quot;./vendor&amp;quot;
    ],
    &amp;quot;exposed-modules&amp;quot;: [],
    &amp;quot;dependencies&amp;quot;: {
        &amp;quot;NoRedInk/elm-decode-pipeline&amp;quot;: &amp;quot;3.0.0 &amp;lt;= v &amp;lt; 4.0.0&amp;quot;,
        &amp;quot;elm-lang/core&amp;quot;: &amp;quot;5.1.1 &amp;lt;= v &amp;lt; 6.0.0&amp;quot;,
        &amp;quot;elm-lang/html&amp;quot;: &amp;quot;2.0.0 &amp;lt;= v &amp;lt; 3.0.0&amp;quot;,
        &amp;quot;elm-lang/http&amp;quot;: &amp;quot;1.0.0 &amp;lt;= v &amp;lt; 2.0.0&amp;quot;,
        &amp;quot;elm-lang/navigation&amp;quot;: &amp;quot;2.1.0 &amp;lt;= v &amp;lt; 3.0.0&amp;quot;,
        &amp;quot;elm-lang/websocket&amp;quot;: &amp;quot;1.0.2 &amp;lt;= v &amp;lt; 2.0.0&amp;quot;,
        &amp;quot;evancz/url-parser&amp;quot;: &amp;quot;2.0.1 &amp;lt;= v &amp;lt; 3.0.0&amp;quot;
    },
    &amp;quot;elm-version&amp;quot;: &amp;quot;0.18.0 &amp;lt;= v &amp;lt; 0.19.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ cd apps/passwordless_auth_web/assets/elm &amp;amp;&amp;amp; elm package install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can add a very basic &lt;strong&gt;Elm&lt;/strong&gt; application to check that everything is working as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Main.elm

module Main exposing (..)

import Html exposing (Html)


type alias Model =
    {}


init : ( Model, Cmd Msg )
init =
    {} ! []


type Msg
    = Noop


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        Noop -&amp;gt;
            model ! []


view : Model -&amp;gt; Html Msg
view model =
    Html.text &amp;quot;Hello from Elm!&amp;quot;


subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Sub.none


main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We probably still have the default layout template from &lt;strong&gt;Phoenix&lt;/strong&gt;, so let&amp;#39;s replace its content with the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- apps/passwordless_auth_web/lib/passwordless_auth_web/templates/layout/app.html.eex  --&amp;gt;

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/css/app.css&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Passwordless Auth&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
    &amp;lt;%= render @view_module, @view_template, assigns %&amp;gt;
    &amp;lt;script src=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/js/app.js&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to add the container in which we are going to render the &lt;strong&gt;Elm&lt;/strong&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- apps/passwordless_auth_web/lib/passwordless_auth_web/templates/page/index.html.eex --&amp;gt;

&amp;lt;div id=&amp;quot;elm-main&amp;quot; class=&amp;quot;flex items-center justify-center h-screen&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, create the &lt;strong&gt;Elm&lt;/strong&gt; application and render it in its container:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// apps/passwordless_auth_web/assets/js/app.js

import css from &amp;#39;../css/app.css&amp;#39;;
import Elm from &amp;#39;../elm/src/Main.elm&amp;#39;;

const elmDiv = document.getElementById(&amp;#39;elm-main&amp;#39;);

if (elmDiv) {
  const app = Elm.Main.embed(elmDiv);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to start Phoenix&amp;#39;s server, visit &lt;a href="http://localhost:4000"&gt;http://localhost:4000&lt;/a&gt; and watch our basic &lt;strong&gt;Elm&lt;/strong&gt; application render correctly, yay!&lt;/p&gt;

&lt;p&gt;&lt;img alt="Basic application" src="https://monosnap.com/image/hOk7G1IDEdtHhSdEBwTu5ZK3rhLvHz" /&gt;&lt;/p&gt;

&lt;p&gt;There is one thing left to do though. We are going to use the &lt;a href="https://github.com/saschatimme/elm-phoenix"&gt;elm-phoenix&lt;/a&gt; library to handle &lt;strong&gt;Phoenix&lt;/strong&gt; sockets communication, therefore we need to download the content of &lt;a href="https://github.com/bigardone/passwordless-auth/tree/master/apps/passwordless_auth_web/assets/elm/vendor"&gt;this folder&lt;/a&gt; and place it in the &lt;code&gt;apps/passwordless_auth_web/assets/elm/vendor&lt;/code&gt; folder.&lt;/p&gt;

&lt;h2&gt;Building the Elm application&lt;/h2&gt;

&lt;p&gt;Now that our basic &lt;strong&gt;Elm&lt;/strong&gt; application is working let&amp;#39;s make some changes to the &lt;strong&gt;Phoenix&lt;/strong&gt; controller and template in charge of rendering it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/controllers/page_controller.ex

defmodule PasswordlessAuthWeb.PageController do
  use PasswordlessAuthWeb, :controller

  def index(conn, params) do
    conn
    |&amp;gt; assign(:token, Map.get(params, &amp;quot;token&amp;quot;, &amp;quot;&amp;quot;))
    |&amp;gt; render(&amp;quot;index.html&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first change consists of assigning the received &lt;code&gt;token&lt;/code&gt; value from the authentication link to the connection so that we can pass it to the &lt;strong&gt;Elm&lt;/strong&gt; application as a flag. We also need to pass the socket URL, so let&amp;#39;s create a helper function for that:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/views/page_view.ex

defmodule PasswordlessAuthWeb.PageView do
  use PasswordlessAuthWeb, :view

  def socket_url do
    PasswordlessAuthWeb.Endpoint.url()
    |&amp;gt; String.replace(&amp;quot;http&amp;quot;, &amp;quot;ws&amp;quot;)
    |&amp;gt; Kernel.&amp;lt;&amp;gt;(&amp;quot;/socket/websocket&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can set these two values in the template:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/templates/page/index.html.eex

&amp;lt;div id=&amp;quot;elm-main&amp;quot; class=&amp;quot;flex items-center justify-center h-screen&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
  window.token = &amp;#39;&amp;lt;%= @token %&amp;gt;&amp;#39;;
  window.socketUrl = &amp;#39;&amp;lt;%= socket_url() %&amp;gt;&amp;#39;;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally pass them as flags in the Elm application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// apps/passwordless_auth_web/assets/js/app.js

import Elm from &amp;#39;../elm/src/Main.elm&amp;#39;;
import css from &amp;#39;../css/app.css&amp;#39;;

const elmDiv = document.getElementById(&amp;#39;elm-main&amp;#39;);

let token = window.token;
const socketUrl = window.socketUrl;

if (token === &amp;#39;&amp;#39; || token == null) token = window.localStorage.getItem(&amp;#39;token&amp;#39;);

if (elmDiv) {
  const app = Elm.Main.embed(elmDiv, { token, socketUrl });

  app.ports.saveToken.subscribe((token) =&amp;gt; {
    window.localStorage.setItem(&amp;#39;token&amp;#39;, token);
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have also added a port for saving the token into &lt;code&gt;localStorage&lt;/code&gt;, that we are going to use later on.&lt;/p&gt;

&lt;p&gt;Before continuing any further, let&amp;#39;s take a moment to think about what we are building, using the following mock image:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Routes" src="https://monosnap.com/image/Isrs18qTVpNMYfWcXNuq9RbvG7Z4nS.png" /&gt;&lt;/p&gt;

&lt;p&gt;To test out our passwordless authentication experiment, we only need a couple of screens and routes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt; which is only accessible by authenticated users, and can potentially have any private data we want to display.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sign-in&lt;/code&gt; which is public, renders the form to request the magic link, and is where we are redirecting any user that tries to navigate to &lt;code&gt;/&lt;/code&gt; without being properly authenticated.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Having this in mind, we can start by implementing the routing module, so we can add these two routes:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Route.elm


module Route
    exposing
        ( Route(..)
        , fromLocation
        , newUrl
        )

import Navigation exposing (Location)
import UrlParser as Url exposing ((&amp;lt;/&amp;gt;), Parser, oneOf, s, string, parsePath)


-- ROUTING --


type Route
    = SignInRoute
    | LobbyRoute


matchers : Parser (Route -&amp;gt; a) a
matchers =
    oneOf
        [ Url.map LobbyRoute &amp;lt;| s &amp;quot;&amp;quot;
        , Url.map SignInRoute &amp;lt;| s &amp;quot;sign-in&amp;quot;
        ]



-- INTERNAL --


routeToString : Route -&amp;gt; String
routeToString page =
    let
        pieces =
            case page of
                LobbyRoute -&amp;gt;
                    []

                SignInRoute -&amp;gt;
                    [ &amp;quot;sign-in&amp;quot; ]
    in
        &amp;quot;/&amp;quot; ++ String.join &amp;quot;/&amp;quot; pieces



-- PUBLIC HELPERS --


newUrl : Route -&amp;gt; Cmd msg
newUrl =
    routeToString &amp;gt;&amp;gt; Navigation.newUrl


fromLocation : Location -&amp;gt; Maybe Route
fromLocation location =
    parsePath matchers location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have defined the routes that we need, let&amp;#39;s move on to the main elm module and start coding the application. In many of my &lt;strong&gt;Elm&lt;/strong&gt; projects and tutorials, I&amp;#39;ve been organizing all the &lt;strong&gt;Elm&lt;/strong&gt; code in folders, creating one for each route. Inside of these folders, I tended to add four different files, one for each of the Model, Messages, Update and View modules of that route. This approach used to work fine for small projects, but it didn&amp;#39;t scale that well for bigger ones. Then I read &lt;a href="https://twitter.com/rtfeldman"&gt;Richard Feldman&amp;#39;s&lt;/a&gt; article &lt;a href="https://dev.to/rtfeldman/tour-of-an-open-source-elm-spa"&gt;Tour of an Open-Source Elm SPA&lt;/a&gt;, and I have started to organize my new &lt;strong&gt;Elm&lt;/strong&gt; projects following his recommendations, feeling more comfortable now when they start to grow.&lt;/p&gt;

&lt;h3&gt;The Page modules&lt;/h3&gt;

&lt;p&gt;Although this is a very small project, we will stick to Richard&amp;#39;s approach, therefore let&amp;#39;s get started by defining the page modules that define the logic for each screen for the application, and which we will use from the main module depending on which is the current page set in the application.&lt;/p&gt;

&lt;h4&gt;Page.SignIn&lt;/h4&gt;

&lt;p&gt;The first page we are implementing is the sign-in page. The goal is to define everything we need as it was a standalone &lt;strong&gt;Elm&lt;/strong&gt; program, except that it does not have a view function, and the entry point can be either an init function to load any necessary data from the backend or its initial model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Page/SignIn.elm

module Page.SignIn
    exposing
        ( Model
        , SignInForm(..)
        , Msg(..)
        , update
        , initialModel
        )

import Http
import Json.Encode as Encode
import Json.Decode as Decode
import Request.Token exposing (requestToken)


-- MODEL --


type SignInForm
    = Editing String
    | Sending String
    | Success String
    | Error String


type alias Model =
    { form : SignInForm }


initialModel : Model
initialModel =
    { form = Editing &amp;quot;&amp;quot; }



-- UPDATE --


type Msg
    = HandleEmailInput String
    | HandleFormSubmit
    | FormSubmitResponse (Result Http.Error String)


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg ({ form } as model) =
    case ( msg, form ) of
        ( HandleEmailInput value, Editing _ ) -&amp;gt;
            { model | form = Editing value } ! []

        ( HandleFormSubmit, Editing email ) -&amp;gt;
            { model | form = Sending email } ! [ requestToken FormSubmitResponse email ]

        ( FormSubmitResponse payload, Sending _ ) -&amp;gt;
            case payload of
                Ok message -&amp;gt;
                    { model | form = Success message } ! []

                _ -&amp;gt;
                    { model | form = Error &amp;quot;We couldn&amp;#39;t sent you your magic link due to an error, please try again later.&amp;quot; } ! []

        _ -&amp;gt;
            model ! []


requestToken : (Result Http.Error String -&amp;gt; msg) -&amp;gt; String -&amp;gt; Cmd msg
requestToken msg email =
    let
        body =
            Encode.object [ ( &amp;quot;email&amp;quot;, Encode.string email ) ]

        request =
            Http.request
                { method = &amp;quot;POST&amp;quot;
                , headers = []
                , url = &amp;quot;/api/auth&amp;quot;
                , body = Http.jsonBody body
                , expect = Http.expectJson requestTokenDecoder
                , timeout = Nothing
                , withCredentials = False
                }
    in
        Http.send msg request


requestTokenDecoder : Decode.Decoder String
requestTokenDecoder =
    Decode.at [ &amp;quot;message&amp;quot; ] Decode.string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Model&lt;/code&gt; for this page consists of a record with a &lt;code&gt;form&lt;/code&gt; custom type that represents the different states that we need in the sign-in form:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Editing String&lt;/code&gt; when the user is typing so we can store the value typed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sending String&lt;/code&gt; when the user submits the form so we can, for instance, render a spinner in the submit button.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Success String&lt;/code&gt; which means a successful form submission, and the &lt;code&gt;String&lt;/code&gt; received from the server.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Error String&lt;/code&gt; if anything goes wrong, and we want to show an error message.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;update&lt;/code&gt; function is very simple too, handling the following messages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HandleEmailInput String&lt;/code&gt; when the form email input changes its value, storing it in the model.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandleFormSubmit&lt;/code&gt; sends the &lt;code&gt;requestToken&lt;/code&gt; HTTP request.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FormSubmitResponse (Result Http.Error String)&lt;/code&gt; which handles the response from the previous HTTP request.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Page.Lobby&lt;/h4&gt;

&lt;p&gt;The other page we need to implement is the one we want to display only to authenticated users:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Page/Lobby.elm

module Page.Lobby exposing ( Model , Msg(..) , init , update)

import Json.Decode as Decode exposing (Value)
import Phoenix
import Phoenix.Push as Push exposing (Push)


-- MODEL --


type alias Model =
    { emails : List String }


initialModel : Model
initialModel =
    { emails = [] }



-- UPDATE --


type Msg
    = HandleInitSuccess Decode.Value


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        HandleInitSuccess payload -&amp;gt;
            case Decode.decodeValue usersDecoder payload of
                Ok emails -&amp;gt;
                    { model | emails = emails } ! []

                Err _ -&amp;gt;
                    model ! []


usersDecoder : Decode.Decoder (List String)
usersDecoder =
    Decode.at [ &amp;quot;data&amp;quot; ] &amp;lt;| Decode.list Decode.string



-- INIT --


init : String -&amp;gt; ( Model, Cmd Msg )
init socketUrl =
    ( initialModel
    , Push.init &amp;quot;admin:lobby&amp;quot; &amp;quot;data&amp;quot;
        |&amp;gt; Push.onOk HandleInitSuccess
        |&amp;gt; Phoenix.push socketUrl
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For simplicity&amp;#39;s sake, the &lt;code&gt;Model&lt;/code&gt; consists of a list of strings representing the list of emails able to authenticate into the application. The &lt;code&gt;init&lt;/code&gt; function, called every time an authenticated user visits the &lt;code&gt;/&lt;/code&gt; route, receives the &lt;code&gt;socketUrl&lt;/code&gt; and pushes a &lt;code&gt;data&lt;/code&gt; message to the &lt;code&gt;admin:lobby&lt;/code&gt; channel through the socket (already connected, we&amp;#39;ll get there in a minute). If the message result is successful, it receives the list of emails, handled by the &lt;code&gt;HandleInitSuccess&lt;/code&gt; message, decodes the list and sets it as the new &lt;code&gt;Model&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;The Views modules&lt;/h3&gt;

&lt;p&gt;Having the main Page modules done, let&amp;#39;s focus now on the view modules for them.
Taking a look at the &lt;code&gt;Lobby&lt;/code&gt; page, we can see that there is a navigation bar on top, with the signout link. This navigation bar will appear in all the future private screen that we might implement, so we need to share it somehow.&lt;/p&gt;

&lt;h4&gt;Views.Page&lt;/h4&gt;

&lt;p&gt;Let&amp;#39;s add a basic module that wraps each particular view content in a container along with the navigation bar:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Views/Page.elm

module Views.Page
    exposing
        ( frameView
        , headerView
        , Msg(..)
        )

import Data.Session exposing (Session(..))
import Html exposing (Html)
import Html.Attributes as Html
import Html.Events as Html


type Msg
    = SignOut


frameView : Session -&amp;gt; Html msg -&amp;gt; Html msg -&amp;gt; Html msg
frameView session header content =
    case session of
        Anonymous -&amp;gt;
            Html.text &amp;quot;&amp;quot;

        Authenticated _ -&amp;gt;
            Html.div
                [ Html.class &amp;quot;main-section flex-1 flex-col flex h-screen&amp;quot; ]
                [ header
                , Html.div
                    [ Html.class &amp;quot;main-content bg-grey-lightest flex-1 flex items-center justify-center&amp;quot; ]
                    [ content ]
                ]


headerView : Html Msg
headerView =
    Html.header
        [ Html.class &amp;quot;main-header&amp;quot; ]
        [ Html.nav
            [ Html.class &amp;quot;flex justify-between&amp;quot; ]
            [ Html.span
                [ Html.class &amp;quot;flex-1 p-4 text-white text-left&amp;quot; ]
                [ Html.text &amp;quot;Admin panel&amp;quot; ]
            , Html.a
                [ Html.class &amp;quot;p-4&amp;quot;
                , Html.onClick SignOut
                ]
                [ Html.text &amp;quot;Sign out&amp;quot; ]
            ]
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It exposes two functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;frameView&lt;/code&gt; which defines the structure of all private screens.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headerView&lt;/code&gt; which renders the top navigation bar, with the sign-out link.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;frameView&lt;/code&gt; takes a &lt;code&gt;Session&lt;/code&gt;, so we can render the contents only when the user is authenticated, and both the &lt;code&gt;header&lt;/code&gt; and the &lt;code&gt;content&lt;/code&gt; for the particular page it is rendering.&lt;/p&gt;

&lt;h4&gt;Views.SignIn&lt;/h4&gt;

&lt;p&gt;Let&amp;#39;s add the view module for the &lt;code&gt;SignIn&lt;/code&gt; page.&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Views/SignIn.elm

module Views.SignIn exposing (view)

import Html exposing (Html, form)
import Html.Attributes as Html
import Html.Events as Html
import Page.SignIn exposing (Model, SignInForm(..), Msg(..))


view : Model -&amp;gt; Html Msg
view { form } =
    let
        content =
            case form of
                Editing email -&amp;gt;
                    formView email

                Sending email -&amp;gt;
                    formView email

                Success text -&amp;gt;
                    successMessageView text

                Error text -&amp;gt;
                    errorMessageView text
    in
        Html.section
            [ Html.class &amp;quot;bg-purple-darker p-8 flex flex-1 items-center justify-center h-screen&amp;quot; ]
            [ content ]


formView : String -&amp;gt; Html Msg
formView email =
    Html.div
        []
        [ Html.img
            [ Html.src &amp;quot;/images/icons8-mailbox-128.png&amp;quot;
            , Html.class &amp;quot;mb-4 slide-in-blurred-top&amp;quot;
            ]
            []
        , Html.h3
            []
            [ Html.text &amp;quot;Password long? Hard to type?&amp;quot; ]
        , Html.p
            []
            [ Html.text &amp;quot;Get a magic link sent to your email that&amp;#39;ll sign you instantly!&amp;quot; ]
        , form
            [ Html.class &amp;quot;w-full max-w-md&amp;quot;
            , Html.onSubmit HandleFormSubmit
            ]
            [ Html.input
                [ Html.class &amp;quot;appearance-none block w-full bg-grey-lighter text-grey-darker rounded py-3 px-4 mb-3&amp;quot;
                , Html.placeholder &amp;quot;foo@email.com&amp;quot;
                , Html.type_ &amp;quot;email&amp;quot;
                , Html.onInput HandleEmailInput
                , Html.value email
                ]
                []
            , Html.button
                [ Html.class &amp;quot;bg-blue hover:bg-blue-dark text-white py-3 px-4 mb-3 rounded w-full&amp;quot; ]
                [ Html.text &amp;quot;Send Magic Link&amp;quot; ]
            ]
        ]


successMessageView : String -&amp;gt; Html Msg
successMessageView message =
    Html.div
        []
        [ Html.img
            [ Html.src &amp;quot;/images/icons8-postal-128.png&amp;quot;
            , Html.class &amp;quot;mb-4 jello-horizontal&amp;quot;
            ]
            []
        , Html.h3
            []
            [ Html.text &amp;quot;Check your email&amp;quot; ]
        , Html.p
            []
            [ Html.text message ]
        ]


errorMessageView : String -&amp;gt; Html Msg
errorMessageView message =
    Html.div
        []
        [ Html.h3
            []
            [ Html.text &amp;quot;Whoops!&amp;quot; ]
        , Html.p
            []
            [ Html.text message ]
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;view&lt;/code&gt; function returns the content to render, depending on the value of the custom type we created previously for the model&amp;#39;s form.&lt;/p&gt;

&lt;h4&gt;View.Lobby&lt;/h4&gt;

&lt;p&gt;The next view we are going to implement is the view for the &lt;code&gt;Lobby&lt;/code&gt; page, so let&amp;#39;s go ahead and add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Views/Lobby.elm

module Views.Lobby exposing (view)

import Html exposing (Html, form)
import Html.Keyed
import Html.Attributes as Html
import Data.Session exposing (User)
import Page.Lobby exposing (Model, Msg(..))


view : User -&amp;gt; Model -&amp;gt; Html Msg
view { email } model =
    Html.div
        []
        [ Html.img
            [ Html.src &amp;quot;/images/icons8-confetti-128.png&amp;quot;
            , Html.class &amp;quot;mb-4 jello-horizontal&amp;quot;
            ]
            []
        , Html.h3
            []
            [ Html.text &amp;lt;| &amp;quot;Welcome &amp;quot; ++ email ++ &amp;quot;!&amp;quot; ]
        , Html.p
            []
            [ Html.text &amp;quot;You signed in successfully.&amp;quot; ]
        , Html.p
            []
            [ Html.text &amp;quot;List of authorized users:&amp;quot; ]
        , model
            |&amp;gt; List.map emailView
            |&amp;gt; Html.Keyed.ul [ Html.class &amp;quot;inline-block m-0 p-0&amp;quot; ]
        ]


emailView : String -&amp;gt; ( String, Html Msg )
emailView email =
    ( email
    , Html.li
        []
        [ Html.text email ]
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its &lt;code&gt;view&lt;/code&gt; function receives the current &lt;code&gt;User&lt;/code&gt; and its model, which consists of a list of emails, and renders them in the screen.&lt;/p&gt;

&lt;h4&gt;View.NotFound&lt;/h4&gt;

&lt;p&gt;Finally, let&amp;#39;s add the view to render unexisting pages, in case the user visits a wrong route:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Views/NotFound.elm

module Views.NotFound exposing (view)

import Html exposing (Html, form)


view : Html msg
view =
    Html.div
        []
        [ Html.h1
            []
            [ Html.text &amp;quot;404&amp;quot; ]
        , Html.p
            []
            [ Html.text &amp;quot;Page not found&amp;quot; ]
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The Main module&lt;/h3&gt;

&lt;p&gt;With our page specific logic and views, we can start editing the &lt;code&gt;Main&lt;/code&gt; module. As this module is quite big, let&amp;#39;s split it into different chunks of code.&lt;/p&gt;

&lt;h4&gt;The model section&lt;/h4&gt;

&lt;pre&gt;&lt;code class="elm"&gt;module Main exposing (main)

import Data.Session exposing (Session(..))
import Html exposing (Html, form, map)
import Json.Decode as Decode exposing (Value)
import Navigation exposing (Location)
import Page.Lobby
import Page.SignIn
import Phoenix
import Phoenix.Channel as Channel exposing (Channel)
import Phoenix.Push as Push exposing (Push)
import Phoenix.Socket as Socket exposing (AbnormalClose, Socket)
import Ports
import Route exposing (Route(..))
import Views.Lobby
import Views.Page
import Views.SignIn



-- MODEL --


type ConnectionStatus
    = Connecting
    | Connected ChannelState
    | Disconnected


type ChannelState
    = Joining
    | Joined
    | Left


type Page
    = BlankPage
    | NotFoundPage
    | SignInPage Page.SignIn.Model
    | LobbyPage Page.Lobby.Model


type alias Flags =
    { token : Maybe String
    , socketUrl : String
    }


type alias Model =
    { page : Page
    , session : Session
    , connectionStatus : ConnectionStatus
    , flags : Flags
    }
-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main &lt;code&gt;Model&lt;/code&gt; consists of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;page&lt;/code&gt; which is a custom type representing the current &lt;code&gt;Page&lt;/code&gt; state.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt; which holds information about the authenticated user.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connectionStatus&lt;/code&gt; which is another custom type representing the status of the socket connection and the channel state.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flags&lt;/code&gt; which stores the configuration data passed from the outside while initializing the application.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;The update section&lt;/h4&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- UPDATE --


type Msg
    = SetRoute (Maybe Route)
    | ConnectionStatusChanged ConnectionStatus
    | HandleAdminChannelJoin Decode.Value
    | ViewsPageMsg Views.Page.Msg
    | HandleSignOutSuccess Decode.Value
    | PageSignInMsg Page.SignIn.Msg
    | PageLobbyMsg Page.Lobby.Msg


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg ({ flags, page } as model) =
    let
        { socketUrl } =
            flags

        toPage toModel toMsg subUpdate subMsg subModel =
            let
                ( newModel, newCmd ) =
                    subUpdate subMsg subModel
            in
            ( { model | page = toModel newModel }, Cmd.map toMsg newCmd )
    in
    case ( msg, page ) of
        ( SetRoute route, _ ) -&amp;gt;
            setRoute route model

        ( ConnectionStatusChanged connectionStatus, _ ) -&amp;gt;
            let
                cmds =
                    case connectionStatus of
                        Disconnected -&amp;gt;
                            [ Route.newUrl SignInRoute
                            , Ports.saveToken Nothing
                            ]

                        _ -&amp;gt;
                            []
            in
            { model | connectionStatus = connectionStatus } ! cmds

        ( HandleAdminChannelJoin payload, _ ) -&amp;gt;
            case Decode.decodeValue Data.Session.decoder payload of
                Ok user -&amp;gt;
                    { model
                        | session =
                            Authenticated user
                        , connectionStatus = Connected Joined
                    }
                        ! [ Ports.saveToken model.flags.token ]

                Err error -&amp;gt;
                    let
                        _ =
                            Debug.log &amp;quot;Error&amp;quot; error
                    in
                    model ! []

        ( HandleSignOutSuccess _, _ ) -&amp;gt;
            { model
                | connectionStatus = Disconnected
                , session = Anonymous
            }
                ! [ Route.newUrl SignInRoute, Ports.saveToken Nothing ]

        ( ViewsPageMsg subMsg, _ ) -&amp;gt;
            case subMsg of
                Views.Page.SignOut -&amp;gt;
                    model
                        ! [ Push.init &amp;quot;admin:lobby&amp;quot; &amp;quot;sign_out&amp;quot;
                                |&amp;gt; Push.onOk HandleSignOutSuccess
                                |&amp;gt; Phoenix.push socketUrl
                          ]

        ( ViewsPageMsg subMsg, _ ) -&amp;gt;
            case subMsg of
                Views.Page.SignOut -&amp;gt;
                    model
                        ! [ Push.init &amp;quot;admin:lobby&amp;quot; &amp;quot;sign_out&amp;quot;
                                |&amp;gt; Push.onOk HandleSignOutSuccess
                                |&amp;gt; Phoenix.push socketUrl
                          ]

        ( PageSignInMsg subMsg, SignInPage subModel ) -&amp;gt;
            toPage SignInPage PageSignInMsg Page.SignIn.update subMsg subModel

        ( PageLobbyMsg subMsg, LobbyPage subModel ) -&amp;gt;
            toPage LobbyPage PageLobbyMsg Page.Lobby.update subMsg subModel

        ( _, _ ) -&amp;gt;
            model ! []


setRoute : Maybe Route -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
setRoute maybeRoute ({ connectionStatus, session, flags } as model) =
    let
        transition init page toMsg =
            let
                ( subModel, subCmd ) =
                    init
            in
            { model | page = page subModel } ! [ Cmd.map toMsg subCmd ]
    in
    case maybeRoute of
        Nothing -&amp;gt;
            { model | page = NotFoundPage } ! [ Cmd.none ]

        Just SignInRoute -&amp;gt;
            { model | page = SignInPage Page.SignIn.initialModel } ! [ Cmd.none ]

        Just LobbyRoute -&amp;gt;
            case connectionStatus of
                Disconnected -&amp;gt;
                    model ! [ Route.newUrl SignInRoute ]

                _ -&amp;gt;
                    transition (Page.Lobby.init flags.socketUrl) LobbyPage PageLobbyMsg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;update&lt;/code&gt; function evaluates the current &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;page&lt;/code&gt;, and depending on the combination takes one of the following actions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;( SetRoute route, _ )&lt;/code&gt; means a route change, so it calls the &lt;code&gt;setRoute&lt;/code&gt; function to initialize the page state depending on the new route.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( ConnectionStatusChanged connectionStatus, _ )&lt;/code&gt; handles changes in the socket connection, and calls a port to delete the stored authentication token from &lt;code&gt;localStorage&lt;/code&gt; and redirects to the &lt;code&gt;SignInRoute&lt;/code&gt; route, and sets the new connection status in the model.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( HandleAdminChannelJoin payload, _ )&lt;/code&gt; handles the success of joining the admin channel, setting the user&amp;#39;s data into the &lt;code&gt;session&lt;/code&gt; key of the model, and changing the connection state to the proper one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( HandleSignOutSuccess _, _ )&lt;/code&gt; sets &lt;code&gt;connectionStatus&lt;/code&gt; to disconnected, resets the session user to &lt;code&gt;Nothing&lt;/code&gt;, calls the port to delete the token and redirect to the &lt;code&gt;SignInRoute&lt;/code&gt; route.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( ViewsPageMsg subMsg, _ )&lt;/code&gt; checks for &lt;code&gt;Views.Page.SignOut&lt;/code&gt; messages, sent by clicking on the sign-out link of the header and sends a &lt;code&gt;sign_out&lt;/code&gt; message to the admin channel through the socket.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( PageSignInMsg subMsg, SignInPage subModel )&lt;/code&gt; and &lt;code&gt;( PageLobbyMsg subMsg, LobbyPage subModel )&lt;/code&gt; update the current page state using their corresponding update function.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;setRoute&lt;/code&gt; function takes care of two different things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It initializes the current route page model.&lt;/li&gt;
&lt;li&gt;Redirects to the &lt;code&gt;SignInRoute&lt;/code&gt; route if the user is not connected to the socket, which means that is not authenticated.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;The view section&lt;/h4&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- VIEW --


view : Model -&amp;gt; Html Msg
view { session, page } =
    let
        header =
            Html.map ViewsPageMsg Views.Page.headerView

        frame =
            Views.Page.frameView session header
    in
    case ( page, session ) of
        ( SignInPage subModel, _ ) -&amp;gt;
            map PageSignInMsg (Views.SignIn.view subModel)

        ( LobbyPage subModel, Authenticated user ) -&amp;gt;
            frame &amp;lt;| map PageLobbyMsg (Views.Lobby.view user subModel)

        ( NotFoundPage, Authenticated _ ) -&amp;gt;
            frame Views.NotFound.view

        _ -&amp;gt;
            frame &amp;lt;| Html.text &amp;quot;View not implemented yet&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;view&lt;/code&gt; function takes the current model, and depending on the current &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;session&lt;/code&gt;, renders the necessary view wrapping it with the &lt;code&gt;frame&lt;/code&gt; or not.&lt;/p&gt;

&lt;h4&gt;The subscriptions section&lt;/h4&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- SUBSCRIPTIONS --


socket : Flags -&amp;gt; Socket Msg
socket { socketUrl, token } =
    Socket.init socketUrl
        |&amp;gt; Socket.withParams [ ( &amp;quot;token&amp;quot;, Maybe.withDefault &amp;quot;&amp;quot; token ) ]
        |&amp;gt; Socket.onOpen (ConnectionStatusChanged (Connected Joining))
        |&amp;gt; Socket.onClose (\_ -&amp;gt; ConnectionStatusChanged Disconnected)
        |&amp;gt; Socket.withDebug


subscriptions : Model -&amp;gt; Sub Msg
subscriptions { connectionStatus, flags } =
    let
        { token } =
            flags

        adminChannel =
            Channel.init &amp;quot;admin:lobby&amp;quot;
                |&amp;gt; Channel.onJoin HandleAdminChannelJoin
                |&amp;gt; Channel.withDebug
    in
    case connectionStatus of
        Disconnected -&amp;gt;
            Sub.none

        _ -&amp;gt;
            Phoenix.connect (socket flags) [ adminChannel ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on the &lt;code&gt;connectionStatus&lt;/code&gt; it tries to connect to the &lt;strong&gt;Phoenix&lt;/strong&gt; &lt;code&gt;Socket&lt;/code&gt;, changing the status to &lt;code&gt;Connected Joining&lt;/code&gt; if the server-side authentication is successful. On the contrary, it sets it to &lt;code&gt;Disconnected&lt;/code&gt; which redirects to the sign-in page as we have previously seen.&lt;/p&gt;

&lt;h4&gt;The main and init section&lt;/h4&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- MAIN AND INIT --


init : Flags -&amp;gt; Location -&amp;gt; ( Model, Cmd Msg )
init flags location =
    let
        ( model, cmd ) =
            setRoute (Route.fromLocation location)
                { page = BlankPage
                , session = Anonymous
                , connectionStatus = Connecting
                , flags = flags
                }
    in
    model ! [ cmd ]


main : Program Flags Model Msg
main =
    Navigation.programWithFlags (Route.fromLocation &amp;gt;&amp;gt; SetRoute)
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As &lt;code&gt;main&lt;/code&gt; returns a &lt;code&gt;Navigation.programWithFlags&lt;/code&gt; application, the &lt;code&gt;init&lt;/code&gt; function takes the received &lt;code&gt;Flags&lt;/code&gt; and a &lt;code&gt;Location&lt;/code&gt;, calling &lt;code&gt;setRoute&lt;/code&gt; to initialize the application&amp;#39;s state depending on the current route.&lt;/p&gt;

&lt;h3&gt;Additional stuff&lt;/h3&gt;

&lt;p&gt;We have almost covered everything excepting two missing modules:&lt;/p&gt;

&lt;h4&gt;The Ports module&lt;/h4&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Ports.elm

port module Ports exposing (saveToken)


port saveToken : Maybe String -&amp;gt; Cmd msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;saveToken&lt;/code&gt; is a port, which sends the valid authentication token, or an empty one, to the main &lt;code&gt;app.js&lt;/code&gt; script where it is stored using &lt;code&gt;localStorage&lt;/code&gt;. The reason for this behaviour is that we want to reuse the valid token to reconnect if the user refreshes the browser, or delete it in case the user signs out.&lt;/p&gt;

&lt;h4&gt;The Data.Session module&lt;/h4&gt;

&lt;p&gt;As we are using &lt;code&gt;Session&lt;/code&gt; all over the place, and to prevent circular dependencies, it makes sense having everything related to &lt;code&gt;Session&lt;/code&gt; in its own module.&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- apps/passwordless_auth_web/assets/elm/src/Data/Session.elm

module Data.Session exposing
    ( Session(..)
    , User
    , decoder
    , encode
    )

import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline exposing (decode, required)
import Json.Encode as Encode exposing (Value)


type alias User =
    { email : String }


type Session
    = Anonymous
    | Authenticated User



-- SERIALIZATION --


decoder : Decoder User
decoder =
    decode User
        |&amp;gt; required &amp;quot;email&amp;quot; Decode.string


encode : User -&amp;gt; Decode.Value
encode user =
    Encode.object
        [ ( &amp;quot;email&amp;quot;, Encode.string user.email )
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again we rely on a custom type to define &lt;code&gt;Session&lt;/code&gt; which can be either &lt;code&gt;Anonymous&lt;/code&gt; or &lt;code&gt;Authenticated User&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;The Phoenix AdminChannel&lt;/h3&gt;

&lt;p&gt;If we start the application, we can see errors related to socket connection. This is because we haven&amp;#39;t created the &lt;code&gt;AdminChannel&lt;/code&gt; yet, so let&amp;#39;s go ahead and add its definition to the &lt;code&gt;UserSocket&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/channels/user_socket.ex

defmodule PasswordlessAuthWeb.UserSocket do
  # ...

  channel(&amp;quot;admin:*&amp;quot;, PasswordlessAuthWeb.AdminChannel)

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, the channel module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/channels/admin_channel.ex

defmodule PasswordlessAuthWeb.AdminChannel do
  use PasswordlessAuthWeb, :channel

  require Logger

  alias PasswordlessAuth.Repo

  def join(&amp;quot;admin:lobby&amp;quot;, _payload, socket) do
    {:ok, socket.assigns.user, socket}
  end

  def handle_in(&amp;quot;data&amp;quot;, _, socket) do
    admin_emails = Application.get_env(:passwordless_auth, :repo)[:emails]

    {:reply, {:ok, %{data: admin_emails}}, socket}
  end

  def handle_in(&amp;quot;sign_out&amp;quot;, _, socket) do
    email = socket.assigns.user.email
    :ok = Repo.invalidate(email)

    {:reply, {:ok, %{success: true}}, socket}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The logic for this module is very simple:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;join&lt;/code&gt; always returns success and the authenticated user data assigned to the connection.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle_in(&amp;quot;data&amp;quot;, _, _)&lt;/code&gt; returns the existing list of valid emails so that we can render it in the lobby view.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle_in(&amp;quot;sign_out&amp;quot;, _, _)&lt;/code&gt; takes the assigned email and invalidates its token in the repository, so cannot use it again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So that&amp;#39;s pretty much it. We finally have our basic &lt;strong&gt;Elm&lt;/strong&gt; SPA admin panel, backed with a &lt;strong&gt;Phoenix&lt;/strong&gt; passwordless and databaseless system. While I was writing this post, I have refactored many parts of the application so I probably might have missed including some of the changes. Therefore, don&amp;#39;t forget to check out the source code for the missing pieces, and sorry for any inconvenience. &lt;strong&gt;Elm 0.19.0&lt;/strong&gt; just came out, so I&amp;#39;m planning to write a new part about upgrading it, once it has proper support for Websockets.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Elixir and Phoenix basic passwordless and databaseless authentication (pt.2)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2/"/>
    <id>http://codeloveandboards.com/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2/</id>
    <published>2018-06-20T07:00:00Z</published>
    <updated>2018-09-01T07:53:25+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Elixir and Phoenix basic passwordless and databaseless authentication&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;Project setup and the initial functionality for storing and verifying authentication tokens&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2"&gt;Sending authentication link emails and the user socket connection&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/09/01/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3"&gt;Setting up webpack as our asset bundler and the Elm single-page application&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;previous part&lt;/a&gt; of the series, we set up the umbrella application for our new project and created the necessary modules for storing and generating authentication tokens. Having this done, the next step is sending emails to valid users, containing the sign-in link that will authenticate them into the system once clicked.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result" src="https://monosnap.com/image/5VUT424b4Hu9ITi8r1SGae7HQleCPT.png" /&gt;&lt;/p&gt;

&lt;h3&gt;Sending emails&lt;/h3&gt;

&lt;p&gt;To send emails in an Elixir application I usually rely on &lt;a href="https://github.com/thoughtbot/bamboo"&gt;Bamboo&lt;/a&gt; from the awesome team at &lt;a href="https://thoughtbot.com/"&gt;thoughtbot&lt;/a&gt;, which is not only simple and powerful, but very customizable as well. Let&amp;#39;s go ahead and add the dependency to the project, under the &lt;code&gt;PasswordlessAuthWeb&lt;/code&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/mix.exs

defmodule PasswordlessAuthWeb.Mixfile do
  use Mix.Project

  # ...

  defp deps do
    [
      {:phoenix, &amp;quot;~&amp;gt; 1.3.2&amp;quot;},
      {:phoenix_pubsub, &amp;quot;~&amp;gt; 1.0&amp;quot;},
      {:phoenix_html, &amp;quot;~&amp;gt; 2.10&amp;quot;},
      {:phoenix_live_reload, &amp;quot;~&amp;gt; 1.0&amp;quot;, only: :dev},
      {:gettext, &amp;quot;~&amp;gt; 0.11&amp;quot;},
      {:passwordless_auth, in_umbrella: true},
      {:cowboy, &amp;quot;~&amp;gt; 1.0&amp;quot;},
      {:bamboo, &amp;quot;~&amp;gt; 0.8&amp;quot;}
    ]
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;#39;t forget to run the necessary &lt;code&gt;deps.get&lt;/code&gt; mix task in order to install it. Next step is configuring Bamboo:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/config/config.exs

use Mix.Config

# ...

# Bamboo mailer configuration
config :passwordless_auth_web,
       PasswordlessAuthWeb.Service.Mailer,
       adapter: Bamboo.LocalAdapter

# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the configuration we are specifying two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The name of the module we are going to use as an interface with &lt;code&gt;Bamboo&lt;/code&gt;&amp;#39;s functionality.&lt;/li&gt;
&lt;li&gt;The adapter we want to use to send emails.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For our particular case and while developing the project, we are going to take advantage of the &lt;a href="https://hexdocs.pm/bamboo/Bamboo.LocalAdapter.html"&gt;LocalAdapter&lt;/a&gt; which stores sent emails in memory and offers us a small inbox application where we can view them. In order to have access to this inbox application, we need to mount a new route it in the router, which will be only accessible in the &lt;code&gt;:dev&lt;/code&gt; environment:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/router.ex

defmodule PasswordlessAuthWeb.Router do
  use PasswordlessAuthWeb, :router

  if Mix.env() == :dev, do: forward(&amp;quot;/sent_emails&amp;quot;, Bamboo.EmailPreviewPlug)

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only part we are missing is creating the &lt;code&gt;Mailer&lt;/code&gt; module, so let&amp;#39;s go ahead and add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/service/mailer.ex

defmodule PasswordlessAuthWeb.Service.Mailer do
  use Bamboo.Mailer, otp_app: :passwordless_auth_web
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start the Phoenix server at this point and visit &lt;a href="http://localhost:4000/sent_emails"&gt;http://localhost:4000/sent_emails&lt;/a&gt;, we should see the following message:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Empty inbox" src="https://monosnap.com/image/gB604OQdzH4yWfhptA9PyaxD16M3AD.png" /&gt;&lt;/p&gt;

&lt;p&gt;This is completely fine, as we haven&amp;#39;t sent any emails yet, so let&amp;#39;s go ahead and create the necessary functionality to build up an email containing the authentication link using an email address and a token:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/emails/auth_email.


defmodule PasswordlessAuthWeb.Emails.AuthEmail do
  import Bamboo.Email, only: [new_email: 1]
  import PasswordlessAuthWeb.Router.Helpers, only: [page_url: 4]

  @from &amp;quot;support@passwordlessauth.com&amp;quot;

  def build(email, token) do
    url = page_url(PasswordlessAuthWeb.Endpoint, :index, [], token: token)

    new_email(
      to: email,
      from: @from,
      subject: &amp;quot;Your authentication link&amp;quot;,
      html_body: &amp;quot;&amp;quot;&amp;quot;
      &amp;lt;p&amp;gt;Here is your authentication link:&amp;lt;/p&amp;gt;
      &amp;lt;a href=&amp;quot;#{url}&amp;quot;&amp;gt;#{url}&amp;lt;/a&amp;gt;
      &amp;lt;p&amp;gt;It is valid for 5 minutes.&amp;lt;/p&amp;gt;
      &amp;quot;&amp;quot;&amp;quot;,
      text_body: &amp;quot;&amp;quot;&amp;quot;
      Here is your authentication link: \n
      #{url}\n
      It is valid for 5 minutes.
      &amp;quot;&amp;quot;&amp;quot;
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the token parameter and thanks to Phoenix&amp;#39;s route helpers, we build the new Bamboo email which has the authentication link in its body, and which addressee is the email parameter. For the time being, let&amp;#39;s use the default route that comes with Phoenix out of the box, and which points to &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s test this out by starting the Phoenix server again and sending a new email:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;$ iex -S mix phx.server
Erlang/OTP 21 [erts-10.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

[info] Running PasswordlessAuthWeb.Endpoint with Cowboy using http://0.0.0.0:4000
Interactive Elixir (1.6.6) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; email = PasswordlessAuthWeb.Emails.AuthEmail.build(&amp;quot;foo@email.com&amp;quot;, &amp;quot;token&amp;quot;)
%Bamboo.Email{
  assigns: %{},
  bcc: nil,
  cc: nil,
  from: &amp;quot;support@passwordlessauth.com&amp;quot;,
  headers: %{},
  html_body: &amp;quot;&amp;lt;p&amp;gt;Here is your authentication link:&amp;lt;/p&amp;gt;\n&amp;lt;a href=\&amp;quot;http://localhost:4000/?token=token\&amp;quot;&amp;gt;http://localhost:4000/?token=token&amp;lt;/a&amp;gt;\n&amp;lt;p&amp;gt;It is valid for 5 minutes.&amp;lt;/p&amp;gt;\n&amp;quot;,
  private: %{},
  subject: &amp;quot;Your authentication link&amp;quot;,
  text_body: &amp;quot;Here is your authentication link: \n\nhttp://localhost:4000/?token=token\n\nIt is valid for 5 minutes.\n&amp;quot;,
  to: &amp;quot;foo@email.com&amp;quot;
}
iex(2)&amp;gt; PasswordlessAuthWeb.Service.Mailer.deliver_later email
[debug] Sending email with Bamboo.LocalAdapter:

%Bamboo.Email{assigns: %{}, bcc: [], cc: [], from: {nil, &amp;quot;support@passwordlessauth.com&amp;quot;}, headers: %{}, html_body: &amp;quot;&amp;lt;p&amp;gt;Here is your authentication link:&amp;lt;/p&amp;gt;\n&amp;lt;a href=\&amp;quot;http://localhost:4000/?token=token\&amp;quot;&amp;gt;http://localhost:4000/?token=token&amp;lt;/a&amp;gt;\n&amp;lt;p&amp;gt;It is valid for 5 minutes.&amp;lt;/p&amp;gt;\n&amp;quot;, private: %{}, subject: &amp;quot;Your authentication link&amp;quot;, text_body: &amp;quot;Here is your authentication link: \n\nhttp://localhost:4000/?token=token\n\nIt is valid for 5 minutes.\n&amp;quot;, to: [nil: &amp;quot;foo@email.com&amp;quot;]}

iex(3)&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we revisit &lt;a href="http://localhost:4000/sent_emails"&gt;http://localhost:4000/sent_emails&lt;/a&gt;, we can see the email that we just sent:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Bamboo inbox" src="https://monosnap.com/image/PLsLxEljpZnc3KHuJLc7oR3Tl0CLPK.png" /&gt;&lt;/p&gt;

&lt;p&gt;But, how are the users going to request the authentication email?&lt;/p&gt;

&lt;h3&gt;The authentication controller&lt;/h3&gt;

&lt;p&gt;Despite the admin site being an Elm single page application, that relies on a socket connection, we still need to provide a mechanism so users can request the authentication email. Let&amp;#39;s use a controller for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/controllers/authentication_controller.ex

defmodule PasswordlessAuthWeb.AuthenticationController do
  use PasswordlessAuthWeb, :controller

  alias PasswordlessAuthWeb.{Emails.AuthEmail, Service.Mailer}

  @email_regex ~r/^[A-Za-z0-9._%+-+&amp;#39;]+@[A-Za-z0-9.-]+\.[A-Za-z]+$/

  def create(conn, params) do
    with %{&amp;quot;email&amp;quot; =&amp;gt; email} &amp;lt;- params,
         true &amp;lt;- valid_email?(email),
         {:ok, token} &amp;lt;- PasswordlessAuth.provide_token_for(email) do
      build_and_deliver_email(email, token)
    end

    json(conn, %{message: gettext(&amp;quot;auth.message&amp;quot;)})
  end

  def valid_email?(email), do: Regex.match?(@email_regex, email)

  defp build_and_deliver_email(email, token) do
    email
    |&amp;gt; AuthEmail.build(token)
    |&amp;gt; Mailer.deliver_later()
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the received parameters contain the &lt;code&gt;email&lt;/code&gt; with a valid format, it provides a token, builds and delivers the authentication email. On the contrary, for security reasons we don&amp;#39;t want to give any clues to the user if the email provided has a wrong format or it does not exist, so it just returns the same success message. Let&amp;#39;s add a new route for this controller and action:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/router.ex

defmodule PasswordlessAuthWeb.Router do
  use PasswordlessAuthWeb, :router

    if Mix.env() == :dev, do: forward(&amp;quot;/sent_emails&amp;quot;, Bamboo.EmailPreviewPlug)

    # ...

    pipeline :api do
        plug(:accepts, [&amp;quot;json&amp;quot;])
    end

    # ...

    scope &amp;quot;/api&amp;quot;, PasswordlessAuthWeb do
        pipe_through(:api)

        post(&amp;quot;/auth&amp;quot;, AuthenticationController, :create)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, to check that everything works as we expect, let&amp;#39;s add a new test module for the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/test/passwordless_auth_web/controllers/authentication_controller_test.exs

defmodule PasswordlessAuthWeb.AuthenticationControllerTest do
  use PasswordlessAuthWeb.ConnCase
  use Bamboo.Test

  import PasswordlessAuthWeb.Gettext

  alias PasswordlessAuth.Repo
  alias PasswordlessAuthWeb.Emails.AuthEmail

  describe &amp;quot;POST /api/auth&amp;quot; do
    test &amp;quot;always returns success message no matter what parameters receives&amp;quot;, %{conn: conn} do
      conn = post(conn, authentication_path(conn, :create), email: &amp;quot;foo@test.com&amp;quot;)
      assert %{&amp;quot;message&amp;quot; =&amp;gt; _} = json_response(conn, 200)

      conn = post(conn, authentication_path(conn, :create), %{})
      assert assert %{&amp;quot;message&amp;quot; =&amp;gt; _} = json_response(conn, 200)
    end

    test &amp;quot;delivers the email only when valid email&amp;quot;, %{conn: conn} do
      email = &amp;quot;#{__MODULE__}@email.com&amp;quot;
      Repo.add_email(email)

      post(conn, authentication_path(conn, :create), email: email)

      {:ok, token} = Repo.fetch(email)

      assert_delivered_email(AuthEmail.build(email, token))
    end

    test &amp;quot;does not deliver the email only when invalid email format&amp;quot;, %{conn: conn} do
      email = &amp;quot;#{__MODULE__}emailcom&amp;quot;
      Repo.add_email(email)

      post(conn, authentication_path(conn, :create), email: email)

      {:ok, token} = Repo.fetch(email)

      refute_delivered_email(AuthEmail.build(email, token))
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run it, we can check that it is actually working fine:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth_web/controllers/authentication_controller_test.exs
==&amp;gt; passwordless_auth
Test patterns did not match any file: test/passwordless_auth_web/controllers/authentication_controller_test.exs
==&amp;gt; passwordless_auth_web
...

Finished in 0.1 seconds
3 tests, 0 failures

Randomized with seed 547795
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yay! Now that we have the email generation and delivery sorted out, let&amp;#39;s move on the next important part of our application, the user socket.&lt;/p&gt;

&lt;h3&gt;Authenticating the user socket connection&lt;/h3&gt;

&lt;p&gt;Phoenix creates a default &lt;code&gt;UserSocket&lt;/code&gt; module while bootstrapping a new project, so let&amp;#39;s edit it to add the authentication logic:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/channels/user_socket.ex

defmodule PasswordlessAuthWeb.UserSocket do
  use Phoenix.Socket

  alias PasswordlessAuth

  ## Transports
  transport(:websocket, Phoenix.Transports.WebSocket)

  def connect(%{&amp;quot;token&amp;quot; =&amp;gt; token}, socket) do
    case PasswordlessAuth.verify_token(token) do
      {:ok, email} -&amp;gt;
        {:ok, assign(socket, :user, %{email: email})}

      _ -&amp;gt;
        :error
    end
  end

  def connect(_, _socket), do: :error

  def id(socket), do: &amp;quot;user_socket:#{socket.assigns.user.email}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;connect/2&lt;/code&gt; callback function receives a &lt;code&gt;token&lt;/code&gt; parameter, and using &lt;code&gt;PasswordlessAuth.verify_token/1&lt;/code&gt; checks whether this token is valid or not, assigning to the socket the corresponding email on success. On the other hand, if no &lt;code&gt;token&lt;/code&gt; parameter is received or the verification goes wrong, it returns &lt;code&gt;:error&lt;/code&gt; rejecting the connection. Let&amp;#39;s add some unit tests to ensure that it works as we expect:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/test/passwordless_auth_web/channels/user_socket_test.exs

defmodule PasswordlessAuthWeb.UserSocketTest do
  use PasswordlessAuthWeb.ChannelCase, async: true

  alias Phoenix.Socket
  alias PasswordlessAuth.Repo
  alias PasswordlessAuthWeb.UserSocket

  describe &amp;quot;connect/2&amp;quot; do
    test &amp;quot;errors when passing invalid params or token&amp;quot; do
      assert :error = connect(UserSocket, %{})
      assert :error = connect(UserSocket, %{&amp;quot;token&amp;quot; =&amp;gt; &amp;quot;invalid-token&amp;quot;})
    end

    test &amp;quot;joins when passing valid token&amp;quot; do
      email = &amp;quot;foo@#{__MODULE__}.com&amp;quot;
      :ok = Repo.add_email(email)
      {:ok, token} = PasswordlessAuth.provide_token_for(email)

      assert {:ok, %Socket{assigns: %{user: %{email: ^email}}}} =
               connect(UserSocket, %{&amp;quot;token&amp;quot; =&amp;gt; token})
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run them to check the result:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth_web/channels/user_socket_test.exs
==&amp;gt; passwordless_auth
Test patterns did not match any file: test/passwordless_auth_web/channels/user_socket_test.exs
==&amp;gt; passwordless_auth_web
..

Finished in 0.06 seconds
2 tests, 0 failures

Randomized with seed 589379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, it works! I think this is all for today. In the next part, we will work on the front end side, configuring &lt;a href="https://webpack.js.org/"&gt;webpack&lt;/a&gt; as our asset build tool of choice, adding Elm support to start building the admin single page application, using everything we have done until now to authenticate users. In the meantime, don&amp;#39;t forget to check out the source code with the final result:&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir and Phoenix basic passwordless and databaseless authentication (pt.1)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1/"/>
    <id>http://codeloveandboards.com/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1/</id>
    <published>2018-06-09T07:00:00Z</published>
    <updated>2018-09-20T08:30:26+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Elixir and Phoenix basic passwordless and databaseless authentication&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;Project setup and the initial functionality for storing and verifying authentication tokens&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2"&gt;Sending authentication link emails and the user socket connection&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/09/01/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3"&gt;Setting up webpack as our asset bundler and the Elm single-page application&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Have you found yourself working on a small project where, at some point,
you are asked to give access to some users to a private part of the
application or a small admin panel of some sort? Depending on the
project&amp;#39;s constraints, we can resolve this situation in many different
ways. For instance, if having administrator profiles and roles forms part
of the business logic and the scope of the project, having a standard
authorization and authentication system is probably the way to go. On the
other hand, if we only need administrator users to authenticate and let
them have access to a private part, we can rely on other simple
alternatives like HTTP basic authentication, which might not be as
flexible and secure as we might need them to be.&lt;/p&gt;

&lt;h3&gt;Passwordless authentication&lt;/h3&gt;

&lt;p&gt;A couple of years ago I read &lt;a href="https://www.smashingmagazine.com/2016/06/the-current-state-of-authentication-we-have-a-password-problem/"&gt;this excellent article&lt;/a&gt; about the current
state of authentication where it showcases the most common ways of
authenticating users, describing their strengths and weaknesses.
Between all of them, passwordless authentication is the one that I liked
the most, as the perfect balance between ease of implementation and security
strength, using this approach in many different projects since then.
If you are not familiar with this technique, it mainly
consists of asking the user for an email address and sending a link
which will automatically authenticate them into the application, just like
Slack does. I&amp;#39;m very pleased with the result so far, as my users
don&amp;#39;t need to remember passwords anymore (which tend to be frequently
forgotten), and I don&amp;#39;t have to deal with credentials storage, validation and
recovery any longer.&lt;/p&gt;

&lt;h3&gt;Databaseless authentication&lt;/h3&gt;

&lt;p&gt;As I said before, sometimes we don&amp;#39;t need a complex authentication system
which involves modifying the database schema or altering the existing
business logic to let a few users access a particular part of the
application. Therefore, I want to experiment alternative ways of storing
credentials, and Elixir is perfect for this particular use case.&lt;/p&gt;

&lt;h3&gt;What are we building&lt;/h3&gt;

&lt;p&gt;For this experiment, we are building a small &lt;a href="https://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-projects.html#umbrella-projects"&gt;Elixir umbrella project&lt;/a&gt;
which consists of two applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;passwordless_auth&lt;/strong&gt;: Responsible for token generation, storage and
authentication logic.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;passwordless_auth_web&lt;/strong&gt;: Responsible for sending authentication emails and serving the Elm SPA to test out our auth experiment against a Phoenix socket.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The final result looks something like this:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result" src="https://monosnap.com/image/5VUT424b4Hu9ITi8r1SGae7HQleCPT.png" /&gt;&lt;/p&gt;

&lt;p&gt;We are going to have three screens:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The last screen in the image corresponds to the root path of the admin panel, which is only displayed to authenticated users.&lt;/li&gt;
&lt;li&gt;The first screen corresponds to &amp;#39;/sign-in&amp;#39;, displayed to any user trying to access &amp;#39;/&amp;#39; while not authenticated.&lt;/li&gt;
&lt;li&gt;The second screen corresponds to the success message showed to the user after requesting the magic link.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bear in mind that these screens might change while we are going through the tutorial, as I keep making changes and refactoring things. Without further ado, let&amp;#39;s do this!&lt;/p&gt;

&lt;h3&gt;Project setup&lt;/h3&gt;

&lt;p&gt;First things first. Let&amp;#39;s build a new Phoenix project with the following options:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix phx.new passwordless_auth --umbrella --no-ecto --no-brunch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--umbrella&lt;/code&gt; tells the mix task to generate an umbrella project instead of a regular one. As we don&amp;#39;t need to handle any database connections, we use the &lt;code&gt;--no-ecto&lt;/code&gt; option to prevent having &lt;code&gt;Ecto&lt;/code&gt; installed, and a default repository created. Finally, I&amp;#39;ve been having some issues related to assets building with Brunch, so let&amp;#39;s remove it with the &lt;code&gt;--no-brunch&lt;/code&gt; option for the moment as we are going to be using a customized Webpack build when we get to that point.&lt;/p&gt;

&lt;p&gt;After running the mix task, we can see that we have our new umbrella project with the two applications inside the &lt;code&gt;/apps&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;passwordless-auth
├── README.md
├── apps
│   ├── passwordless_auth
│   └── passwordless_auth_web
├── config
│   ├── config.exs
│   ├── dev.exs
│   ├── prod.exs
│   └── test.exs
├── mix.exs
└── mix.lock
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The authentication repository&lt;/h3&gt;

&lt;p&gt;We are not relying on a database to store admitted user emails and their corresponding authentication tokens, but we have to store them somewhere else. Erlang/Elixir offer a simple and straightforward solution for in-memory storage, the &lt;a href="https://hexdocs.pm/elixir/GenServer.html"&gt;GenServer&lt;/a&gt; behaviour, which seems to fit perfectly for our needs. Let&amp;#39;s go ahead and create the &lt;code&gt;Repo&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/repo.ex

defmodule PasswordlessAuth.Repo do
  use GenServer
  @name __MODULE__

  def start_link(opts) do
    opts = Keyword.put_new(opts, :name, @name)
    {:ok, emails} = Keyword.fetch(opts, :emails)

    GenServer.start_link(__MODULE__, emails, opts)
  end

  @impl true
  def init(emails) when is_list(emails) and length(emails) &amp;gt; 0 do
    state = Enum.reduce(emails, %{}, &amp;amp;Map.put(&amp;amp;2, &amp;amp;1, nil))

    {:ok, state}
  end

  def init(_), do: {:stop, &amp;quot;Invalid list of emails&amp;quot;}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;start_link&lt;/code&gt; function receives the options to spawn the &lt;code&gt;GenServer&lt;/code&gt; process of the repository. These options consist of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:name&lt;/code&gt; which is optional and used for registering the process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:emails&lt;/code&gt; which is mandatory, represents the list of admitted emails, and which we are using in the &lt;code&gt;init&lt;/code&gt; function to build the initial state of the process.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;init&lt;/code&gt; function receives a list of emails and creates a &lt;code&gt;Map&lt;/code&gt; where keys are the emails, and the values will store the authentication tokens, but at the moment we are setting them to &lt;code&gt;nil&lt;/code&gt;. On the contrary, if what receives is not a list, we want it to return &lt;code&gt;{:stop, &amp;quot;Invalid list of emails&amp;quot;}&lt;/code&gt;, exiting the process and not letting the application to start.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s create a test module to test this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/repo_test.exs

defmodule PasswordlessAuth.RepoTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  describe &amp;quot;.init/1&amp;quot; do
    test &amp;quot;returns error when emails are wrong&amp;quot; do
      Process.flag(:trap_exit, true)

      name = :repo_test_1
      Repo.start_link(name: name, emails: &amp;quot;&amp;quot;)

      assert_receive {:EXIT, _, &amp;quot;Invalid list of emails&amp;quot;}
    end

    test &amp;quot;starts the repo when emails is a list&amp;quot; do
      name = :repo_test_1
      assert {:ok, _pid} = Repo.start_link(name: name, emails: [&amp;quot;foo@email.com&amp;quot;])
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the test shows that everything works as we expect:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/repo_test.exs
==&amp;gt; passwordless_auth
..

Finished in 0.1 seconds
2 tests, 0 failures

Randomized with seed 407876
==&amp;gt; passwordless_auth_web
Test patterns did not match any file: test/passwordless_auth/repo_test.exs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool! Now we need to spawn the &lt;code&gt;Repo&lt;/code&gt; process once the application starts, so let&amp;#39;s add it to the main supervision tree:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/application.ex

defmodule PasswordlessAuth.Application do
  use Application

  def start(_type, _args) do
    import Supervisor.Spec, warn: false

    children = [
      worker(
        PasswordlessAuth.Repo,
        [[emails: emails()]]
      )
    ]

    Supervisor.start_link(children, strategy: :one_for_one, name: PasswordlessAuth.Supervisor)
  end

  defp emails, do: Application.get_env(:passwordless_auth, :repo)[:emails]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try to start the application at this point, it will not do it, due to we have not set the emails in the configuration yet, just like we have asserted in the previous test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix
Erlang/OTP 21 [RELEASE CANDIDATE 1] [erts-10.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

[info] Application passwordless_auth exited: PasswordlessAuth.Application.start(:normal, []) returned an error: shutdown: failed to start child: PasswordlessAuth.Repo
    ** (EXIT) &amp;quot;Invalid list of emails&amp;quot;
** (Mix) Could not start application passwordless_auth: PasswordlessAuth.Application.start(:normal, []) returned an error: shutdown: failed to start child: PasswordlessAuth.Repo
    ** (EXIT) &amp;quot;Invalid list of emails&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s add a list of emails to the configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/config/config.exs

use Mix.Config

config :passwordless_auth,
       :repo,
       emails: ~w(foo@email.com bar@email.com baz@email.com)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And try to start it again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix
Erlang/OTP 21 [RELEASE CANDIDATE 1] [erts-10.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

Interactive Elixir (1.6.5) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works as expected, so let&amp;#39;s move on to adding some logic to the &lt;code&gt;Repo&lt;/code&gt; module.&lt;/p&gt;

&lt;h3&gt;Repo logic&lt;/h3&gt;

&lt;p&gt;Before continuing, let&amp;#39;s start the application and check how the current state of the &lt;code&gt;Repo&lt;/code&gt; process looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix
...
iex(1)&amp;gt; :sys.get_state PasswordlessAuth.Repo
%{&amp;quot;bar@email.com&amp;quot; =&amp;gt; nil, &amp;quot;baz@email.com&amp;quot; =&amp;gt; nil, &amp;quot;foo@email.com&amp;quot; =&amp;gt; nil}
iex(2)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is the map where we are going to store the authentication tokens. Let&amp;#39;s continue by adding some functionality to validate if an email is valid, save and fetch token values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/repo.ex

defmodule PasswordlessAuth.Repo do
  #...

  def exists?(pid \\ @name, email),
    do: GenServer.call(pid, {:exists, email})

  def save(pid \\ @name, email, token),
    do: GenServer.call(pid, {:save, email, token})

  def fetch(pid \\ @name, email),
    do: GenServer.call(pid, {:fetch, email})

  # ...

  @impl true
  def handle_call({:exists, email}, _from, state) do
    {:reply, Map.has_key?(state, email), state}
  end

  def handle_call({:save, email, token}, _from, state) do
    if Map.has_key?(state, email) do
      {:reply, :ok, Map.put(state, email, token)}
    else
      {:reply, {:error, :invalid_email}, state}
    end
  end

  def handle_call({:fetch, email}, _from, state) do
    {:reply, Map.fetch(state, email), state}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exists?/2&lt;/code&gt; takes an email and checks if it belongs to the state&amp;#39;s keys.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save/3&lt;/code&gt; takes an email and a token, and tries to store it into the state, returning &lt;code&gt;:ok&lt;/code&gt; if the email exists or &lt;code&gt;{:error, :invalid_email}&lt;/code&gt; if it does not.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fetch/2&lt;/code&gt; takes an email and fetches the state for its token value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s add some tests for the new functionality:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/repo_test.exs

defmodule PasswordlessAuth.RepoTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  # ...

    describe &amp;quot;.exists?/2&amp;quot; do
    test &amp;quot;returns true when passed email is in the repo&amp;#39;s state&amp;quot; do
      name = :repo_test_2
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      assert Repo.exists?(name, email)
    end

    test &amp;quot;returns false when passed email no it repo&amp;#39;s state&amp;quot; do
      name = :repo_test_3
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      refute Repo.exists?(name, &amp;quot;not_found@test.com&amp;quot;)
    end
  end

  describe &amp;quot;.save/3&amp;quot; do
    test &amp;quot;returns :ok and sets token value in state when email exists&amp;quot; do
      name = :repo_test_4
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      assert :ok = Repo.save(name, email, token)
      assert %{&amp;quot;foo@test.com&amp;quot; =&amp;gt; ^token} = :sys.get_state(name)
    end

    test &amp;quot;returns {:error, :invalid_email} when email does not exist&amp;quot; do
      name = :repo_test_5
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      assert {:error, :invalid_email} = Repo.save(name, &amp;quot;bar@test.com&amp;quot;, token)
    end
  end

  describe &amp;quot;.fetch/2&amp;quot; do
    test &amp;quot;returns {:ok, token} for passed email&amp;quot; do
      name = :repo_test_6
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert {:ok, ^token} = Repo.fetch(name, email)
    end

    test &amp;quot;returns :error when token not found&amp;quot; do
      name = :repo_test_7
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert :error = Repo.fetch(name, &amp;quot;not_found@test.com&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And check that they all pass:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/repo_test.exs
==&amp;gt; passwordless_auth
........

Finished in 0.1 seconds
8 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Token logic&lt;/h3&gt;

&lt;p&gt;It looks like we have the basic stuff covered, for now, so let&amp;#39;s create the &lt;code&gt;Token&lt;/code&gt; module to handle token generation and verification. Phoenix has a convenient module for these purposes, &lt;a href="https://hexdocs.pm/phoenix/Phoenix.Token.html"&gt;Phoenix.Token&lt;/a&gt;, and we can build our module wrapping it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/token.ex

defmodule PasswordlessAuth.Token do
  alias Phoenix.Token, as: PhoenixToken

  @salt &amp;quot;token salt&amp;quot;
  @max_age :timer.minutes(5) / 1000
  @secret Application.get_env(:passwordless_auth, __MODULE__)[:secret_key_base]

  def generate(data) when data in [nil, &amp;quot;&amp;quot;], do: {:error, :invalid}

  def generate(data) do
    {:ok, PhoenixToken.sign(@secret, @salt, data)}
  end

  def verify(token, data, max_age \\ @max_age) do
    case PhoenixToken.verify(
           @secret,
           @salt,
           token,
           max_age: max_age
         ) do
      {:ok, ^data} -&amp;gt;
        {:ok, data}

      {:ok, _other} -&amp;gt;
        {:error, :invalid}

      {:error, reason} -&amp;gt;
        {:error, reason}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generate/1&lt;/code&gt; takes some &lt;code&gt;data&lt;/code&gt; and returns &lt;code&gt;{:ok, token}&lt;/code&gt; with the token generated using &lt;code&gt;Phoenix.Token.sign/4&lt;/code&gt; unless the &lt;code&gt;data&lt;/code&gt; it is receiving is either &lt;code&gt;nil&lt;/code&gt; or and empty string, in which case it returns the corresponding &lt;code&gt;{:error, :invalid}&lt;/code&gt; tuple.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verify/3&lt;/code&gt; takes a &lt;code&gt;token&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and a &lt;code&gt;max_age&lt;/code&gt; and uses &lt;code&gt;Phoenix.Token.verify/4&lt;/code&gt; to check id the &lt;code&gt;token&lt;/code&gt; corresponds to &lt;code&gt;data&lt;/code&gt;, and it has not expired yet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s add a test module to check that everything works as it should:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/token_test.exs

defmodule PasswordlessAuth.TokenTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Token

  describe &amp;quot;.generate/1&amp;quot; do
    test &amp;quot;returns {:error, :invalid} when value is nil&amp;quot; do
      assert {:error, :invalid} = Token.generate(nil)
      assert {:error, :invalid} = Token.generate(&amp;quot;&amp;quot;)
    end

    test &amp;quot;returns {:ok, token}&amp;quot; do
      assert {:ok, _token} = Token.generate(&amp;quot;foo&amp;quot;)
    end
  end

  describe &amp;quot;.verify/3&amp;quot; do
    test &amp;quot;returns {:ok, data} when token is valid&amp;quot; do
      {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)

      assert {:ok, &amp;quot;foo&amp;quot;} = Token.verify(token, &amp;quot;foo&amp;quot;)
    end

    test &amp;quot;returns {:error, :invalid} when token is not valid&amp;quot; do
      {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)

      assert {:error, :invalid} = Token.verify(token, &amp;quot;bar&amp;quot;)
    end

    test &amp;quot;returns {:error, reason} when token expires&amp;quot; do
      {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)

      Process.sleep(150)
      assert {:error, :expired} = Token.verify(token, &amp;quot;foo&amp;quot;, 0.1)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run the tests and see the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix test test/passwordless_auth/token_test.exs
==&amp;gt; passwordless_auth


  1) test .verify/3 returns {:error, reason} when token expires (PasswordlessAuth.TokenTest)
     test/passwordless_auth/token_test.exs:30
     ** (UndefinedFunctionError) function nil.config/1 is undefined or private
     code: {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)
     stacktrace:
       nil.config(:secret_key_base)
       (phoenix) lib/phoenix/token.ex:202: Phoenix.Token.get_endpoint_key_base/1
       (phoenix) lib/phoenix/token.ex:111: Phoenix.Token.sign/4
       (passwordless_auth) lib/passwordless_auth/token.ex:25: PasswordlessAuth.Token.generate/1
       test/passwordless_auth/token_test.exs:31: (test)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like we forgot adding the &lt;code&gt;:secret&lt;/code&gt; value in the configuration, so let&amp;#39;s go ahead and set it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/config/config.exs

# ...

config :passwordless_auth,
       PasswordlessAuth.Token,
       secret_key_base: &amp;quot;your_secret_key_base&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To generate the &lt;code&gt;secret_key_base&lt;/code&gt; value, you can use the &lt;code&gt;phx.gen.secret&lt;/code&gt; mix task. After setting the value and running once more the tests, everything should be working fine now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/token_test.exs
==&amp;gt; passwordless_auth
.....

Finished in 0.2 seconds
5 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Providing and verifying tokens&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s edit the main &lt;code&gt;PasswordlessAuth&lt;/code&gt; module and add a new function to provide new tokens by using what we have done so far:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth.ex

defmodule PasswordlessAuth do
  alias PasswordlessAuth.{Repo, Token}

  def provide_token_for(repo \\ Repo, email)
  def provide_token_for(_, email) when email in [nil, &amp;quot;&amp;quot;], do: {:error, :invalid_email}

  def provide_token_for(repo, email) do
    with true &amp;lt;- Repo.exists?(repo, email),
         {:ok, token} &amp;lt;- Token.generate(email),
         :ok &amp;lt;- Repo.save(repo, email, token) do
      {:ok, token}
    else
      false -&amp;gt;
        {:error, :not_found}

      other -&amp;gt;
        {:error, :internal_error, other}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before moving on to adding the verification logic, let&amp;#39;s stop for a second and think about what we need. The function will receive a token, and we want to check not only it corresponds to any of the stored ones in the &lt;code&gt;Repo&lt;/code&gt;, but also that the token&amp;#39;s signed value corresponds to the email key under which is stored. Therefore, let&amp;#39;s add a new function to return an email by its token from the &lt;code&gt;Repo&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/repo.ex

defmodule PasswordlessAuth.Repo do
  # ...

  def find_by_token(pid \\ @name, token),
    do: GenServer.call(pid, {:find_by_token, token})

  # ...

  def handle_call({:find_by_token, token}, _from, state) do
    {:reply, Enum.find(state, &amp;amp;(elem(&amp;amp;1, 1) == token)), state}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find_by_token/2&lt;/code&gt; checks if there is an element it the state with the value, returning the tuple of &lt;code&gt;{email, token}&lt;/code&gt; or nil if not found. This might not be the most performant way of doing it, but as we have already agreed on that the repo is only going to store a few emails, let&amp;#39;s keep it like this for simplicity&amp;#39;s sake. Let&amp;#39;s test it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/repo_test.exs

defmodule PasswordlessAuth.RepoTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  # ...

  describe &amp;quot;.find_by_token/2&amp;quot; do
    test &amp;quot;returns {email, token} when token exists&amp;quot; do
      name = :repo_test_8
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert {^email, ^token} = Repo.find_by_token(name, token)
    end

    test &amp;quot;returns nil when token not found&amp;quot; do
      name = :repo_test_9
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert nil == Repo.find_by_token(name, &amp;quot;other-token&amp;quot;)
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/repo_test.exs
==&amp;gt; passwordless_auth
..........

Finished in 0.1 seconds
10 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to continue where we left it, so let&amp;#39;s go ahead and add the verification functionality to the &lt;code&gt;PasswordlessAuth&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth.ex

defmodule PasswordlessAuth do
  alias PasswordlessAuth.{Repo, Token}

  # ...

  def verify_token(repo \\ Repo, token) do
    repo
    |&amp;gt; Repo.find_by_token(token)
    |&amp;gt; do_verify()
  end

  # ...

  defp do_verify(nil), do: {:error, :not_found}
  defp do_verify({email, token}), do: Token.verify(token, email)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we&amp;#39;ve been doing so far, let&amp;#39;s create a test module for the &lt;code&gt;PasswordlessAuth&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth_test.exs

defmodule PasswordlessAuthTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  describe &amp;quot;provide_token_for/2&amp;quot; do
    test &amp;quot;returns error when email is blank&amp;quot; do
      assert {:error, :invalid_email} = PasswordlessAuth.provide_token_for(nil)
      assert {:error, :invalid_email} = PasswordlessAuth.provide_token_for(&amp;quot;&amp;quot;)
    end

    test &amp;quot;returns error when email does not exist&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_1&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])

      assert {:error, :not_found} =
               PasswordlessAuth.provide_token_for(repo, &amp;quot;not-found-email@test.com&amp;quot;)
    end

    test &amp;quot;returns token when valid email&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_2&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])

      assert {:ok, token} = PasswordlessAuth.provide_token_for(repo, email)
      assert byte_size(token) &amp;gt; 0
    end
  end

  describe &amp;quot;verify_token/2&amp;quot; do
    test &amp;quot;returns error when token not found&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_3&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])
      {:ok, _token} = PasswordlessAuth.provide_token_for(repo, email)

      assert {:error, :not_found} = PasswordlessAuth.verify_token(repo, &amp;quot;not-found-token&amp;quot;)
    end

    test &amp;quot;returns value when token valid&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_4&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])
      {:ok, token} = PasswordlessAuth.provide_token_for(repo, email)

      assert {:ok, ^email} = PasswordlessAuth.verify_token(repo, token)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally run it to confirm that everything is working as it should:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth_test.exs
==&amp;gt; passwordless_auth
.....

Finished in 0.07 seconds
5 tests, 0 failures

Randomized with seed 291795
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yay! Let&amp;#39;s leave it here for now. In the next part of the series, we will take care of sending the authentication link via email to the user, and use this link to verify the token and authenticate a Phoenix Socket connection. In the meantime, don&amp;#39;t forget to check out the source code with the final result of our small experiment:&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix &amp; Elm landing page (pt.3)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"/>
    <id>http://codeloveandboards.com/blog/2018/01/06/phoenix-elm-landing-page-pt-3/</id>
    <published>2018-01-07T07:06:00Z</published>
    <updated>2018-01-14T08:27:17+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix &amp; Elm landing page&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"&gt;Bootstrapping the project and the basic API functionality to save our first leads&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/"&gt;Building the landing page UI and the basic Elm subscription form&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"&gt;Adding Google reCAPTCHA support to avoid spambots&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/&amp;amp;lt;Paste"&gt;previous part&lt;/a&gt; of the series, we created the landing page main
layout and implemented the Elm subscription form, which lets visitors
subscribe, saving their name and email in the leads database table. We do
not want spambots to subscribe, therefore, in this part we are going
to add a protective layer to the subscription process using &lt;a href="https://developers.google.com/recaptcha/"&gt;Google&amp;#39;s
reCAPTCHA&lt;/a&gt;, which consists of two different steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adding the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; widget to the Elm subscription form, and sending
the user&amp;#39;s response along with the name and email.&lt;/li&gt;
&lt;li&gt;Verifying in the server-side the user&amp;#39;s response against &lt;strong&gt;Google&amp;#39;s RECAPTCHA API&lt;/strong&gt; to verify whether is valid or not&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Without further ado, let&amp;#39;s do this!&lt;/p&gt;

&lt;h3&gt;Adding the reCAPTCHA widget to the form&lt;/h3&gt;

&lt;p&gt;First of all, we need to head to &lt;a href="https://www.google.com/recaptcha/admin"&gt;Google&amp;#39;s reCAPTCHA admin
site&lt;/a&gt; and register our website,
using localhost as the domain, to get the necessary keys that we need.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/recaptcha-admin.jpg"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Next, we have to add &lt;strong&gt;Google&amp;#39;s reCAPTCHA&lt;/strong&gt; script in the main template, so
let&amp;#39;s edit it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/templates/layout/app.html.eex

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;!--... --&amp;gt;

  &amp;lt;body class=&amp;quot;landing-page&amp;quot;&amp;gt;
    &amp;lt;!--... --&amp;gt;

    &amp;lt;script src=&amp;quot;https://www.google.com/recaptcha/api.js?onload=onloadCallback&amp;amp;render=explicit&amp;quot; async defer&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are not only adding the script but passing the &lt;code&gt;onload&lt;/code&gt; and &lt;code&gt;render&lt;/code&gt;
parameters to render the widget explicitly and to call the
&lt;code&gt;onloadCallback&lt;/code&gt; function once the script gets loaded. The plan is to
render the widget inside the Elm form, and for that we need the script to
be loaded before rendering it, so let&amp;#39;s edit the main &lt;code&gt;app.js&lt;/code&gt; file to
achieve this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/js/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    const app = Elm.Main.embed(formContainer);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the &lt;strong&gt;Elm&lt;/strong&gt; program is embedded once the script is ready, we have to
render the widget somehow using its internal API. Before continuing any
further, let&amp;#39;s update the &lt;code&gt;View&lt;/code&gt; module and add a new div where we want to
render the widget:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;# assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
        -- ...

        , Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.div
                        [ Html.id &amp;quot;recaptcha&amp;quot; ]
                        []
                , validationErrorView &amp;quot;recaptcha_token&amp;quot; validationErrors
                ]

        -- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How can we tell the external &lt;strong&gt;reCAPTCHA&lt;/strong&gt; script that we want it to
render the widget inside the div with &lt;code&gt;recaptcha&lt;/code&gt; id? In Elm, the proper way
of communicating with external &lt;strong&gt;JavaScript&lt;/strong&gt; is by using &lt;strong&gt;ports&lt;/strong&gt;, so let&amp;#39;s go
ahead and create a new module with a port to initialize the widget:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Ports.elm

port module Ports exposing (..)

-- OUT PORTS


port initRecaptcha : String -&amp;gt; Cmd msg

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;initRecaptcha&lt;/code&gt; port function receives a string which is the id of the
container where we want to render the widget and returns a command.
Therefore, we can use it in the main &lt;code&gt;init&lt;/code&gt; function, and the port will get
called once the program starts for the first time:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

module Main exposing (main)

import Ports
-- ...

init : ( Model, Cmd Msg )
init =
    initialModel ! [ Ports.initRecaptcha &amp;quot;recaptcha&amp;quot; ]

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can go back to the &lt;code&gt;app.js&lt;/code&gt; script and subscribe to the
&lt;code&gt;initRecaptcha&lt;/code&gt; port:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/javascript/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    const app = Elm.Main.embed(formContainer);
    let recaptcha;

    app.ports.initRecaptcha.subscribe(id =&amp;gt; {
      window.requestAnimationFrame(() =&amp;gt; {
        recaptcha = grecaptcha.render(id, {
          sitekey: &amp;#39;YOUR_SITE_KEY&amp;#39;,
        });
      });
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;app.ports&lt;/code&gt; contains all the ports from the Elm program. By subscribing to
any of them, we are making the passed function to get called anytime
a port gets triggered by the Elm runtime. In our case, it is using
&lt;strong&gt;Google&amp;#39;s reCAPTCHA&lt;/strong&gt; script to render the widget inside the specified id,
using the &lt;code&gt;sitekey&lt;/code&gt; we created previously from the admin site. Also, note
that we are wrapping the render function inside
&lt;code&gt;window.requestAnimationFrame&lt;/code&gt;, forcing the script to initialize the widget
immediately after the form renders for the first time. Not doing it like
so may create race conditions between Elm programs and external JavaScript
components, so don&amp;#39;t forget using it. Let&amp;#39;s jump to the browser and see
the result:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/landing-page.jpg" alt="Landing
page" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;The widget renders as expected, yay!&lt;/p&gt;

&lt;h3&gt;Setting the reCAPTCHA token&lt;/h3&gt;

&lt;p&gt;When a visitor clicks on the widget, it generates a token that we need to
validate against Google reCAPTCHA API, so we need to send it to the server
along with the &lt;code&gt;full_name&lt;/code&gt; and the &lt;code&gt;email&lt;/code&gt;. Before this, let&amp;#39;s edit the model
module to add a new key in the &lt;code&gt;SubscribeForm&lt;/code&gt; so we can store the token:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Model.elm

module Model exposing (..)


type alias FormFields =
    { fullName : String
    , email : String
    , recaptchaToken : Maybe String
    }

-- ...

emptyFormFields : FormFields
emptyFormFields =
    { fullName = &amp;quot;&amp;quot;
    , email = &amp;quot;&amp;quot;
    , recaptchaToken = Nothing
    }

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How can we store in it the token received from the external &lt;strong&gt;reCAPTCHA&lt;/strong&gt;
widget? As sending messages to external &lt;strong&gt;JavaScript&lt;/strong&gt;, &lt;strong&gt;Elm&lt;/strong&gt; can also receive
messages from the outer world by subscribing to incoming ports. Knowing
this, let&amp;#39;s create a new port which receives the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; token from the
widget:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Ports.elm

port module Ports exposing (..)

-- ...


-- IN PORTS


port setRecaptchaToken : (String -&amp;gt; msg) -&amp;gt; Sub msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;strong&gt;Elm&lt;/strong&gt; receives the &lt;code&gt;setRecaptchaToken&lt;/code&gt; port, we want it to set the token
in the model, and for that, we need to create a new message type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Messages.elm

type Msg
    = HandleFullNameInput String
    -- ...
    | SetRecaptchaToken String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to handle this message in the &lt;code&gt;update&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    -- ...

    SetRecaptchaToken token -&amp;gt;
        { model | subscribeForm = Editing { formFields | recaptchaToken = Just token } } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned before, &lt;strong&gt;Elm&lt;/strong&gt; needs to subscribe to incoming ports, so let&amp;#39;s go
ahead and define the &lt;code&gt;subscriptions&lt;/code&gt; function to put all the pieces together:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

-- ...

subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Ports.setRecaptchaToken SetRecaptchaToken
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing left is sending the token from &lt;strong&gt;JavaScript&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/javascript/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  // ...

    app.ports.initRecaptcha.subscribe(id =&amp;gt; {
      window.requestAnimationFrame(() =&amp;gt; {
        recaptcha = grecaptcha.render(id, {
          sitekey: &amp;#39;YOUR_SITE_KEY&amp;#39;,
          callback: app.ports.setRecaptchaToken.send, // &amp;lt;- CHECK THIS OUT
        });
      });
    });

  // ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;strong&gt;reCAPTCHA&lt;/strong&gt; widget has a callback option which is a function that gets
called after checking the visitor&amp;#39;s response and which contains the token,
and which we can use to send the &lt;code&gt;setRecaptchaToken&lt;/code&gt; port message to &lt;strong&gt;Elm&lt;/strong&gt;.
Let&amp;#39;s check that everything is working as expected:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/settoken-port.gif"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Using &lt;strong&gt;Elm&amp;#39;s debugger&lt;/strong&gt;, we can verify that when we click on the &lt;strong&gt;reCAPTCHA
widget&lt;/strong&gt;, ELm handles the &lt;code&gt;SetRecaptchaToken&lt;/code&gt; message, setting the
&lt;code&gt;recaptchaToken&lt;/code&gt; received through the &lt;code&gt;setRecaptchaToken&lt;/code&gt; port in the model.
The only thing left, for now, is preventing sending the form while the
&lt;code&gt;recaptchaToken&lt;/code&gt; is not set, so let&amp;#39;s fix this in the view module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
    let
        { fullName, email, recaptchaToken } =
            extractFormFields subscribeForm


        -- ...

        buttonDisabled =
            fullName
                == &amp;quot;&amp;quot;
                || email
                == &amp;quot;&amp;quot;
                || recaptchaToken
                == Nothing
                || recaptchaToken
                == Just &amp;quot;&amp;quot;
                || saving
                || invalid

        -- ...
    in
        -- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we have to include the &lt;code&gt;recaptchaToken&lt;/code&gt; value to the HTTP request body:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Commands.elm

module Commands exposing (subscribe)

-- ...

encodeModel : FormFields -&amp;gt; JD.Value
encodeModel { fullName, email, recaptchaToken } =
    JE.object
        [ ( &amp;quot;lead&amp;quot;
          , JE.object
                -- ...

                , ( &amp;quot;recaptcha_token&amp;quot;, JE.string &amp;quot;foo&amp;quot; )
                ]
          )
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Server-side reCAPTCHA token validation&lt;/h3&gt;

&lt;p&gt;Now that the form is sending the token, we can implement the second step
of the process, which is validating it against &lt;strong&gt;Google&amp;#39;s API&lt;/strong&gt;. Although we
are somehow forcing the &lt;code&gt;recaptcha_token&lt;/code&gt; value to have a non-empty value,
let&amp;#39;s add a validation check on the backend, so no leads with empty tokens
can get saved. As we only need to validate it, and not save it, we can add
a virtual field to the &lt;code&gt;Lead&lt;/code&gt; schema:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/lead.ex

defmodule LandingPage.Marketing.Lead do
  use Ecto.Schema
  import Ecto.Changeset
  alias LandingPage.Marketing.Lead

  @derive {Poison.Encoder, only: [:full_name, :email]}

  schema &amp;quot;leads&amp;quot; do
    field(:email, :string)
    field(:full_name, :string)

    field(:recaptcha_token, :string, virtual: true)

    timestamps()
  end

  @fields ~w(full_name email recaptcha_token)a

  @doc false
  def changeset(%Lead{} = lead, attrs) do
    lead
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@fields)
    |&amp;gt; unique_constraint(:email)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This change breaks the tests, so let&amp;#39;s go ahead and fix them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page/marketing/marketing_test.exs

defmodule LandingPage.MarketingTest do
  use LandingPage.DataCase

  # ...

  @valid_attrs %{
    &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;some email&amp;quot;,
    &amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;some full_name&amp;quot;,
    &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;foo&amp;quot;
  }
  @invalid_attrs %{email: nil, full_name: nil, recaptcha_token: nil}

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page_web/controllers/v1/lead_controller_test.exs

defmodule LandingPageWeb.V1.LeadControllerTest do
  use LandingPageWeb.ConnCase

  # ...


  describe &amp;quot;POST /api/v1/leads&amp;quot; do
    test &amp;quot;returns error response with invalid params&amp;quot;, %{conn: conn} do
      conn = post(conn, lead_path(conn, :create), %{&amp;quot;lead&amp;quot; =&amp;gt; %{}})

      assert json_response(conn, 422) == %{
               &amp;quot;full_name&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;],
               &amp;quot;email&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;],
               &amp;quot;recaptcha_token&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;]
             }
    end

    test &amp;quot;returns success response with valid params&amp;quot;, %{conn: conn} do
      params = %{
        &amp;quot;lead&amp;quot; =&amp;gt; %{&amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;, &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;, &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;foo&amp;quot;}
      }

      conn = post(conn, lead_path(conn, :create), params)
      assert json_response(conn, 200) == %{&amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;, &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we now run the test suite, we can see that every test is passing now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;➜ mix test
...........

Finished in 0.1 seconds
11 tests, 0 failures

Randomized with seed 66361
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check whether Google has verified the user, we have to send an HTTP
request to &lt;code&gt;https://www.google.com/recaptcha/api/siteverify&lt;/code&gt; with the
token. For that we first need to install an HTTP client like
&lt;a href="https://github.com/edgurgel/httpoison"&gt;HTTPoison&lt;/a&gt;, so let&amp;#39; go ahead and add
it to the dependencies list:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# mix.exs

# ...

  defp deps do
    [
      # ...
      {:httpoison, &amp;quot;~&amp;gt; 0.13&amp;quot;}
    ]
  end

# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running the necessary &lt;code&gt;mix deps.get&lt;/code&gt; task, we are ready to implement
our &lt;strong&gt;Google&amp;#39;s HTTP client&lt;/strong&gt;, so let&amp;#39;s create the following module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/clients/google/recaptcha_http.ex

defmodule LandingPage.Clients.GoogleRecaptchaHttp do
  use HTTPoison.Base

  @secret_key Application.get_env(:landing_page, :google_recaptcha)[:secret_key]

  def verify(token) do
    params = %{
      secret: @secret_key,
      response: token
    }

    &amp;quot;/siteverify&amp;quot;
    |&amp;gt; get!([], params: params)
    |&amp;gt; case do
         %{status_code: 200, body: body} -&amp;gt;
           {:ok, body}

         response -&amp;gt;
           {:error, response}
       end
  end

  def process_url(url) do
    &amp;quot;https://www.google.com/recaptcha/api&amp;quot; &amp;lt;&amp;gt; url
  end

  def process_response_body(body), do: Poison.decode!(body, keys: :atoms)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;HTTPoison.Base&lt;/code&gt; gives us mostly all the functionality that we need
out of the box. The &lt;code&gt;verify/1&lt;/code&gt; function receives a token and sends an HTTP
request against the specified URL, with the &lt;code&gt;secret_key&lt;/code&gt; and the user&amp;#39;s
token. Depending on the result, it returns a tuple with the &lt;code&gt;:ok&lt;/code&gt; atom and
the processed body using the &lt;code&gt;process_response_body/1&lt;/code&gt; function, or one
containing &lt;code&gt;:error&lt;/code&gt; and the response. To finish the client, we need to set
the value of &lt;code&gt;@secret_key&lt;/code&gt; in the application&amp;#39;s config:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# config/config.exs

# ...

config :landing_page,
  google_recaptcha: [
    secret_key: &amp;quot;SET_HERE_YOUR_SECRET_KEY&amp;quot;
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jumping back to the &lt;a href="https://developers.google.com/recaptcha/docs/verify"&gt;reCAPTCHA
docs&lt;/a&gt;, we can see that
the response body looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
  &amp;quot;success&amp;quot;: true|false,
  &amp;quot;challenge_ts&amp;quot;: timestamp,  // timestamp of the challenge load (ISO format yyyy-MM-dd&amp;#39;T&amp;#39;HH:mm:ssZZ)
  &amp;quot;hostname&amp;quot;: string,         // the hostname of the site where the reCAPTCHA was solved
  &amp;quot;error-codes&amp;quot;: [...]        // optional
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having this in mind, we can go ahead and create a new function in the
&lt;code&gt;Marketing&lt;/code&gt; module to subscribe and create new leads:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/marketing.ex

alias LandingPage.Clients.GoogleRecaptchaHttp
# ...

defmodule LandingPage.Marketing do
  # ...

  def subscribe(lead_params) do
    token = Map.get(lead_params, &amp;quot;recaptcha_token&amp;quot;)

    with %Ecto.Changeset{valid?: true} = changeset &amp;lt;- Lead.changeset(%Lead{}, lead_params),
         {:ok, %{success: true}} &amp;lt;- GoogleRecaptchaHttp.verify(token),
         {:ok, lead} &amp;lt;- Repo.insert(changeset) do
      {:ok, lead}
    else
      {:ok, %{success: false}} -&amp;gt;
        {:error, :invalid_recaptcha_token}

      {:error, response} -&amp;gt;
        {:error, response}

      other -&amp;gt;
        {:error, other}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if everything goes as expected, &lt;code&gt;subscribe/1&lt;/code&gt; receives the
&lt;code&gt;lead_params&lt;/code&gt; and validates them against a lead changeset, verifying the
token using the client, inserting the lead and returning a tuple
containing it. On the other hand, if the token validation returns &lt;code&gt;{:ok,
    %{success: false}}&lt;/code&gt;, which means that is not valid, it returns a &lt;code&gt;{:error,
:invalid_recaptcha_token}&lt;/code&gt; tuple.&lt;/p&gt;

&lt;p&gt;Let&amp;#39; write some tests to check that everything is currently behaving as it
should:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page/marketing/marketing_test.exs

defmodule LandingPage.MarketingTest do
  use LandingPage.DataCase

  # ...

  describe &amp;quot;leads&amp;quot; do
    # ...

    test &amp;quot;subscribe/1 with valid data and token creates a lead&amp;quot; do
      assert {:ok, %Lead{}} = Marketing.subscribe(@valid_attrs)
    end

    test &amp;quot;subscribe/1 with invalid token returns error changeset&amp;quot; do
      params = %{@valid_attrs | &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;invalid&amp;quot;}
      assert {:error, :invalid_recaptcha_token} = Marketing.subscribe(params)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before running the test, let&amp;#39;s think about our current solution for
a second. Every time that we run the tests, the &lt;code&gt;GoogleRecaptchaHttp&lt;/code&gt; client
is going to be sending requests, slowing down the test suite, and we do
not really want that. Moreover, knowing beforehand what the Google&amp;#39;s API
returns, we no longer need to send a real request to test what we need.
There are many ways of implementing a workaround for this, but one of my
favorite ones is creating a mock client, which returns fake responses,
based on the API specification, and use either of the clients depending on
the environment. Let&amp;#39;s stick to this approach, and create a new mock
client:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/clients/google/recaptcha_mock.ex

defmodule LandingPage.Clients.GoogleRecaptchaMock do
  def verify(&amp;quot;invalid&amp;quot;), do: {:ok, %{success: false}}
  def verify(_token), do: {:ok, %{success: true}}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use a specific client depending on the current environment that the
application is running in, we can just set the module we want to use in
that environment configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# config/config.exs

# ...

config :landing_page,
  google_recaptcha: [
    secret_key: &amp;quot;SET_HERE_YOUR_SECRET_KEY&amp;quot;,
    client: LandingPage.Clients.GoogleRecaptchaHttp
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# config/test.exs

# ...

config :landing_page,
  google_recaptcha: [
    client: LandingPage.Clients.GoogleRecaptchaMock
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;#39;s refactor the &lt;code&gt;Marketing&lt;/code&gt; module to use the client set in the
environment:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/marketing.ex

alias LandingPage.Clients.GoogleRecaptchaHttp
# ...

@google_recaptcha_client Application.get_env(:landing_page, :google_recaptcha)[:client]

defmodule LandingPage.Marketing do
  # ...

  def subscribe(lead_params) do
    token = Map.get(lead_params, &amp;quot;recaptcha_token&amp;quot;)

    with %Ecto.Changeset{valid?: true} = changeset &amp;lt;- Lead.changeset(%Lead{}, lead_params),
         {:ok, %{success: true}} &amp;lt;- @google_recaptcha_client.verify(token),
         {:ok, lead} &amp;lt;- Repo.insert(changeset) do
      {:ok, lead}
    else
      # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@google_recaptcha_client&lt;/code&gt; contains the client module, which in the test
environment is the mock client, so we can non safely run the tests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜ mix test test/landing_page/marketing/marketing_test.exs
....

Finished in 0.1 seconds
4 tests, 0 failures

Randomized with seed 506123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And they all pass, yay!&lt;/p&gt;

&lt;p&gt;We are still missing an important part though. We need to update the
&lt;code&gt;LeadController&lt;/code&gt; module to use the new &lt;code&gt;subscribe&lt;/code&gt; function we just
created:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/v1/lead_controller.ex

defmodule LandingPageWeb.V1.LeadController do
  use LandingPageWeb, :controller

  alias LandingPage.Marketing

  plug(:scrub_params, &amp;quot;lead&amp;quot;)

  def create(conn, %{&amp;quot;lead&amp;quot; =&amp;gt; params}) do
    with {:ok, lead} &amp;lt;- Marketing.subscribe(params) do
      json(conn, lead)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to handle in the &lt;code&gt;FallbackController&lt;/code&gt; module the &lt;code&gt;{:error,
:invalid_recaptcha_token}&lt;/code&gt; response resulting from an invalid token check:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/fallback_controller.ex

defmodule LandingPageWeb.FallbackController do
  use LandingPageWeb, :controller

  # ...

  def call(conn, {:error, :invalid_recaptcha_token}) do
    conn
    |&amp;gt; put_status(:unprocessable_entity)
    |&amp;gt; render(LandingPageWeb.ErrorView, &amp;quot;invalid_recaptcha_token.json&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;#39;s edit the &lt;code&gt;ErrorView&lt;/code&gt; module in order to add the
necessary render function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/views/error_view.ex

defmodule LandingPageWeb.ErrorView do
  # ...

  def render(&amp;quot;invalid_recaptcha_token.json&amp;quot;, _) do
    %{recaptcha_token: [&amp;quot;the response is invalid&amp;quot;]}
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following the same convention for validation errors, we return a map with
the error we want to render below the &lt;strong&gt;reCAPTCHA widget&lt;/strong&gt;. Let&amp;#39;s add a test
to check that it works:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page_web/controllers/v1/lead_controller_test.exs

defmodule LandingPageWeb.V1.LeadControllerTest do
  use LandingPageWeb.ConnCase

  describe &amp;quot;POST /api/v1/leads&amp;quot; do
    # ...

    test &amp;quot;returns error response with invalid token&amp;quot;, %{conn: conn} do
      params = %{
        &amp;quot;lead&amp;quot; =&amp;gt; %{
          &amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;,
          &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;,
          &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;invalid&amp;quot;
        }
      }

      conn = post(conn, lead_path(conn, :create), params)

      assert json_response(conn, 422) == %{
               &amp;quot;recaptcha_token&amp;quot; =&amp;gt; [&amp;quot;the response is invalid&amp;quot;]
             }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜ mix test  test/landing_page_web/controllers/v1/lead_controller_test.exs
...

Finished in 0.1 seconds
3 tests, 0 failures

Randomized with seed 723440
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test it in the browser, we can edit the Elm &lt;code&gt;Commands&lt;/code&gt; module and
simply set a hardcoded value for the &lt;code&gt;recaptcha_token&lt;/code&gt; parameter:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/token-error.gif"
alt="Token error" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;However, wait a minute. If the token is invalid, there is no current way
of resetting the widget again, so the user is not able to resubmit the
form. Let&amp;#39;s fix this.&lt;/p&gt;

&lt;h3&gt;Resetting the token on error&lt;/h3&gt;

&lt;p&gt;Luckily for us, the widget has a &lt;code&gt;reset&lt;/code&gt; function and we
can call it through an Elm port. Let&amp;#39;s edit the &lt;code&gt;Ports&lt;/code&gt; module and add
a new outgoing port:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Ports.elm

port module Ports exposing (..)

-- OUT PORTS


-- ...


port resetRecaptcha : () -&amp;gt; Cmd msg


-- ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to subscribe to the new port and call the widget&amp;#39;s &lt;code&gt;reset&lt;/code&gt;
function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/javascript/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    const app = Elm.Main.embed(formContainer);
    let recaptcha;

    // ...

    app.ports.resetRecaptcha.subscribe(() =&amp;gt; {
      grecaptcha.reset(recaptcha);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we have to trigger the &lt;code&gt;resetRecaptcha&lt;/code&gt; wherever we need, so
let&amp;#39;s do it on any response error that we receive from the server:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    -- ...

      SubscribeResponse (Err (BadStatus response)) -&amp;gt;
          case Decode.decodeString validationErrorsDecoder response.body of
              Ok validationErrors -&amp;gt;
                  { model | subscribeForm = Invalid { formFields | recaptchaToken = Nothing } validationErrors } ! [ Ports.resetRecaptcha () ]

              Err error -&amp;gt;
                  { model | subscribeForm = Errored { formFields | recaptchaToken = Nothing } &amp;quot;Oops! Something went wrong!&amp;quot; } ! [ Ports.resetRecaptcha () ]

      SubscribeResponse (Err error) -&amp;gt;
          { model | subscribeForm = Errored { formFields | recaptchaToken = Nothing } &amp;quot;Oops! Something went wrong!&amp;quot; } ! [ Ports.resetRecaptcha () ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s jump back to the browser and check that it actually is working fine:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/token-reset.gif"
alt="Token reset" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;The widget is reset as expected, allowing the user to click it again.
Let&amp;#39;s remove the hardcoded value from the &lt;code&gt;recaptcha_token&lt;/code&gt; on the post
parameters and test that everything works fine and the lead subscribes
successfully:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/final-result.gif"
alt="Final result" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;And there we go. Our very basic landing page is ready for deployment and
subscribing new leads, without making us worry about spambots. I hope you
have enjoyed these series as much as I have enjoyed doing them. See you
next time, and don&amp;#39;t forget to check the code from this part
&lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-3"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
</feed>

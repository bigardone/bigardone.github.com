<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code, Love &amp; Boards</title>
  <subtitle>A blog about coding web apps, loving life and board sports</subtitle>
  <id>http://codeloveandboards.com/blog</id>
  <link href="http://codeloveandboards.com/blog"/>
  <link href="http://codeloveandboards.com/feed.xml" rel="self"/>
  <updated>2017-12-24T07:44:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Phoenix &amp; Elm landing page (pt.2)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/12/23/phoenix-elm-landing-page-pt-2/"/>
    <id>http://codeloveandboards.com/blog/2017/12/23/phoenix-elm-landing-page-pt-2/</id>
    <published>2017-12-24T07:44:00Z</published>
    <updated>2018-01-07T19:06:12+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix &amp; Elm landing page&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"&gt;Bootstrapping the project and the basic API functionality to save our first leads&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/24/phoenix-elm-landing-page-pt-2/"&gt;Building the landing page UI and the basic Elm subscription form&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;Coming soon...&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2017/12/01/phoenix-elm-landing-page-pt-1/"&gt;previous part&lt;/a&gt; of the series we created the project for our
brand new landing page, we generated the migration for the leads table, we
implemented the logic for saving them into the database, and we also added
some tests to ensure that everything was working fine. Now we can focus on
the front-end side of the project, which consists of a &lt;strong&gt;Phoenix&lt;/strong&gt; template,
an &lt;strong&gt;Elm&lt;/strong&gt; form, and some &lt;strong&gt;Sass&lt;/strong&gt; love. Let&amp;#39;s do this!&lt;/p&gt;

&lt;h2&gt;A little bit of clean up&lt;/h2&gt;

&lt;p&gt;Before going any further, let&amp;#39;s do a clean up emptying or removing some of
the files generated by &lt;strong&gt;Phoenix&lt;/strong&gt;. These changes include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Removing &lt;code&gt;assets/css/phoenix.css&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Removing &lt;code&gt;assets/js/socket.js&lt;/code&gt; as we are not using sockets this time.&lt;/li&gt;
&lt;li&gt;Removing &lt;code&gt;assets/static/images/phoenix.png&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from removing these extra files that we do not need anymore, we are
also going to edit some of the existing ones. First of all, let&amp;#39;s update
the main layout template and remove all the default &lt;strong&gt;Phoenix&lt;/strong&gt; HTML elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class="eex"&gt;# lib/landing_page_web/templates/layout/app.html.eex

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;

    &amp;lt;title&amp;gt;Hello Landing Page!&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/css/app.css&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
    &amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;
    &amp;lt;script src=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/js/app.js&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to edit the &lt;code&gt;index.html&lt;/code&gt; template to add the basic structure
of the landing page:&lt;/p&gt;

&lt;pre&gt;&lt;code class="eex"&gt;# lib/landing_page_web/templates/page/index.html.eex

&amp;lt;div class=&amp;quot;main-wrapper&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;hero&amp;quot;&amp;gt;
      &amp;lt;h1 class=&amp;quot;title&amp;quot;&amp;gt;Phoenix &amp;amp; Elm landing page&amp;lt;/h1&amp;gt;
      &amp;lt;p class=&amp;quot;subtitle&amp;quot;&amp;gt;
        Real use case of building a landing page using &amp;lt;strong&amp;gt;Phoenix&amp;lt;/strong&amp;gt; and &amp;lt;strong&amp;gt;Elm&amp;lt;/strong&amp;gt;,
        following some common patterns and best practices.
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;scroll-to&amp;quot;&amp;gt;
      &amp;lt;a class=&amp;quot;icon&amp;quot;&amp;gt;
        &amp;lt;i class=&amp;quot;fa fa-chevron-down&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;right&amp;quot; id=&amp;quot;subscribe_form&amp;quot;&amp;gt;
    &amp;lt;section class=&amp;quot;section&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;container is-fluid&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;form_container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having deleted all the extra files and the layout template ready, we are
in a good position to add some styling.&lt;/p&gt;

&lt;h2&gt;Adding styles with Sass and Bulma&lt;/h2&gt;

&lt;p&gt;I have started using &lt;a href="https://bulma.io/"&gt;Bulma&lt;/a&gt; like a month ago, and
I love the results so far. It is a pretty slick looking CSS framework,
based on &lt;strong&gt;flexbox&lt;/strong&gt; and which is very easy to customize using &lt;strong&gt;Sass&lt;/strong&gt;.
Let&amp;#39;s install everything we need to use &lt;strong&gt;Bulma&lt;/strong&gt; and &lt;strong&gt;Sass&lt;/strong&gt; with
&lt;strong&gt;Brunch&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ cd assets
$ npm install node-sass sass-brunch --save-dev
...
...
$ npm install bulma normalize-scss --save
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing the needed modules, we have to edit Brunch&amp;#39;s
configuration file to add support for Sass:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/brunch-config.js

exports.config = {
  // See http://brunch.io/#documentation for docs.
  // ...

  // Configure your plugins
  plugins: {
    // ...

    sass: {
      mode: &amp;#39;native&amp;#39;,
      sourceMapEmbed: true,
      options: {
        includePaths: [
          &amp;#39;node_modules/normalize-scss/sass/&amp;#39;,
          &amp;#39;node_modules/bulma/&amp;#39;,
        ],
      },
    },
  },

//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another tool that I often use to organize my styles files is
&lt;a href="https://github.com/jasonreece/css-burrito"&gt;css-burrito&lt;/a&gt;, which generates
a very convenient structure of &lt;strong&gt;Sass&lt;/strong&gt; files to help you have a well and
organized &lt;strong&gt;Sass&lt;/strong&gt; architecture based on modules. I am not going to dive
deeper into the implementation details, but here you
can find the resulting files. After adding the style files, and restarting
the &lt;strong&gt;Phoenix&lt;/strong&gt; server, we can visit
&lt;a href="http://localhost:4000"&gt;http://localhost:4000&lt;/a&gt; and see the following:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/plain-html.jpg"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Not looking bad at all! However, what about the subscription form?&lt;/p&gt;

&lt;h2&gt;Adding Elm support&lt;/h2&gt;

&lt;p&gt;Adding &lt;strong&gt;Elm&lt;/strong&gt; to the project is pretty straightforward. Before going any
further, make sure you visit &lt;a href="http://elm-lang.org/"&gt;Elm&amp;#39;s official site&lt;/a&gt;
and follow the install instructions for your current platform. Once you
have sorted that out, let&amp;#39;s continue by adding &lt;strong&gt;Elm&lt;/strong&gt;, and its &lt;strong&gt;Brunch&lt;/strong&gt;
support to the project:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ cd assets
$ mkdir elm
$ cd elm
$ elm package install elm-lang/html -y
.
..
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last command installs the basic &lt;strong&gt;Elm&lt;/strong&gt; packages and generates the initial
file structure and configuration file that we need to update to make it
look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;// assets/elm/elm-package.json

{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;summary&amp;quot;: &amp;quot;Repo for my Phoenix and Elm landing page series&amp;quot;,
  &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/bigardone/phoenix-and-elm-landing-page.git&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;BSD3&amp;quot;,
  &amp;quot;source-directories&amp;quot;: [&amp;quot;src&amp;quot;],
  &amp;quot;exposed-modules&amp;quot;: [],
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;elm-lang/core&amp;quot;: &amp;quot;5.1.1 &amp;lt;= v &amp;lt; 6.0.0&amp;quot;,
    &amp;quot;elm-lang/html&amp;quot;: &amp;quot;2.0.0 &amp;lt;= v &amp;lt; 3.0.0&amp;quot;
  },
  &amp;quot;elm-version&amp;quot;: &amp;quot;0.18.0 &amp;lt;= v &amp;lt; 0.19.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When working with &lt;strong&gt;Elm&lt;/strong&gt;, something that I usually do is to create an src
folder inside &lt;code&gt;assets/elm&lt;/code&gt; where I put there all my &lt;strong&gt;Elm&lt;/strong&gt; source files. The
reason for this is that I sometimes install third-party libraries, and
I like to separate them from my source files, so I place them in an
&lt;code&gt;assets/elm/vendor&lt;/code&gt; folder. Therefore, don&amp;#39;t forget to change the
&lt;code&gt;&amp;quot;source-directories&amp;quot;: [&amp;quot;src&amp;quot;]&lt;/code&gt; line, otherwise your &lt;strong&gt;Elm&lt;/strong&gt; files are not going
to compile at all. We still have to make &lt;strong&gt;Brunch&lt;/strong&gt; detect and build &lt;strong&gt;Elm&lt;/strong&gt;
files, so let&amp;#39;s edit the &lt;strong&gt;Brunch&lt;/strong&gt; configuration file once more:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/brunch-config.js

exports.config = {
  // See http://brunch.io/#documentation for docs.
  // ...

  // Phoenix paths configuration
  paths: {
    // Dependencies and current project directories to watch
    watched: [&amp;#39;static&amp;#39;, &amp;#39;css&amp;#39;, &amp;#39;js&amp;#39;, &amp;#39;vendor&amp;#39;, &amp;#39;elm&amp;#39;],
    // ...
  },

  // Configure your plugins
  plugins: {
    // ...

    elmBrunch: {
      mainModules: [&amp;#39;src/Main.elm&amp;#39;],
      elmFolder: &amp;#39;elm&amp;#39;,
      outputFolder: &amp;#39;../js/elm&amp;#39;,
      makeParameters: [&amp;#39;--warn&amp;#39;, &amp;#39;--debug&amp;#39;],
    },
  },

//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test that everything is working fine, let&amp;#39;s create simple main Elm
module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

module Main exposing (main)

import Html exposing (Html)


main : Html msg
main =
    Html.text &amp;quot;Hello, Elm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we have to embed the generated javascript by &lt;strong&gt;Elm&lt;/strong&gt; in the
&lt;code&gt;index.html&lt;/code&gt; template, so let&amp;#39;s edit the main &lt;code&gt;app.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/js/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

const elmContainer = document.querySelector(&amp;#39;#elm_container&amp;#39;);

if (elmContainer) {
  const app = Elm.Main.embed(elmContainer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After &lt;strong&gt;Brunch&lt;/strong&gt; finishes compiling the assets, we can see the &lt;code&gt;Hello,
Elm!&lt;/code&gt; message on the right section of the landing page, yay!&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/hello-elm.jpg"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h2&gt;The subscription form&lt;/h2&gt;

&lt;p&gt;The subscription form we need consists of two fields, one for the lead&amp;#39;s
full name and another one for the email. Knowing this, let&amp;#39;s start by
defining any &lt;strong&gt;Elm&lt;/strong&gt; application core element, the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Model.elm

module Model exposing (..)

import Dict exposing (Dict)


type alias FormFields =
    { fullName : String
    , email : String
    }


type alias ValidationErrors =
    Dict String (List String)


type SubscribeForm
    = Editing FormFields
    | Saving FormFields
    | Invalid FormFields ValidationErrors
    | Errored FormFields String
    | Success


type alias Model =
    { subscribeForm : SubscribeForm }


extractFormFields : SubscribeForm -&amp;gt; FormFields
extractFormFields subscribeForm =
    case subscribeForm of
        Editing ff -&amp;gt;
            ff

        Saving ff -&amp;gt;
            ff

        Invalid ff _ -&amp;gt;
            ff

        Errored ff _ -&amp;gt;
            ff

        Success -&amp;gt;
            emptyFormFields


emptyFormFields : FormFields
emptyFormFields =
    { fullName = &amp;quot;&amp;quot;
    , email = &amp;quot;&amp;quot;
    }


extractValidationErrors : SubscribeForm -&amp;gt; ValidationErrors
extractValidationErrors subscribeForm =
    case subscribeForm of
        Invalid _ validationErrors -&amp;gt;
            validationErrors

        _ -&amp;gt;
            emptyValidationErrors


emptyValidationErrors : ValidationErrors
emptyValidationErrors =
    Dict.empty


initialModel : Model
initialModel =
    { subscribeForm = Editing emptyFormFields }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Model&lt;/code&gt; consists of a record with a &lt;code&gt;subscribeForm&lt;/code&gt; key, which is
a &lt;strong&gt;union type&lt;/strong&gt; representing the form&amp;#39;s current state which can be one of
the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Editing&lt;/code&gt; is the initial state when the user is typing on its controls.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Saving&lt;/code&gt; is when the user submits the form, and the Http request with
the data is sent to the backend.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Invalid&lt;/code&gt; means that there are validation errors or something went wrong
while saving the data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Errored&lt;/code&gt; for the cases where there is an error not related to
validation.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Success&lt;/code&gt; represents that everything went fine, and the lead&amp;#39;s data has
been saved into the database.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on the form&amp;#39;s current state, &lt;code&gt;SubscribeForm&lt;/code&gt; might have
a &lt;code&gt;FormFields&lt;/code&gt; record with the current values inserted by the user, and
a &lt;code&gt;ValidationErrors&lt;/code&gt; type, which consists of a &lt;code&gt;Dict&lt;/code&gt; of validation errors by
field, or a &lt;code&gt;String&lt;/code&gt; containing an error message, which is the case of
&lt;code&gt;Errored&lt;/code&gt;. But why are we defining the model like this? If you are new to
&lt;strong&gt;Elm&lt;/strong&gt;, and not very familiar with &lt;strong&gt;union types&lt;/strong&gt;, you might have probably
defined the model something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;type Status
    = Editing
    | Saving
    | Invalid
    | Errored
    | Success

type alias Model =
    { formFields : FormFields
    , validationErrors : Dict String (List String)
    , error: String
    , status : Status
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach is completely fine, until you realize that it can drive to
&lt;strong&gt;inconsistent states&lt;/strong&gt;, like having a &lt;code&gt;Success&lt;/code&gt; state with a nonempty &lt;code&gt;Dict&lt;/code&gt; of
&lt;code&gt;validationErrors&lt;/code&gt; or with an error message string, and you have to make an
extra effort to prevent the impossible states, or states that don&amp;#39;t make
sense at all. Union types are a very convenient way of avoiding these
situations by making the model data depend on the type, &lt;a href="https://www.youtube.com/watch?v=IcgmSRJHu_8"&gt;making impossible
states impossible&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once the model is defined, let&amp;#39;s continue by implementing the view to
represent the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

import Dict exposing (Dict)
import Html exposing (Html, form)
import Html.Attributes as Html
import Html.Events as Html
import Messages exposing (Msg(..))
import Model exposing (..)


view : Model -&amp;gt; Html Msg
view { subscribeForm } =
    case subscribeForm of
        Success -&amp;gt;
            Html.div
                [ Html.class &amp;quot;success-message&amp;quot; ]
                [ Html.div
                    [ Html.class &amp;quot;icon is-large&amp;quot; ]
                    [ Html.i
                        [ Html.class &amp;quot;fa fa-3x fa-heart&amp;quot; ]
                        []
                    ]
                , Html.h2
                    []
                    [ Html.text &amp;quot;You have subscribed with success&amp;quot; ]
                , Html.p
                    []
                    [ Html.text &amp;quot;We will keep you updated with the latest news&amp;quot; ]
                ]

        _ -&amp;gt;
            formView subscribeForm


formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
    let
        { fullName, email } =
            extractFormFields subscribeForm

        saving =
            case subscribeForm of
                Saving _ -&amp;gt;
                    True

                _ -&amp;gt;
                    False

        invalid =
            case subscribeForm of
                Invalid _ _ -&amp;gt;
                    True

                _ -&amp;gt;
                    False

        buttonDisabled =
            fullName == &amp;quot;&amp;quot; || email == &amp;quot;&amp;quot; || saving || invalid
    in
        Html.div
            [ Html.class &amp;quot;content&amp;quot; ]
            [ Html.h3
                []
                [ Html.text &amp;quot;Want to know more?&amp;quot; ]
            , Html.p
                []
                [ Html.text &amp;quot;Subscribe to stay updated&amp;quot; ]
            , formError subscribeForm
            , form
                [ Html.onSubmit HandleFormSubmit ]
                [ Html.div
                    [ Html.class &amp;quot;field&amp;quot; ]
                    [ Html.div
                        [ Html.class &amp;quot;control&amp;quot; ]
                        [ Html.input
                            [ Html.classList
                                [ ( &amp;quot;input is-medium&amp;quot;, True )
                                ]
                            , Html.placeholder &amp;quot;My name is...&amp;quot;
                            , Html.required True
                            , Html.value fullName
                            , Html.onInput HandleFullNameInput
                            ]
                            []
                        ]
                    ]
                , Html.div
                    [ Html.class &amp;quot;field&amp;quot; ]
                    [ Html.div
                        [ Html.class &amp;quot;control&amp;quot; ]
                        [ Html.input
                            [ Html.classList
                                [ ( &amp;quot;input is-medium&amp;quot;, True )
                                ]
                            , Html.type_ &amp;quot;email&amp;quot;
                            , Html.placeholder &amp;quot;My email address is...&amp;quot;
                            , Html.required True
                            , Html.value email
                            , Html.onInput HandleEmailInput
                            ]
                            []
                        ]
                    ]
                , Html.div
                    [ Html.class &amp;quot;field&amp;quot; ]
                    [ Html.div
                        [ Html.class &amp;quot;control&amp;quot; ]
                        [ Html.button
                            [ Html.class &amp;quot;button is-primary is-medium&amp;quot;
                            , Html.disabled buttonDisabled
                            ]
                            [ Html.span
                                [ Html.class &amp;quot;icon&amp;quot; ]
                                [ Html.i
                                    [ Html.classList
                                        [ ( &amp;quot;fa fa-check&amp;quot;, not saving )
                                        , ( &amp;quot;fa fa-circle-o-notch fa-spin&amp;quot;, saving )
                                        ]
                                    ]
                                    []
                                ]
                            , Html.span
                                []
                                [ Html.text &amp;quot;Subscribe me&amp;quot; ]
                            ]
                        ]
                    ]
                ]
            ]


formError : SubscribeForm -&amp;gt; Html Msg
formError subscribeForm =
    case subscribeForm of
        Errored _ message -&amp;gt;
            Html.div
                [ Html.class &amp;quot;notification is-danger fade-in&amp;quot; ]
                [ Html.text message ]

        _ -&amp;gt;
            Html.text &amp;quot;&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;view&lt;/code&gt; function receives the &lt;code&gt;Model&lt;/code&gt; and depending on the value of
&lt;code&gt;subscribeForm&lt;/code&gt; it renders a success message or the form using the
&lt;code&gt;formView&lt;/code&gt; function. This function starts by extracting the
current &lt;code&gt;formFields&lt;/code&gt; values and checking if the form is &lt;code&gt;saving&lt;/code&gt; or &lt;code&gt;invalid&lt;/code&gt;.
With these four values, we define the &lt;code&gt;buttonDisabled&lt;/code&gt; value, to disable the
submit button if any of the fields are empty or the form is currently
invalid or saving the data. Inside the &lt;code&gt;in&lt;/code&gt; block, it renders the form,
which has the following peculiarities which are worth mentioning:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It sends a &lt;code&gt;HandleFormSubmit&lt;/code&gt; message when submitted.&lt;/li&gt;
&lt;li&gt;It sends a &lt;code&gt;HandleFullNameInput&lt;/code&gt; message when the &lt;code&gt;fullName&lt;/code&gt; input
changes.&lt;/li&gt;
&lt;li&gt;Same happens for the &lt;code&gt;email&lt;/code&gt; input, but with a &lt;code&gt;HandleEmailInput&lt;/code&gt;
message.&lt;/li&gt;
&lt;li&gt;The submit button is styled and disabled depending on the current state
of &lt;code&gt;subscribeForm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;formError&lt;/code&gt; function renders a message box with the error when the
form state happens to be &lt;code&gt;Errored&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have not defined yet the messages that we are using in the view for
handling input changes and the form submission, so let&amp;#39;s go ahead and
create the messages module to define them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Messages.elm

module Messages exposing (Msg(..))

import Dict exposing (Dict)
import Http


type Msg
    = HandleFullNameInput String
    | HandleEmailInput String
    | HandleFormSubmit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;#39;s create the update module, which handles messages updating the
application model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

import Messages exposing (Msg(..))
import Model exposing (..)


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    let
        subscribeForm =
            model.subscribeForm

        formFields =
            extractFormFields model.subscribeForm
    in
        case msg of
            HandleFullNameInput value -&amp;gt;
                { model | subscribeForm = Editing { formFields | fullName = value } } ! []

            HandleEmailInput value -&amp;gt;
                { model | subscribeForm = Editing { formFields | email = value } } ! []

            HandleFormSubmit -&amp;gt;
                { model | subscribeForm = Saving formFields } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the update function receives either a &lt;code&gt;HandleFullNameInput&lt;/code&gt; or
a &lt;code&gt;HandleEmailInput&lt;/code&gt;, it sets the &lt;code&gt;subscribeForm&lt;/code&gt; to &lt;code&gt;Editing&lt;/code&gt; applying the
current value of the corresponding input. This approach is going to be
very convenient while dealing with validation errors as we are going to
see in a minute. On the other hand, &lt;code&gt;HandleFormSubmit&lt;/code&gt; sets the state to
&lt;code&gt;Saving&lt;/code&gt; which we are using in the &lt;code&gt;View&lt;/code&gt; module to add a spinner and disable
the submit button.&lt;/p&gt;

&lt;p&gt;Last but not least, let&amp;#39;s change the main module to tie everything
together:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

module Main exposing (main)

import Html exposing (Html)
import Messages exposing (Msg(..))
import Model exposing (..)
import Update exposing (update)
import View exposing (view)


main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


init : ( Model, Cmd Msg )
init =
    initialModel ! []


subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Sub.none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything should be compiling successfully now, so jumping back to the
browser we should see the subscription form rendering and ready to send
leads subscriptions:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/subscription-form.gif"
alt="Subscription form" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h2&gt;Form submission and error handling&lt;/h2&gt;

&lt;p&gt;The form is submitted using an HTTP request, and for that, we need to
install &lt;a href="http://package.elm-lang.org/packages/elm-lang/http/latest"&gt;Elm&amp;#39;s HTTP
package&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ cd assets/elm
$ elm package install elm-lang/http -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As an HTTP request involves &lt;strong&gt;side effects&lt;/strong&gt;, we have to manage them in Elm
using &lt;code&gt;Commands&lt;/code&gt;, so let&amp;#39;s create the command for posting the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Commands.elm

import Http
import Json.Decode as JD
import Json.Encode as JE
import Decoders exposing (responseDecoder)
import Messages exposing (Msg(..))
import Model exposing (SubscribeForm(..), FormFields)


subscribe : SubscribeForm -&amp;gt; Cmd Msg
subscribe subscribeForm =
    case subscribeForm of
        Saving formFields -&amp;gt;
            Http.send SubscribeResponse (post formFields)

        _ -&amp;gt;
            Cmd.none


post : FormFields -&amp;gt; Http.Request Bool
post formFields =
    Http.request
        { method = &amp;quot;POST&amp;quot;
        , headers = []
        , url = &amp;quot;/api/v1/leads&amp;quot;
        , body = Http.jsonBody (encodeModel formFields)
        , expect = Http.expectJson responseDecoder
        , timeout = Nothing
        , withCredentials = False
        }


encodeModel : FormFields -&amp;gt; JD.Value
encodeModel { fullName, email } =
    JE.object
        [ ( &amp;quot;lead&amp;quot;
          , JE.object
                [ ( &amp;quot;full_name&amp;quot;, JE.string fullName )
                , ( &amp;quot;email&amp;quot;, JE.string email )
                ]
          )
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;subscribe&lt;/code&gt; function we can find another example of how convenient
are union types. We want to post the data only when the form&amp;#39;s status is
&lt;code&gt;Saving&lt;/code&gt; and not when there are validation errors for instance. &lt;code&gt;Http.send&lt;/code&gt;
receives the &lt;code&gt;SubscribeForm&lt;/code&gt; message, used to handle the result and the post
request. This request consists of a record that has all the details of the
request, including the &lt;code&gt;JSON&lt;/code&gt; body which is the encoded form fields, and the
logic to handle the expected response in the expect field, in our case
a &lt;code&gt;JSON&lt;/code&gt; decoder &lt;code&gt;responseDecoder&lt;/code&gt; that we have to create:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Decoders.elm

module Decoders exposing (..)

import Json.Decode as Decode
import Model exposing (ValidationErrors)


responseDecoder : Decode.Decoder Bool
responseDecoder =
    Decode.succeed True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we do not care about the payload that the &lt;code&gt;LeadController&lt;/code&gt; is returning
once the lead subscribes successfully, the &lt;code&gt;responseDecoder&lt;/code&gt; function
decodes anything received into a &lt;code&gt;True&lt;/code&gt; value. Next step for handling the
response is to add the &lt;code&gt;SubscribeResponse&lt;/code&gt; message to the &lt;code&gt;Messages&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Messages.elm

module Messages exposing (Msg(..))

import Dict exposing (Dict)
import Http


type Msg
    = HandleFullNameInput String
    | HandleEmailInput String
    | HandleFormSubmit
    | SubscribeResponse (Result Http.Error Bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, of course, the necessary handle clause in the &lt;code&gt;Update.update&lt;/code&gt;
function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

-- ...

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    let
        subscribeForm =
            model.subscribeForm

        formFields =
            extractFormFields model.subscribeForm
    in
        case msg of
            -- ...

            SubscribeResponse (Ok result) -&amp;gt;
                { model | subscribeForm = Success } ! []

            SubscribeResponse (Err (BadStatus response)) -&amp;gt;
                case Decode.decodeString validationErrorsDecoder response.body of
                    Ok validationErrors -&amp;gt;
                        { model | subscribeForm = Invalid formFields validationErrors } ! []

                    Err error -&amp;gt;
                        { model | subscribeForm = Errored formFields &amp;quot;Oops! Something went wrong!&amp;quot; } ! []

            SubscribeResponse (Err error) -&amp;gt;
                { model | subscribeForm = Errored formFields &amp;quot;Oops! Something went wrong!&amp;quot; } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt; of the form post can be either an &lt;code&gt;Ok True&lt;/code&gt;, meaning that
everything went fine setting the &lt;code&gt;subscribeForm&lt;/code&gt; to &lt;code&gt;Success&lt;/code&gt;, or an
&lt;code&gt;Http.Error&lt;/code&gt;, which is another union type describing the reason for the
error. In our case, we only want to handle validation errors, so it
patterns matches against &lt;code&gt;BadStatus&lt;/code&gt; response, using the
&lt;code&gt;validationErrorsDecoder&lt;/code&gt; to decode response which is the error list
returned by the &lt;code&gt;LandingPageWeb.FallbackController&lt;/code&gt; that we created in the
previous part. If there is any other sort of error, it sets the form to
&lt;code&gt;Errored&lt;/code&gt; with a custom error message. To make it work properly, let&amp;#39;s
implement the missing &lt;code&gt;validationErrorsDecoder&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Decoders.elm

module Decoders exposing (..)

import Json.Decode as Decode
import Model exposing (ValidationErrors)

-- ...

validationErrorsDecoder : Decode.Decoder ValidationErrors
validationErrorsDecoder =
    Decode.dict &amp;lt;| Decode.list Decode.string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new decoder transforms the response into a &lt;code&gt;ValidationErrors&lt;/code&gt; which is
a &lt;code&gt;Dict&lt;/code&gt; where its keys are field names, and the values are a list of
errors, that we can now render in the view:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
    let
        validationErrors =
            extractValidationErrors subscribeForm

        -- ...
    in
        -- ...

        , form
            [ Html.onSubmit HandleFormSubmit ]
            [ Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.div
                    [ Html.class &amp;quot;control&amp;quot; ]
                    [ Html.input
                        [ Html.classList
                            [ ( &amp;quot;input is-medium&amp;quot;, True )
                            , ( &amp;quot;is-danger&amp;quot;, Dict.member &amp;quot;full_name&amp;quot; validationErrors )
                            ]
                        , Html.placeholder &amp;quot;My name is...&amp;quot;
                        , Html.required True
                        , Html.value fullName
                        , Html.onInput HandleFullNameInput
                        ]
                        []
                    , validationErrorView &amp;quot;full_name&amp;quot; validationErrors
                    ]
                ]
            , Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.div
                    [ Html.class &amp;quot;control&amp;quot; ]
                    [ Html.input
                                [ Html.classList
                                    [ ( &amp;quot;input is-medium&amp;quot;, True )
                                    , ( &amp;quot;is-danger&amp;quot;, Dict.member &amp;quot;email&amp;quot; validationErrors )
                                    ]
                                , Html.type_ &amp;quot;email&amp;quot;
                                , Html.placeholder &amp;quot;My email address is...&amp;quot;
                                , Html.required True
                                , Html.value email
                                , Html.onInput HandleEmailInput
                                ]
                                []
                            , validationErrorView &amp;quot;email&amp;quot; validationErrors
                            ]
                      ]

                      -- ...


validationErrorView : String -&amp;gt; ValidationErrors -&amp;gt; Html Msg
validationErrorView key validationErrors =
    case Dict.get key validationErrors of
        Just error -&amp;gt;
            error
                |&amp;gt; List.map Html.text
                |&amp;gt; Html.p
                    [ Html.class &amp;quot;help is-danger&amp;quot; ]

        Nothing -&amp;gt;
            Html.text &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;extractValidationErrors&lt;/code&gt; helper function from the &lt;code&gt;Model&lt;/code&gt; module,
it gets the possible &lt;code&gt;validationErrors&lt;/code&gt; and not only sets an is-danger class
to the fields when it happens to have errors but calls &lt;code&gt;validationErrorView&lt;/code&gt;
to render them.&lt;/p&gt;

&lt;h2&gt;The final result&lt;/h2&gt;

&lt;p&gt;It is time to test out our work so far. Let&amp;#39;s jump back to the browser and
try to subscribe using valid values:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/success-message.gif"
alt="Success message" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Submitting the form returns a &lt;code&gt;200&lt;/code&gt; success message which changes the
&lt;code&gt;subscribeForm&lt;/code&gt; to &lt;code&gt;Success&lt;/code&gt;, displaying the success message. Next, let&amp;#39;s
try subscribing again using the same email:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/validation-error.gif"
alt="Validation errors" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;This time the server returns a &lt;code&gt;422&lt;/code&gt; unprocessable entity status, with an
error message for the &lt;code&gt;email&lt;/code&gt; field, as it is already taken, cool!
Finally, let&amp;#39;s try to stop the Phoenix server and submit the form once
more to simulate an unexpected response:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/unknown-error.gif"
alt="Unknown error" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;As the server is down, the request fails, rendering the generic error message
that we have previously set for nonvalidation errors.&lt;/p&gt;

&lt;p&gt;Our new landing page is looking pretty good so far, though we haven&amp;#39;t finished
yet. In the next episode, we are going to add some protection against spam
bots using &lt;a href="https://developers.google.com/recaptcha/"&gt;Googles reCAPTCHA&lt;/a&gt;,
which not only implies using an external javascript library from our Elm
code but consuming a third party API from our backend. In the meantime,
you can check out the source code of the part
&lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-2"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Merry Christmas and Happy New Coding Year!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix &amp; Elm landing page (pt.1)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"/>
    <id>http://codeloveandboards.com/blog/2017/12/02/phoenix-elm-landing-page-pt-1/</id>
    <published>2017-12-02T08:00:00Z</published>
    <updated>2018-01-07T19:06:22+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix &amp; Elm landing page&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"&gt;Bootstrapping the project and the basic API functionality to save our first leads&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/24/phoenix-elm-landing-page-pt-2/"&gt;Building the landing page UI and the basic Elm subscription form&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;Coming soon...&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In these series, we are going to cover some common patterns and best practices related to using &lt;strong&gt;Phoenix&lt;/strong&gt; and &lt;strong&gt;Elm&lt;/strong&gt; to build a simple landing page with a subscription form. The primary goal is to achieve the following list of tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a new &lt;strong&gt;Phoenix&lt;/strong&gt; project.&lt;/li&gt;
&lt;li&gt;Add a new &lt;strong&gt;Phoenix&lt;/strong&gt; context for marketing leads.&lt;/li&gt;
&lt;li&gt;Add an &lt;strong&gt;API&lt;/strong&gt; endpoint to insert a lead&amp;#39;s data into the database.&lt;/li&gt;
&lt;li&gt;Build the landing page template using &lt;strong&gt;Phoenix&lt;/strong&gt; and &lt;a href="https://bulma.io/"&gt;Bulma&lt;/a&gt; as our CSS framework of choice.&lt;/li&gt;
&lt;li&gt;Add &lt;strong&gt;Elm&lt;/strong&gt; to the project and build a subscription form that points to the API endpoint described previously.&lt;/li&gt;
&lt;li&gt;Add &lt;a href="https://developers.google.com/recaptcha/"&gt;Google&amp;#39;s reCAPTCHA&lt;/a&gt; widget to the &lt;strong&gt;Elm&lt;/strong&gt; subscription form, and how to render it and how to handle a visitor&amp;#39;s &lt;strong&gt;reCAPTCHA&lt;/strong&gt; response.&lt;/li&gt;
&lt;li&gt;Build an HTTP client using &lt;a href="https://github.com/edgurgel/httpoison"&gt;HTTPoison&lt;/a&gt; to verify the token received by the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; widget against &lt;strong&gt;Google&amp;#39;s reCAPTCHA API&lt;/strong&gt; from our backend.&lt;/li&gt;
&lt;li&gt;Build another HTTP client to subscribe leads to an email marketing service such as &lt;a href="https://mailchimp.com"&gt;MailChimp&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Add tests covering the subscription process using &lt;strong&gt;mocks&lt;/strong&gt; for the HTTP clients.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that we have detailed what we need let&amp;#39;s get cracking!&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/landing-page.jpg" alt="Landing page" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h3&gt;Creating the Phoenix project&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s start by bootstrapping a new &lt;strong&gt;Phoenix&lt;/strong&gt; project as we usually do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phx.new landing_page
* creating landing_page/config/config.exs
* creating landing_page/config/dev.exs
* creating landing_page/config/prod.exs
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the task finishes, we can go to the generated project folder and create the database:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd landing_page
$ mix ecto.create
The database for LandingPage.Repo has already been created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to start working on the backend.&lt;/p&gt;

&lt;h3&gt;The Marketing context and Lead schema&lt;/h3&gt;

&lt;p&gt;Before continuing, let&amp;#39;s stop for a second and think about what is the primary goal of our future landing page. The principal goal is not only to be the temporally home site of our awesome new product that we are working on but to let potential leads subscribe so we can take any marketing or business decision that we might need, like for instance sending them the latest news and promotions via email campaigns. Having this in mind, we can identify a &lt;code&gt;Marketing&lt;/code&gt; context and a &lt;code&gt;leads&lt;/code&gt; table for the database, so let&amp;#39;s create both of them using the new &lt;strong&gt;Phoenix&lt;/strong&gt; context generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phx.gen.context Marketing Lead leads full_name:string email:string
* creating lib/landing_page/marketing/lead.ex
* creating priv/repo/migrations/20171202101203_create_leads.exs
* creating lib/landing_page/marketing/marketing.ex
* injecting lib/landing_page/marketing/marketing.ex
* creating test/landing_page/marketing/marketing_test.exs
* injecting test/landing_page/marketing/marketing_test.exs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before running the migrations task, we need to tweak the migration file just created to add a &lt;code&gt;unique&lt;/code&gt; index to the &lt;code&gt;email&lt;/code&gt; column, because we do not want leads subscribing multiple times with the same &lt;code&gt;email&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# priv/repo/migrations/20171201145808_create_leads.exs

defmodule LandingPage.Repo.Migrations.CreateLeads do
  use Ecto.Migration

  def change do
    create table(:leads) do
      add(:full_name, :string, null: false)
      add(:email, :string, null: false)

      timestamps()
    end

    create(unique_index(:leads, [:email]))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run the migrations task to create the table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mix ecto.migrate
[info] == Running LandingPage.Repo.Migrations.CreateLeads.change/0 forward
[info] create table leads
[info] create index leads_email_index
[info] == Migrated in 0.0s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also have to add the necessary validation rules and constraints to the &lt;code&gt;Lead&lt;/code&gt; schema module, so let&amp;#39;s edit it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/lead.ex

defmodule LandingPage.Marketing.Lead do
  use Ecto.Schema
  import Ecto.Changeset
  alias LandingPage.Marketing.Lead

  @derive {Poison.Encoder, only: [:full_name, :email]}

  schema &amp;quot;leads&amp;quot; do
    field(:email, :string)
    field(:full_name, :string)

    timestamps()
  end

  @doc false
  def changeset(%Lead{} = lead, attrs) do
    lead
    |&amp;gt; cast(attrs, [:full_name, :email])
    |&amp;gt; validate_required([:full_name, :email])
    |&amp;gt; unique_constraint(:email)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from adding the &lt;code&gt;unique_constraint&lt;/code&gt; check function, we are also adding the &lt;code&gt;@derive&lt;/code&gt; clause specifying the fields we want to return when a &lt;code&gt;%Lead{}&lt;/code&gt; struct is automatically encoded by &lt;strong&gt;Poison&lt;/strong&gt;, which is very convenient while developing &lt;strong&gt;JSON APIs&lt;/strong&gt;, as we are going to see in a minute.&lt;/p&gt;

&lt;h3&gt;The API endpoint and saving leads&lt;/h3&gt;

&lt;p&gt;Now that our context and schema are ready to start saving leads, let&amp;#39;s add the new &lt;strong&gt;route&lt;/strong&gt; that we are going to use for this purpose:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/router.ex

defmodule LandingPageWeb.Router do
  use LandingPageWeb, :router

    # ...

  # Other scopes may use custom stacks.
  scope &amp;quot;/api&amp;quot;, LandingPageWeb do
    pipe_through(:api)

    scope &amp;quot;/v1&amp;quot;, V1 do
      post(&amp;quot;/leads&amp;quot;, LeadController, :create)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s continue with a more test-driven approach and create a new test file that covers how we expect the controller to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page_web/controllers/v1/lead_controller_test.exs

defmodule LandingPageWeb.V1.LeadControllerTest do
  use LandingPageWeb.ConnCase

  describe &amp;quot;POST /api/v1/leads&amp;quot; do
    test &amp;quot;returns error response with invalid parms&amp;quot;, %{conn: conn} do
      conn = post(conn, lead_path(conn, :create), %{&amp;quot;lead&amp;quot; =&amp;gt; %{}})

      assert json_response(conn, 422) == %{
               &amp;quot;full_name&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;],
               &amp;quot;email&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;]
             }
    end

    test &amp;quot;returns success response with valid params&amp;quot;, %{conn: conn} do
      params = %{
        &amp;quot;lead&amp;quot; =&amp;gt; %{&amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;, &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;}
      }

      conn = post(conn, lead_path(conn, :create), params)
      assert json_response(conn, 200) == params[&amp;quot;lead&amp;quot;]
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is a very basic test, but it pretty much covers what we need at the moment. If the &lt;code&gt;lead&lt;/code&gt; parameter is invalid, it should return a &lt;code&gt;422&lt;/code&gt; response (unprocessable entity) along with the validation errors. On the other hand, if the sent parameters are correct, it will return a success response along with the inserted data. Let&amp;#39;s run the &lt;code&gt;mix test&lt;/code&gt; task and see what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix test test/landing_page_web/controllers/v1/lead_controller_test.exs


  1) test POST /api/v1/leads returns success response with valid params (LandingPageWeb.V1.LeadControllerTest)
     test/landing_page_web/controllers/v1/lead_controller_test.exs:14
     ** (UndefinedFunctionError) function LandingPageWeb.V1.LeadController.init/1 is undefined (module LandingPageWeb.V1.LeadController is not available)
     code: conn = post(conn, lead_path(conn, :create), params)
     stacktrace:
       LandingPageWeb.V1.LeadController.init(:create)
       (landing_page) lib/landing_page_web/router.ex:1: anonymous fn/1 in LandingPageWeb.Router.__match_route__/4
       (phoenix) lib/phoenix/router.ex:278: Phoenix.Router.__call__/1
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.plug_builder_call/2
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.call/2
       (phoenix) lib/phoenix/test/conn_test.ex:224: Phoenix.ConnTest.dispatch/5
       test/landing_page_web/controllers/v1/lead_controller_test.exs:19: (test)



  2) test POST /api/v1/leads returns error response with invalid parms (LandingPageWeb.V1.LeadControllerTest)
     test/landing_page_web/controllers/v1/lead_controller_test.exs:5
     ** (UndefinedFunctionError) function LandingPageWeb.V1.LeadController.init/1 is undefined (module LandingPageWeb.V1.LeadController is not available)
     code: conn = post(conn, lead_path(conn, :create), %{&amp;quot;lead&amp;quot; =&amp;gt; %{}})
     stacktrace:
       LandingPageWeb.V1.LeadController.init(:create)
       (landing_page) lib/landing_page_web/router.ex:1: anonymous fn/1 in LandingPageWeb.Router.__match_route__/4
       (phoenix) lib/phoenix/router.ex:278: Phoenix.Router.__call__/1
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.plug_builder_call/2
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.call/2
       (phoenix) lib/phoenix/test/conn_test.ex:224: Phoenix.ConnTest.dispatch/5
       test/landing_page_web/controllers/v1/lead_controller_test.exs:6: (test)



Finished in 0.09 seconds
2 tests, 2 failures

Randomized with seed 665970
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As expected, the test is failing because we have not created the controller module yet, so let&amp;#39;s add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/v1/lead_controller.ex

defmodule LandingPageWeb.V1.LeadController do
  use LandingPageWeb, :controller

  alias LandingPage.Marketing

  plug(:scrub_params, &amp;quot;lead&amp;quot;)

  def create(conn, %{&amp;quot;lead&amp;quot; =&amp;gt; params}) do
    with {:ok, lead} &amp;lt;- Marketing.create_lead(params) do
      json(conn, lead)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the &lt;code&gt;scrub_params&lt;/code&gt; plug to check if the lead parameter is present and to convert any of its empty keys to nil values. To create the lead, we are using &lt;code&gt;Marketing.create_lead&lt;/code&gt;, which we created before while generating the context. However, we are only pattern matching against the successful &lt;code&gt;{:ok, lead}&lt;/code&gt; response, and there might be validation errors, throwing a runtime error due to the missing pattern matching against &lt;code&gt;{:error, _}&lt;/code&gt;. So what is the reason for doing it like so? Simply because we want to introduce the new &lt;code&gt;Phoenix.Controller.action_fallback/1&lt;/code&gt; macro, which registers a &lt;code&gt;plug&lt;/code&gt; to call as a fallback when an action doesn&amp;#39;t return a valid &lt;code&gt;%Plug.Conn{}&lt;/code&gt; structure. In our particular case, if there is any validation error, it returns a &lt;code&gt;{:error, %Ecto.Changeset{}}&lt;/code&gt; that we need to handle, so let&amp;#39;s setup the fallback controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web.ex

defmodule LandingPageWeb do
# ...

  def controller do
    quote do
      use Phoenix.Controller, namespace: LandingPageWeb
      import Plug.Conn
      import LandingPageWeb.Router.Helpers
      import LandingPageWeb.Gettext

      action_fallback(LandingPageWeb.FallbackController)
    end
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding &lt;code&gt;action_fallback&lt;/code&gt; to the main &lt;code&gt;LandingPageWeb&lt;/code&gt; module makes it available to all of the controllers, but we also have to create the &lt;code&gt;FallbackController&lt;/code&gt; plug module itself, implementing the &lt;code&gt;call/2&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/fallback_controller.ex

defmodule LandingPageWeb.FallbackController do
  use LandingPageWeb, :controller

  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do
    conn
    |&amp;gt; put_status(:unprocessable_entity)
    |&amp;gt; render(LandingPageWeb.ErrorView, &amp;quot;error.json&amp;quot;, changeset: changeset)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it receives an error with a &lt;code&gt;changeset&lt;/code&gt;, it sets the &lt;code&gt;unprocessable_entity&lt;/code&gt; status to the connection and renders the &lt;code&gt;error.json&lt;/code&gt; template from the &lt;code&gt;LandingPageWeb.ErrorView&lt;/code&gt; module that we also need to implement in the existing module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/views/error_view.ex

defmodule LandingPageWeb.ErrorView do
  use LandingPageWeb, :view

  import LandingPageWeb.ErrorHelpers

  # ...

  def render(&amp;quot;error.json&amp;quot;, %{changeset: changeset}) do
    Ecto.Changeset.traverse_errors(changeset, &amp;amp;translate_error/1)
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calling Ectos&amp;#39;s &lt;code&gt;traverse_errors&lt;/code&gt; using the &lt;code&gt;translate_errors&lt;/code&gt; from the &lt;code&gt;ErrorHelpers&lt;/code&gt; module, returns the list of changeset errors we have described in the controller&amp;#39;s test. Let&amp;#39;s rerun the test task to verify that we are good to go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix test test/landing_page_web/controllers/v1/lead_controller_test.exs
..
Finished in 0.1 seconds
2 tests, 0 failures

Randomized with seed 304229
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome, all test are passing, and the controller is working as we initially planned. In regards to the back-end we have everything that we need, for now, so in the next part we will focus on the front-end side, install all dependencies that we need such as &lt;strong&gt;Elm&lt;/strong&gt; and &lt;strong&gt;Bulma&lt;/strong&gt;, building the basic layout and the subscription form to start saving the first leads. In the meantime, you can check out the source code of what we have done so far &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-1"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Migrating ActiveRecord STI to Ecto (pt. 1)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/10/03/migrating-activerecord-sti-to-ecto/"/>
    <id>http://codeloveandboards.com/blog/2017/10/03/migrating-activerecord-sti-to-ecto/</id>
    <published>2017-10-04T06:01:00Z</published>
    <updated>2017-10-06T10:40:14+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;From ActiveRecord STI to Ecto embedded schemas&lt;/h2&gt;

&lt;p&gt;Almost three years have passed since I wrote a post about &lt;a href="/blog/2015/01/11/rails-sti-with-postgresql-hstore"&gt;Rails STI with
PostgreSQL hstore&lt;/a&gt;. At
that time I was building a platform called &lt;a href="https://eventos.talentoit.org/"&gt;Eventos Talento
IT&lt;/a&gt; which started as a place where
developers could participate in raffles to win tickets for tech events, but we
have ended up raffling books and courses as well. In the mentioned post,
I explain how to achieve &lt;strong&gt;STI&lt;/strong&gt; in &lt;strong&gt;Rails&lt;/strong&gt; and &lt;strong&gt;PostgreSQL&lt;/strong&gt; thanks to
Postgres&amp;#39;s &lt;strong&gt;hstore&lt;/strong&gt; type. After these years, we want to make some
improvements in the platform, so instead of updating the old codebase, I can&amp;#39;t
resist redoing everything in &lt;strong&gt;Elixir&lt;/strong&gt; and, of course, &lt;strong&gt;Elm&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;After taking a look at the original &lt;strong&gt;Rails&lt;/strong&gt; project and recalling the schema
and models, I have encountered the first problem in regards to migrating
ActiveRecord models to Ecto schemas, inheritance. In the old &lt;strong&gt;Rails&lt;/strong&gt; project
we have the following models:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/item.rb

# == Schema Information
#
# Table name: items
#
#  id          :integer          not null, primary key
#  name        :string           not null
#  description :text
#  site_url    :string
#  image       :string
#  raffle_date :date
#  raffled_at  :datetime
#  created_at  :datetime         not null
#  updated_at  :datetime         not null
#  type        :string           not null
#  data        :hstore
#
# Indexes
#
#  index_items_on_data  (data)
#

class Item &amp;lt; ActiveRecord::Base
  # Validations
  validates :name, :raffle_date, presence: true
end

# app/models/book.rb

class Book &amp;lt; Item
  store_accessor :data, :author

  # Validations
  validates :author, presence: true
end

# app/models/event.rb

class Event &amp;lt; Item
  store_accessor :data, :start_date, :end_date, :location

  # Validations
  validates :start_date, :end_date, :location, presence: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Item&lt;/code&gt; model has the basic structure with the shared fields for &lt;code&gt;Book&lt;/code&gt; and
&lt;code&gt;Event&lt;/code&gt;, and the field &lt;code&gt;type&lt;/code&gt; specifies which item type is going to be. Both
&lt;code&gt;Event&lt;/code&gt; and &lt;code&gt;Book&lt;/code&gt; inherit from &lt;code&gt;Item&lt;/code&gt; defining their specific fields in
the &lt;code&gt;store_accessor&lt;/code&gt; function and their validation rules, which will be
checked along with the common rules when needed. In regards to &lt;strong&gt;Rails&lt;/strong&gt; and
&lt;strong&gt;ActiveRecord&lt;/strong&gt;, this is pretty much it, thanks to a lot of black magic going
on in the background. So, how can we achieve something similar with &lt;strong&gt;Ecto&lt;/strong&gt;?&lt;/p&gt;

&lt;h3&gt;Defining the table&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s start by preparing the new schema table to mirror. To make this work
correctly it, is essential that the field &lt;code&gt;type&lt;/code&gt; is adequately defined and it
only contains the values that we need. Of course, there are multiple ways of
achieving this, but last week my good friend
&lt;a href="https://oscardearriba.com/"&gt;Oscar&lt;/a&gt; told me about the
&lt;a href="https://github.com/gjaldon/ecto_enum"&gt;EctoEnum&lt;/a&gt; library, which adds support
for enums in &lt;strong&gt;Ecto&lt;/strong&gt; schemas, and looks like an excellent opportunity for
trying it out. To install it we need to add it in the &lt;code&gt;mix.exs&lt;/code&gt; file of the
project:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# mix.exs

defmodule TalentoItSchema.Mixfile do
  use Mix.Project

  # ...

  defp deps do
    [
      ...
      {:ecto_enum, &amp;quot;~&amp;gt; 1.0&amp;quot;}
    ]
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to create a module to define our different enums:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# talento_it_schema/lib/talento_it_schema/ecto_enums.ex

defmodule TalentoItSchema.EctoEnums do
  import EctoEnum

  defenum ItemTypeEnum, :item_type, [:book, :event]

  def item_type_book, do: :book

  def item_type_event, do: :event
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;defenum&lt;/code&gt; macro, we are setting a new &lt;code&gt;ItemTypeEnum&lt;/code&gt; enum that maps
a new Postgres &lt;code&gt;item_type&lt;/code&gt; enum that will have &lt;code&gt;book&lt;/code&gt; or &lt;code&gt;event&lt;/code&gt; as valid
values. Now we have to create both the enum type and the table, so let&amp;#39;s create
the migration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/priv/repo/migrations/123456789_create_raffle_items.exs

dule TalentoItSchema.Repo.Migrations.CreateRaffleItems do
  use Ecto.Migration

  alias TalentoItSchema.EctoEnums.ItemTypeEnum

  def change do
    ItemTypeEnum.create_type()

    create table(:raffle_items) do
      add :type, :item_type, null: false
      add :name, :string, null: false
      add :description, :string
      add :site_url, :string
      add :image, :string
      add :raffle_date, :date
      add :raffled_at, :utc_datetime
      add :data, :map

      timestamps()
    end

    create index(:raffle_items, [:type])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ItemTypeEnum.create_type()&lt;/code&gt; is a helper function that comes with &lt;strong&gt;EctoEnum&lt;/strong&gt;
to create the new enum type in Postgres. Also note that the &lt;code&gt;data&lt;/code&gt; column is of
type &lt;code&gt;map&lt;/code&gt;, and will store the specific data for books and events. Let&amp;#39;s run
the migration and &lt;code&gt;run mix ecto.dump&lt;/code&gt; to check in the generated file how it
creates this new type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;-- talento_it_schema/priv/repo/structure.sql

-- ...

--
-- Name: item_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE item_type AS ENUM (
    &amp;#39;book&amp;#39;,
    &amp;#39;event&amp;#39;
);

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;#39;s move on the schema module to set it up correctly:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/lib/talento_it_schame/raffle/item.ex

defmodule TalentoItSchema.Raffle.Item do
  use Ecto.Schema
  import Ecto.Changeset

  alias TalentoItSchema.{
    EctoEnums,
    EctoEnums.ItemTypeEnum
  }

  schema &amp;quot;raffle_items&amp;quot; do
    field :name, :string
    field :description, :string
    field :site_url, :string
    field :image, :string
    field :raffle_date, :date
    field :raffled_at, :utc_datetime
    field :type, ItemTypeEnum
    field :data, :map

    timestamps()
  end

  @fields ~w(type name description site_url image raffle_date raffled_at data)a
  @required_fields ~w(type name data)a

  @doc false
  def changeset(%Item{} = item, attrs) do
    item
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@required_fields)
  end

  # ...

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we have set the type of the &lt;code&gt;:type&lt;/code&gt; field to &lt;code&gt;ItemTypeEnum&lt;/code&gt;,
which takes care of validating that the passed attributes only contain allowed
values, in this particular case any of &lt;code&gt;[:book, :event, &amp;quot;book&amp;quot;, &amp;quot;event&amp;quot;]&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt;Item.changeset(%Item{}, %{type: &amp;quot;IVALID&amp;quot;, name: &amp;quot;Foo&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;},
 errors: [type: {&amp;quot;is invalid&amp;quot;,
   [type: TalentoItSchema.EctoEnums.ItemTypeEnum, validation: :cast]}],
 data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: false&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Item.changeset(%Item{}, %{type: &amp;quot;book&amp;quot;, name: &amp;quot;Foo&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;, type: :book},
 errors: [], data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until this point, we have covered the basic &lt;code&gt;Item&lt;/code&gt; attributes and validations,
but how can we do something similar to the old &lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Event&lt;/code&gt; &lt;strong&gt;Rails&lt;/strong&gt;
models to define specific attributes and validations? One of my favorite things
about &lt;code&gt;Ecto&lt;/code&gt; (and &lt;code&gt;Elixir&lt;/code&gt; in general) is that there is no hidden magic behind.
Its explicitness forces you to write more code, but on the other hand, it gives
you the freedom to solve problems in many different ways.&lt;/p&gt;

&lt;h3&gt;Ecto embedded schemas&lt;/h3&gt;

&lt;p&gt;After doing some research and watching &lt;a href="https://github.com/darinwilson"&gt;Darin
Wilson&amp;#39;s&lt;/a&gt; talk on &lt;a href="https://elixirconf.com/"&gt;ElixirConf
2017&lt;/a&gt; called &lt;a href="https://www.youtube.com/watch?v=YQxopjai0CU"&gt;Thinking in
Ecto&lt;/a&gt;, I have decided to use
Ecto&amp;#39;s
&lt;a href="https://hexdocs.pm/ecto/Ecto.Schema.html#embedded_schema/1"&gt;embedded_schema&lt;/a&gt;.
An embedded schema is essentially a schema which doesn&amp;#39;t point to any
particular data source. It can&amp;#39;t be queried or persisted, but, on the other
hand, it lets you define its structure, types and validation rules, which is
very suitable for our needs. Let&amp;#39;s create the embedded schemas for both the
&lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Event&lt;/code&gt; modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/lib/talento_it_schema/raffle/item/book.ex

defmodule TalentoItSchema.Raffle.Item.Book do
  use Ecto.Schema
  import Ecto.Changeset

  embedded_schema do
    field :author, :string
  end

  @fields ~w(author)a

  def changeset(attrs), do: changeset(%__MODULE__{}, attrs)
  def changeset(%__MODULE__{} = book, attrs) do
    book
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@fields)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/lib/talento_it_schema/raffle/item/event.ex

defmodule TalentoItSchema.Raffle.Item.Event do
  use Ecto.Schema
  import Ecto.Changeset

  embedded_schema do
    field :start_date, :date
    field :end_date, :date
    field :location, :string
  end

  @fields ~w(start_date end_date location)a

  def changeset(attrs), do: changeset(%__MODULE__{}, attrs)
  def changeset(%__MODULE__{} = event, attrs) do
    event
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@fields)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like in the old &lt;strong&gt;Rails&lt;/strong&gt; models, the &lt;code&gt;Book&lt;/code&gt; embed schema contains an
&lt;code&gt;author&lt;/code&gt; key with a required &lt;code&gt;string&lt;/code&gt; value. Same happens with &lt;code&gt;Event&lt;/code&gt;, but
it has &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt;, both of them &lt;code&gt;date&lt;/code&gt; fields, and
&lt;code&gt;location&lt;/code&gt; which is a string, all of them mandatory. Going back to &lt;code&gt;IEx&lt;/code&gt;, we
can check that everything works as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; Book.changeset(%{})
#Ecto.Changeset&amp;lt;action: nil, changes: %{},
 errors: [author: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}],
 data: #TalentoItSchema.Raffle.Item.Book&amp;lt;&amp;gt;, valid?: false&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Event.changeset(%{})
#Ecto.Changeset&amp;lt;action: nil, changes: %{},
 errors: [start_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  end_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  location: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}],
 data: #TalentoItSchema.Raffle.Item.Event&amp;lt;&amp;gt;, valid?: false&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! Now we just need a way of making the &lt;code&gt;Item.changeset/2&lt;/code&gt; function call
the respective &lt;code&gt;changeset&lt;/code&gt; functions of the embedded schemas modules, depending
of course on the &lt;code&gt;type&lt;/code&gt; enum previously defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# talento_it_schema/lib/talento_it_schame/raffle/item.ex

defmodule TalentoItSchema.Raffle.Item do
  use Ecto.Schema
  import Ecto.Changeset

  alias TalentoItSchema.{
    EctoEnums,
    EctoEnums.ItemTypeEnum,
    Raffle.Item.Book,
    Raffle.Item.Event
  }

  # ...

  @doc false
  def changeset(%Item{} = item, attrs) do
    item
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@required_fields)
    |&amp;gt; validate_data
  end

  defp validate_data(changeset) do
    changeset
    |&amp;gt; build_data_changeset
    |&amp;gt; case do
      %{valid?: true} -&amp;gt;
        changeset

      %{errors: errors} -&amp;gt;
        add_data_errors(changeset, errors)
    end
  end

  defp build_data_changeset(changeset) do
    data = get_field(changeset, :data)
    type = get_field(changeset, :type)

    cond do
      type == EctoEnums.item_type_book() -&amp;gt;
        Book.changeset(data)

      type == EctoEnums.item_type_event() -&amp;gt;
        Event.changeset(data)

      true -&amp;gt;
        changeset
    end
  end

  defp add_data_errors(changeset, errors) do
    Enum.reduce(errors, changeset, fn {key, {message, meta}}, acc -&amp;gt; add_error(acc, key, message, meta) end)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;changeset&lt;/code&gt; pipeline we have added a call to a new &lt;code&gt;validate_data/1&lt;/code&gt;
function, which receives the current &lt;code&gt;changeset&lt;/code&gt; and depending on the &lt;code&gt;type&lt;/code&gt;
enum value, calls the specific &lt;code&gt;Book&lt;/code&gt; or &lt;code&gt;Event&lt;/code&gt; module &lt;code&gt;changeset/1&lt;/code&gt;
function passing the &lt;code&gt;data&lt;/code&gt; map values. If the resulting changeset is valid,
then it returns it. Otherwise, it calls the &lt;code&gt;add_data_errors/2&lt;/code&gt;, adding the
embedded errors to the &lt;code&gt;Item&lt;/code&gt; changeset. Let&amp;#39;s jump back to the interactive
shell and try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;book&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;, type: :book},
 errors: [author: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}],
 data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: false&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;event&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;, type: :event},
 errors: [location: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  end_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  start_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}], data:
  #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: false&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validations seem to be working just fine, let&amp;#39;s check out some valid data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;book&amp;quot;, data: %{author: &amp;quot;Foo&amp;quot;}})
#Ecto.Changeset&amp;lt;action: nil,
 changes: %{data: %{author: &amp;quot;Foo&amp;quot;}, name: &amp;quot;Foo&amp;quot;, type: :book}, errors: [],
 data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: true&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;event&amp;quot;, data: %{start_date: &amp;quot;2017-10-05&amp;quot;, end_date: &amp;quot;2017-10-07&amp;quot;, location: &amp;quot;Foo&amp;quot;}})
#Ecto.Changeset&amp;lt;action: nil,
 changes: %{data: %{end_date: &amp;quot;2017-10-07&amp;quot;, location: &amp;quot;Foo&amp;quot;,
     start_date: &amp;quot;2017-10-05&amp;quot;}, name: &amp;quot;Foo&amp;quot;, type: :event}, errors: [], data:
 #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works as expected, yay! However, we need a proper and reliable way of
testing this functionality correctly instead of trying it out in the
interactive shell. Speaking of which, I have started using &lt;a href="http://propertesting.com/"&gt;property-based
testing&lt;/a&gt; in the new project, and I&amp;#39;m very pleased
with the results so far. On the next part I would like to write about it,
and add some tests to what we have done today. In the meantime, what do you
think about the solution so far? Have you happened to run into a similar
problem? How did you solved it?&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elm and the outer world</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/05/15/elm-and-the-outer-world/"/>
    <id>http://codeloveandboards.com/blog/2017/05/15/elm-and-the-outer-world/</id>
    <published>2017-05-16T06:57:00Z</published>
    <updated>2017-10-04T07:36:08+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;em&gt;Huge thanks to my teammate &lt;a href="https://github.com/alvivi" target="_blank"&gt;Alvaro&lt;/a&gt; for the Elm masterclasses and his endless patience :)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;These have been very exciting weeks of development at &lt;a href="https://thebookofeveryone.com"&gt;The Book of Everyone&lt;/a&gt;. We have been migrating a crucial part of our core functionality to Elm. This hard work includes not only front-end stuff, but also other cool features like static assets downloading and caching, running server-side &lt;strong&gt;Elm&lt;/strong&gt; applications through &lt;strong&gt;Elixir&lt;/strong&gt; ports and &lt;strong&gt;Node&lt;/strong&gt;, and creating our &lt;strong&gt;Elm Native modules&lt;/strong&gt; for the not supported stuff. Before these weeks, &lt;strong&gt;Native modules&lt;/strong&gt; were something that I have not used before, so I would like to give you a small introduction to them, just in case you might find it useful in the future. But before, let&amp;#39;s start by understanding how &lt;strong&gt;Elm&lt;/strong&gt; communicates with external code.&lt;/p&gt;

&lt;h2&gt;Elm ports&lt;/h2&gt;

&lt;p&gt;If you are into &lt;strong&gt;Elm&lt;/strong&gt;, then you should probably know that an &lt;strong&gt;Elm&lt;/strong&gt; application is like a bulletproof box, where any interaction with the outside world needs to be done through a very specific API. If you want to communicate with external &lt;strong&gt;JavaScript&lt;/strong&gt; code from your application, you need to use &lt;strong&gt;Ports&lt;/strong&gt; to handle the incoming and outgoing messages. These ports have to be defined correctly as any other function in &lt;strong&gt;Elm&lt;/strong&gt;, so nothing weird happens to break the application. The problem with this is that your project is going to be tightly coupled to external code, which makes it difficult to share or reuse, especially when building libraries that might be included in other projects.&lt;/p&gt;

&lt;p&gt;To understand it better let&amp;#39;s build a very simple application which has an HTML file input, and that renders a preview of any selected image with it.&lt;/p&gt;

&lt;h3&gt;The setup&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s start by creating a new &lt;strong&gt;Elm&lt;/strong&gt; project by running the following command from your terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ elm package install elm-lang/html -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Starting downloads...

  ● elm-lang/html 2.0.0
  ● elm-lang/virtual-dom 2.0.4
  ● elm-lang/core 5.1.1

Packages configured successfully!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you check the folder&amp;#39;s content, you can find an &lt;code&gt;elm-stuff&lt;/code&gt; folder and a &lt;code&gt;elm-package.json&lt;/code&gt; file. Let&amp;#39;s open it to edit its content to be something similar to the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;summary&amp;quot;: &amp;quot;helpful summary of your project, less than 80 characters&amp;quot;,
    &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/user/project.git&amp;quot;,
    &amp;quot;license&amp;quot;: &amp;quot;BSD3&amp;quot;,
    &amp;quot;source-directories&amp;quot;: [
        &amp;quot;.&amp;quot;
    ],
    &amp;quot;exposed-modules&amp;quot;: [],
    &amp;quot;dependencies&amp;quot;: {
        &amp;quot;elm-lang/core&amp;quot;: &amp;quot;5.1.1 &amp;lt;= v &amp;lt; 6.0.0&amp;quot;,
        &amp;quot;elm-lang/html&amp;quot;: &amp;quot;2.0.0 &amp;lt;= v &amp;lt; 3.0.0&amp;quot;
    },
    &amp;quot;elm-version&amp;quot;: &amp;quot;0.18.0 &amp;lt;= v &amp;lt; 0.19.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I usually create an &lt;code&gt;src&lt;/code&gt; folder as the main directory of my project, so let&amp;#39;s update the config file to reflect this...&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
    ...

    &amp;quot;source-directories&amp;quot;: [
        &amp;quot;src&amp;quot;
    ],

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;...and create the &lt;em&gt;src&lt;/em&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next,  let&amp;#39;s create an &lt;em&gt;src/Main.elm&lt;/em&gt; file with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Main.elm

module Main exposing (main)

import Html exposing (Html, text)


main : Html msg
main =
    text &amp;quot;Hello, Elm!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are also going to create a very basic &lt;em&gt;src/index.html&lt;/em&gt; in which we are going to render the &lt;strong&gt;Elm&lt;/strong&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/index.html --&amp;gt;

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Elm FileReader&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      const elmDiv = document.querySelector(&amp;#39;#main&amp;#39;);

      if (elmDiv) {
        const app = Elm.Main.embed(elmDiv);
      }
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once these two files are ready, let&amp;#39;s build the project using Elm&amp;#39;s make:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ elm make --warn --debug src/Main.elm --output src/main.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can start Elm&amp;#39;s reactor by typing &lt;code&gt;elm reactor&lt;/code&gt; and visit &lt;a href="http://localhost:8000/src/index.html"&gt;http://localhost:8000/src/index.html&lt;/a&gt; to check that the &lt;code&gt;Hello, Elm!&lt;/code&gt; text gets displayed in our browser :)&lt;/p&gt;

&lt;h3&gt;Elm basic modules&lt;/h3&gt;

&lt;p&gt;Now that we have setup the project and we have checked that everything is working fine let&amp;#39;s start building the basic &lt;strong&gt;Elm Architecture&lt;/strong&gt; modules. The first of these modules is the &lt;code&gt;Model&lt;/code&gt;, so let&amp;#39;s add a new &lt;em&gt;src/Model.elm&lt;/em&gt; file with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Model.elm

module Model exposing (..)


type ImageData e s
    = NotLoaded
    | Loading
    | Error e
    | Success s


type alias Model =
    { imageData : ImageData String String }


initialModel : Model
initialModel =
    { imageData = NotLoaded }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The model consist of an &lt;code&gt;ImageData&lt;/code&gt; type which can have different values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NotLoaded&lt;/code&gt; for the initial state.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Loading&lt;/code&gt; for when the file is selected, and it calls the port for reading the file&amp;#39;s content.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Error r&lt;/code&gt; represents a failure while reading the file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Success s&lt;/code&gt; means that reading the file is successful, having its binary content.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let&amp;#39;s define a default message, by creating a &lt;em&gt;src/Messages.elm&lt;/em&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Messages.elm

module Messages exposing (Msg(..))

type Msg
    = NoOp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s do the same with the &lt;code&gt;Update&lt;/code&gt; module, to handle the &lt;code&gt;NoOp&lt;/code&gt; message:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Update.elm

module Update exposing (update)

import Messages exposing (Msg(..))
import Model exposing (..)


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        NoOp -&amp;gt;
            model ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we can create the &lt;code&gt;View&lt;/code&gt; module as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/View.elm

module View exposing (view)

import Html exposing (..)
import Html.Attributes exposing (..)
import Messages exposing (Msg(..))
import Model exposing (Model, ImageData(..))


view : Model -&amp;gt; Html Msg
view model =
    section
        [ sectionStyles ]
        [ imageView model.imageData
        , input
            [ type_ &amp;quot;file&amp;quot;
            , accept &amp;quot;image/*&amp;quot;
            ]
            []
        ]


sectionStyles : Html.Attribute Msg
sectionStyles =
    style
        [ ( &amp;quot;height&amp;quot;, &amp;quot;100vh&amp;quot; )
        , ( &amp;quot;display&amp;quot;, &amp;quot;flex&amp;quot; )
        , ( &amp;quot;justify-content&amp;quot;, &amp;quot;center&amp;quot; )
        , ( &amp;quot;align-items&amp;quot;, &amp;quot;center&amp;quot; )
        , ( &amp;quot;flex-direction&amp;quot;, &amp;quot;column&amp;quot; )
        ]


imageView : ImageData String String -&amp;gt; Html Msg
imageView imageData =
    case imageData of
        NotLoaded -&amp;gt;
            p
                []
                [ text &amp;quot;Choose an image file using the selector below...&amp;quot; ]

        Loading -&amp;gt;
            p

                [ text &amp;quot;Loading...&amp;quot; ]

        Error error -&amp;gt;
            p
                []
                [ text error ]

        Success binary -&amp;gt;
            img
                [ style
                    [ ( &amp;quot;max-height&amp;quot;, &amp;quot;300px&amp;quot; )
                    , ( &amp;quot;margin-bottom&amp;quot;, &amp;quot;3rem&amp;quot; )
                    ]
                , src binary
                ]
                []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please note that in the &lt;code&gt;imageView&lt;/code&gt; function we render the necessary HTML depending on the model&amp;#39;s &lt;code&gt;imageData&lt;/code&gt; current value, proving how convenient is using a union type as its value in this case.&lt;/p&gt;

&lt;p&gt;To wrap everything together let&amp;#39;s update the original &lt;code&gt;Main&lt;/code&gt; module, and make it look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Main.elm

module Main exposing (..)

import Html exposing (Html)
import Messages exposing (Msg(..))
import Model exposing (Model, initialModel)
import Update exposing (update)
import View exposing (view)


init : ( Model, Cmd Msg )
init =
    initialModel ! []


main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = (\_ -&amp;gt; Sub.none)
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check the result of these changes, build the project again and visit &lt;a href="http://localhost:8000/src/index.html"&gt;http://localhost:8000/src/index.html&lt;/a&gt;, seeing something similar to:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result 1" src="../../../../../images/blog/elm-native-modules/final-result-1-4dea1d1e.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s move on to the ports part. What we want to do is, once a file is selected, read its binary content using JavaScript&amp;#39;s &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader"&gt;FileReader&lt;/a&gt; object, and return it to the application to render the image. Having this in mind, let&amp;#39;s create an &lt;em&gt;src/Ports.elm&lt;/em&gt; file with the two different ports we need:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Ports.elm

port module Ports exposing (fileSelected, fileLoaded)

import Json.Decode as JD


-- Out ports


port fileSelected : JD.Value -&amp;gt; Cmd msg



-- In ports


port fileLoaded : (String -&amp;gt; msg) -&amp;gt; Sub msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fileSelected&lt;/code&gt; port gets triggered once we select a file using the input in the view, so let&amp;#39;s update the view to add the &lt;code&gt;on change&lt;/code&gt; event:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/View.elm

module View exposing (view)

import Html.Events exposing (on)
import Json.Decode as JD

-- ...

view : Model -&amp;gt; Html Msg
view model =
    section
        [ sectionStyles ]
        [ imageView model.imageData
        , input
            [ type_ &amp;quot;file&amp;quot;
            , accept &amp;quot;image/*&amp;quot;
            , on &amp;quot;change&amp;quot; &amp;lt;| JD.map FileSelected JD.value
            ]
            []
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The change event triggers a new &lt;code&gt;FileSelected&lt;/code&gt; message that we still need to define in the &lt;code&gt;Messages&lt;/code&gt; module, so let&amp;#39;s add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Messages.elm

module Messages exposing (Msg(..))

import Json.Decode as JD


type Msg
    = FileSelected JD.Value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have to edit as well the &lt;code&gt;Update&lt;/code&gt; module to handle the new message:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Update.elm

module Update exposing (update)

import Ports exposing (fileSelected)
-- ...


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        FileSelected event -&amp;gt;
            { model | imageData = Loading } ! [ fileSelected event ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;FileSelected&lt;/code&gt; message has the &lt;code&gt;event&lt;/code&gt;, which is sent through the port to the outer world, and to which we can now subscribe from the &lt;code&gt;index.html&lt;/code&gt; file, so let&amp;#39;s update it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="html"&gt;&amp;lt;!-- src/index.html --&amp;gt;

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Elm FileReader&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      const elmDiv = document.querySelector(&amp;#39;#main&amp;#39;);

      if (elmDiv) {
        const app = Elm.Main.embed(elmDiv);

        app.ports.fileSelected.subscribe(function (e) {
          const input = e.target;
          const file = input.files[0];
          const reader = new FileReader();

          reader.onload = (function (event) {
            const binary = event.target.result;

            console.log(&amp;#39;Binary size&amp;#39;, binary.length);

            app.ports.fileLoaded.send(binary);
          });

          reader.onerror = (function (err) {
            console.error(err);
          });

          reader.readAsDataURL(file);
        });
      }
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To receive messages from &lt;strong&gt;Elm&lt;/strong&gt;, we only need to subscribe to any of the defined ports. In this case &lt;code&gt;app.ports.fileSelected.subscribe&lt;/code&gt; receives the event triggered once selected the file, takes the file and using &lt;code&gt;FileReader&lt;/code&gt; tries to load the content. If it is successful, it logs through the console its length and sends the content through the previous defined &lt;code&gt;fileLoaded&lt;/code&gt; port. Let&amp;#39;s rebuild the project and refresh the browser to check if it works correctly:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result 2" src="../../../../../images/blog/elm-native-modules/final-result-2-9fb60b70.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;Cool, it seems to be working perfectly. However, we still need to handle the fileLoaded port to set the file content into the application&amp;#39;s model and render it. As in the &lt;strong&gt;JavaScript&lt;/strong&gt; side, &lt;strong&gt;Elm&lt;/strong&gt; handles external ports by subscribing to them, so let&amp;#39;s create a new &lt;em&gt;src/Subscriptions.elm&lt;/em&gt; file with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Subscriptions.elm

module Subscriptions exposing (subscriptions)

import Messages exposing (Msg(..))
import Model exposing (Model)
import Ports exposing (fileLoaded)


subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Sub.batch [ fileLoaded FileLoaded ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;#39;t forget about updating the &lt;code&gt;Main&lt;/code&gt; module, so it uses the &lt;code&gt;subscriptions&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Main.elm

module Main exposing (..)

import Subscriptions exposing (subscriptions)
-- ...


main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fileLoaded&lt;/code&gt; port will is going to be handled by a new &lt;code&gt;FileLoaded&lt;/code&gt; message with the content of the file, which we have to add to the &lt;code&gt;Messages&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Messages.elm

module Messages exposing (Msg(..))

-- ...


type Msg
    = FileSelected JD.Value
    | FileLoaded String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we have to edit the &lt;code&gt;Update&lt;/code&gt; module as well and implement the corresponding handler for it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Update.elm

module Update exposing (update)

-- ...

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        -- ...

        FileLoaded binary -&amp;gt;
            { model | imageData = Success binary } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting the &lt;code&gt;imageData&lt;/code&gt; key of the model as &lt;code&gt;Success&lt;/code&gt; with the content of the file makes the &lt;code&gt;view&lt;/code&gt; function render an image with that content as its &lt;code&gt;src&lt;/code&gt; attribute, displaying the selected image in the browser. Let&amp;#39;s rebuild the project and check it out:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result 3" src="../../../../../images/blog/elm-native-modules/final-result-3-16d298ec.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;It works, yay! In some cases, this is good enough. We have our application which depends on some ports to run properly, but as we do not need to use in any other place in the project, we can leave it like this. However, what if we want to reuse it somewhere else? It forces us, not only to take the &lt;strong&gt;Elm&lt;/strong&gt; code but the related &lt;strong&gt;JavaScript&lt;/strong&gt; as well, which in the new project might be handled very differently. Wouldn&amp;#39;t it better having that &lt;strong&gt;JavaScript&lt;/strong&gt; code encapsulated within the &lt;strong&gt;Elm&lt;/strong&gt; application itself?&lt;/p&gt;

&lt;h2&gt;Elm Native modules&lt;/h2&gt;

&lt;p&gt;Fortunately, &lt;strong&gt;Elm&lt;/strong&gt; has another way of dealing with external code, which is by using &lt;strong&gt;Native modules&lt;/strong&gt;. These modules, usually written in &lt;strong&gt;Javascript&lt;/strong&gt;, can be called from anywhere in your application instead of having to use ports. Some of the downsides are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Native API &lt;strong&gt;is not officially documented&lt;/strong&gt; and usually changes between different Elm versions making your application harder to upgrade and maintain.&lt;/li&gt;
&lt;li&gt;Elm applications using Native modules can make it have runtime errors due to relying on unsafe &lt;strong&gt;Javascript&lt;/strong&gt; code, also making it more difficult to debug.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although using custom &lt;strong&gt;Native modules&lt;/strong&gt; is not usually recommended for these (and more) reasons, sometimes it makes sense using them, so let&amp;#39;s refactor our application to remove the ports and move the external &lt;strong&gt;JavaScript&lt;/strong&gt; code to a &lt;strong&gt;Native&lt;/strong&gt; module.&lt;/p&gt;

&lt;h3&gt;The setup&lt;/h3&gt;

&lt;p&gt;The first thing we need to do is updating the the &lt;em&gt;elm-package.json&lt;/em&gt; file adding these two changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
    ...
    &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/bigardone/elm-file-reader.git&amp;quot;,
    &amp;quot;native-modules&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to add a proper &lt;code&gt;repository&lt;/code&gt; name, which is vital for defining Native modules, and we also have to tell &lt;strong&gt;Elm&lt;/strong&gt; that this project is going to use &lt;strong&gt;Native&lt;/strong&gt; modules by setting &lt;code&gt;native-modules&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;The Native module&lt;/h3&gt;

&lt;p&gt;Next, let&amp;#39;s create a new file in this path &lt;em&gt;src/Native/FileReader.js&lt;/em&gt; with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/Native/FileReader.js

var _bigardone$elm_file_reader$Native_FileReader = (function () {
  function readFile(e) {
    // Content here...
  }

  return {
    readFile,
  };
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here comes the tricky part. When compiling to &lt;strong&gt;Javascript&lt;/strong&gt;, &lt;strong&gt;Elm&lt;/strong&gt; takes the repository&amp;#39;s name and username specified in the &lt;em&gt;elm-package.json&lt;/em&gt; file to define the different functions, and this is the reason why naming your Native module this way is so important. Otherwise, it will not find your module at runtime. So we start by defining a &lt;code&gt;_bigardone$elm_file_reader$Native_FileReader&lt;/code&gt; function, where &lt;code&gt;_bighardone$elm_file_reader&lt;/code&gt; corresponds to the repository&amp;#39;s user name and name. The final &lt;code&gt;$Native_FileReader&lt;/code&gt; chunk of the name, corresponds to the module namespace, in this case, &lt;code&gt;Native.FileReader&lt;/code&gt;. We also declare a readFile function, in which we are going to implement the reading logic. Finally, we return an object with the exposed functions of this module.&lt;/p&gt;

&lt;p&gt;So far so good. Now let&amp;#39;s add the missing functionality:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// src/Native/FileReader.js

var _bigardone$elm_file_reader$Native_FileReader = (function () {
  function readFile(e) {
    return _elm_lang$core$Native_Scheduler.nativeBinding(function (cb) {
      var input = e.target;
      var file = input.files[0];
      var reader = new FileReader();

      reader.onload = (function (event) {
        var binary = event.target.result;

        console.log(&amp;#39;Binary size&amp;#39;, binary.length);

        cb(_elm_lang$core$Native_Scheduler.succeed(binary));
      });

      reader.onerror = (function (err) {
        cb(_elm_lang$core$Native_Scheduler.fail(err.toString()));
      });

      reader.readAsDataURL(file);
    });
  }

  return {
    readFile,
  };
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As reading a file is not only async but an impure action in &lt;strong&gt;Elm&lt;/strong&gt; terms, we have to use a &lt;code&gt;Task&lt;/code&gt; for it. That is why it returns a &lt;code&gt;_elm_lang$core$Native_Scheduler.nativeBinding&lt;/code&gt; that takes a callback to use it once the task finishes. The rest of the code is pretty similar to the ports version, except for the fact that instead of calling a port when is ready or there is an error, it returns the callback with either a &lt;code&gt;succeed&lt;/code&gt; or a &lt;code&gt;fail&lt;/code&gt; call to tell Elm&amp;#39;s runtime whether the task is successful or not.&lt;/p&gt;

&lt;h2&gt;Refactoring the existing modules&lt;/h2&gt;

&lt;p&gt;Once the native module is ready, let&amp;#39;s get rid of the old modules we do not need any more, which are &lt;code&gt;Ports&lt;/code&gt; and &lt;code&gt;Subscriptions&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm src/Ports.elm src/Subscriptions.elm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This change is going to break the build, so let&amp;#39;s update the &lt;code&gt;Main&lt;/code&gt; module to remove the corresponding imports and the subscriptions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Main.elm

module Main exposing (..)

-- ...

main : Program Never Model Msg
main =
    Html.program
        { init = init
        -- ...
        , subscriptions = (\_ -&amp;gt; Sub.none)
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same happens with the &lt;code&gt;Update&lt;/code&gt; module. We no longer have to use a port for reading the file content, so let&amp;#39;s edit it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Update.elm

module Update exposing (update)

-- ...
import Native.FileReader
import Task


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        FileSelected event -&amp;gt;
            { model | imageData = Loading } ! [ readFile event ]

        FileLoaded (Ok binary) -&amp;gt;
            { model | imageData = Success binary } ! []

        FileLoaded (Err error) -&amp;gt;
            { model | imageData = Error error } ! []


readFile : JD.Value -&amp;gt; Cmd Msg
readFile =
    Native.FileReader.readFile &amp;gt;&amp;gt; Task.attempt FileLoaded
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;FileSelected event&lt;/code&gt; message, along with the model, it now returns the &lt;code&gt;readFile event&lt;/code&gt; command, which uses the new &lt;code&gt;Native.FileReader.readFile&lt;/code&gt; function defined previously to read the selected file&amp;#39;s content. As it is an asynchronous action and it might fail, we use &lt;code&gt;Task.attempt&lt;/code&gt; to call it, passing the &lt;code&gt;FileLoaded&lt;/code&gt; message to handle the result of the task, setting the content in the model when succeeds or the error when it fails. Changing this, forces us to change as well the &lt;code&gt;Messages&lt;/code&gt; module to add this new message type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- src/Messages.elm


module Messages exposing (Msg(..))

import Json.Decode as JD


type Msg
    = FileSelected JD.Value
    | FileLoaded (Result String String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new &lt;code&gt;FileLoaded&lt;/code&gt; type consists of a &lt;code&gt;Result&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; for the error and another &lt;code&gt;String&lt;/code&gt; for the binary content of the file. If we build the project again with &lt;code&gt;elm make --warn --debug src/Main.elm --output src/main.js&lt;/code&gt;, start the  reactor with &lt;code&gt;elm reactor&lt;/code&gt; and visit &lt;a href="http://localhost:8000/src/index.html"&gt;http://localhost:8000/src/index.html&lt;/a&gt;, everything should be working as before:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result 4" src="../../../../../images/blog/elm-native-modules/final-result-4-8ec3925b.jpg" /&gt;&lt;/p&gt;

&lt;p&gt;And in fact it does, yay! Now our Elm application doesn&amp;#39;t depend on the JavaScript in the &lt;em&gt;index.htlm&lt;/em&gt; to work. Moreover, if we visit &lt;a href="http://localhost:8000/src/Main.elm"&gt;http://localhost:8000/src/Main.elm&lt;/a&gt; in our browser, which runs the Elm code without the JavaScript in the index.html file, everything works perfectly.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;While building &lt;strong&gt;Elm&lt;/strong&gt; applications, it is very common to use external &lt;strong&gt;JavaScript&lt;/strong&gt; at some point. Ports are the official and safe way to go, but sometimes you need to encapsulate that external code in your application&amp;#39;s core, and for that you can use &lt;strong&gt;Native modules&lt;/strong&gt;, always knowing the drawbacks and at your own risk.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a class="btn" href="https://github.com/bigardone/elm-file-reader" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
  &lt;a class="btn" href="https://github.com/bigardone/elm-file-reader/ports" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Ports version source code&lt;/a&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix and Elm, a real use case (pt. 6)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/03/19/phoenix-and-elm-a-real-use-case-pt-6/"/>
    <id>http://codeloveandboards.com/blog/2017/03/19/phoenix-and-elm-a-real-use-case-pt-6/</id>
    <published>2017-03-20T06:30:00Z</published>
    <updated>2017-05-02T09:59:24+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix and Elm, a real use case&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/02/phoenix-and-elm-a-real-use-case-pt-1/"&gt;Introduction to creating a SPA with Phoenix and Elm&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/08/phoenix-and-elm-a-real-use-case-pt-2/"&gt;Rendering the initial contact list&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/14/phoenix-and-elm-a-real-use-case-pt-3/"&gt;Adding full text search and pagination navigation to the contact list&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/23/phoenix-and-elm-a-real-use-case-pt-4/"&gt;Better state with union types, search resetting and keyed nodes.&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/03/07/phoenix-and-elm-a-real-use-case-pt-5/"&gt;Implementing Elm routing&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/03/19/phoenix-and-elm-a-real-use-case-pt-6/"&gt;Poenix and Elm communication through WebSockets&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://phoenix-and-elm.herokuapp.com/" target="_blank"&gt;&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; Live demo&lt;/a&gt; |
  &lt;a href="https://github.com/bigardone/phoenix-and-elm" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;h2&gt;Phoenix and Elm WebSockets support&lt;/h2&gt;

&lt;p&gt;In the &lt;a href="/blog/2017/03/07/phoenix-and-elm-a-real-use-case-pt-5/"&gt;last part&lt;/a&gt;, we refactored our application to add &lt;strong&gt;Elm&lt;/strong&gt; routing and added the show contact route.
These changes include adding a new API endpoint in the &lt;code&gt;ContactController&lt;/code&gt; module to return a given contact&amp;#39;s JSON representation.
However, since I started using &lt;strong&gt;Phoenix&lt;/strong&gt;, I have found myself using fewer controllers, and more
&lt;strong&gt;WebSockets&lt;/strong&gt; and &lt;strong&gt;Phoenix&amp;#39;s&lt;/strong&gt; channels. The main reasons for doing this are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are much faster than Http requests.&lt;/li&gt;
&lt;li&gt;Once the connection is established, and the authentication is accomplished, you do not need to authenticate future requests and rely on cookies for it.&lt;/li&gt;
&lt;li&gt;Its &lt;strong&gt;PubSub&lt;/strong&gt; system opens a new world of possibilities.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That being said, today we are going to replace the current &lt;strong&gt;API&lt;/strong&gt; controller we have with a new
&lt;strong&gt;Phoenix&lt;/strong&gt; &lt;strong&gt;channel&lt;/strong&gt; and learn how to add support for this new channel in &lt;strong&gt;Elm&lt;/strong&gt;. Let&amp;#39;s do this!&lt;/p&gt;

&lt;h3&gt;Phoenix changes&lt;/h3&gt;

&lt;p&gt;First of all, let&amp;#39;s get rid of what we are not going to need anymore. This includes deleting the &lt;code&gt;ContactContoller&lt;/code&gt; file, located in &lt;code&gt;web/controllers/contact_controller.ex&lt;/code&gt;
and the &lt;code&gt;ContactView&lt;/code&gt; in &lt;code&gt;web/views/contact_view.ex&lt;/code&gt;. We also need to update the &lt;code&gt;router&lt;/code&gt; file to remove the &lt;strong&gt;API&lt;/strong&gt; pipeline:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# web/router.ex

defmodule PhoenixAndElm.Router do
  use PhoenixAndElm.Web, :router

  pipeline :browser do
    plug :accepts, [&amp;quot;html&amp;quot;]
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  scope &amp;quot;/&amp;quot;, PhoenixAndElm do
    pipe_through :browser # Use the default browser stack

    get &amp;quot;/*path&amp;quot;, PageController, :index
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have removed the unnecessary stuff, let&amp;#39;s create the channel which is going to replace the old &lt;code&gt;ContactController&lt;/code&gt;.
First, we need to declare it in the &lt;code&gt;UserSocket&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# web/channels/user_socket.ex

defmodule PhoenixAndElm.UserSocket do
  use Phoenix.Socket

  ## Channels
  channel &amp;quot;contacts&amp;quot;, PhoenixAndElm.ContactsChannel

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next step is to create the &lt;code&gt;ContactsChannel&lt;/code&gt; module in the same folder:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# web/channels/contacts_channel.ex

defmodule PhoenixAndElm.ContactsChannel do
  use Phoenix.Channel
  alias PhoenixAndElm.{Contact, Repo}
  import Ecto.Query, only: [order_by: 2]

  require Logger

  def join(&amp;quot;contacts&amp;quot;, _, socket), do: {:ok, socket}

  def handle_in(&amp;quot;contacts:fetch&amp;quot;, params, socket) do
    Logger.info &amp;quot;Handling contacts...&amp;quot;

    search = Map.get(params, &amp;quot;search&amp;quot;) || &amp;quot;&amp;quot;

    page = Contact
    |&amp;gt; Contact.search(search)
    |&amp;gt; order_by(:first_name)
    |&amp;gt; Repo.paginate(params)

    {:reply, {:ok, page}, socket}
  end

  def handle_in(&amp;quot;contact:&amp;quot; &amp;lt;&amp;gt; contact_id, _, socket) do
    Logger.info &amp;quot;Handling contact...&amp;quot;

    contact = Contact
    |&amp;gt; Repo.get(contact_id)

    case contact do
      nil -&amp;gt;
        {:reply, {:error, %{error: &amp;quot;Contact no found&amp;quot;}}, socket}
      _ -&amp;gt;
        {:reply, {:ok, contact}, socket}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ContactsChannel&lt;/code&gt; handles two events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;contacts:fetch&lt;/code&gt; wich handles contact search and pagination like the old index action of the &lt;code&gt;ContactController&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contacts:id&lt;/code&gt; which returns a given contact&amp;#39;s data, just like the old show action.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on the environment the application is running, the socket &lt;strong&gt;URL&lt;/strong&gt; will probably change.
The front-end application needs to know the &lt;strong&gt;URL&lt;/strong&gt; to create the connection, so we need it to pass it somehow.
The easiest way of doing so is by creating a helper method in a &lt;strong&gt;Phoenix&lt;/strong&gt; view and call it to assign it to javascript
globally. Let&amp;#39;s add the helper method in the &lt;code&gt;LayoutView&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# web/views/layout_view.ex

defmodule PhoenixAndElm.LayoutView do
  use PhoenixAndElm.Web, :view

  def socket_url, do: System.get_env(&amp;quot;WEBSOCKECT_URL&amp;quot;) || &amp;quot;ws://localhost:4000/socket/websocket&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;socket_url&lt;/code&gt; function returns the value in the &lt;code&gt;WEBSOCKECT_URL&lt;/code&gt; system variable, or the default one if not set. Now we can update
the main template file to call this function and set value in javascript:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# web/templates/layout/app.html.eex

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  # ...

  &amp;lt;body&amp;gt;
    # ...

    &amp;lt;script&amp;gt;window.socketUrl = &amp;#39;&amp;lt;%= PhoenixAndElm.LayoutView.socket_url %&amp;gt;&amp;#39;;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/js/app.js&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the &lt;code&gt;socketUrl&lt;/code&gt; value is set, we can use it in the &lt;code&gt;app.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// web/static/js/app.js

import Elm from &amp;#39;./main&amp;#39;;

const elmDiv = document.querySelector(&amp;#39;#elm_target&amp;#39;);

if (elmDiv) {
  const socketUrl = window.socketUrl;

  Elm.Main.embed(elmDiv, { socketUrl });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, but how does &lt;strong&gt;Elm&lt;/strong&gt; handle this values?&lt;/p&gt;

&lt;h3&gt;Program with flags&lt;/h3&gt;

&lt;p&gt;Conveniently, &lt;strong&gt;Elm&lt;/strong&gt; has the concept of flags which are values that can be received from &lt;strong&gt;JavaScript&lt;/strong&gt; while
creating the application. To use flags, we need to do some refactoring in the application, so let&amp;#39;s start by editing the &lt;code&gt;Main&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Main.elm

module Main exposing (..)

-- ...

init : Flags -&amp;gt; Navigation.Location -&amp;gt; ( Model, Cmd Msg )
init flags location =
    let
        currentRoute =
            parse location

        model =
            initialModel flags currentRoute
    in
        urlUpdate model


main : Program Flags Model Msg
main =
    Navigation.programWithFlags UrlChange
        { init = init
        , view = view
        , update = update
        , subscriptions = always &amp;lt;| Sub.none
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;main&lt;/code&gt; function now has a Flags type in its definition, that is passed to the init function and from
there to the &lt;code&gt;initialModel&lt;/code&gt;. Let&amp;#39;s move on to the &lt;code&gt;Model&lt;/code&gt; module to implement this type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt; -- web/elm/Model.elm

 module Model exposing (..)

 -- ...

type alias Flags =
    { socketUrl : String }


type alias Model =
    { -- ---
    , flags : Flags
    }


initialModel : Flags -&amp;gt; Route -&amp;gt; Model
initialModel flags route =
    { -- ...
    , flags = flags
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Flags&lt;/code&gt; type is a record containing a &lt;code&gt;socketUrl&lt;/code&gt; key. As we want to initialize this value with the flags
received from javascript, we pass it to the &lt;code&gt;initialModel&lt;/code&gt; function. If we now refresh the browser and take a closer
look at the debugger history, we can see how the flags key is already set:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix_and_elm/flags.jpg" alt="Flags" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Now we are ready to start implementing the socket communication between the &lt;strong&gt;Elm&lt;/strong&gt; program and the &lt;strong&gt;Phoenix&lt;/strong&gt; backend.&lt;/p&gt;

&lt;h3&gt;The elm-phoenix package&lt;/h3&gt;

&lt;p&gt;There are many different ways to add &lt;strong&gt;WebSockets&lt;/strong&gt; support in &lt;strong&gt;Elm&lt;/strong&gt;, but my favorite one so far is using the &lt;a href="https://github.com/saschatimme/elm-phoenix"&gt;elm-phoenix&lt;/a&gt;
package.
This package is an effect manager, so at the moment is not in the elm package repository. Therefore, its installation can
be tricky depending on your &lt;strong&gt;Phoenix&lt;/strong&gt; configuration, so easiest way I have found is by &lt;a href="https://github.com/saschatimme/elm-phoenix/archive/master.zip"&gt;downloading&lt;/a&gt; it and
adding the source files into a vendor folder. Before doing this, let&amp;#39;s move all of our &lt;strong&gt;Elm&lt;/strong&gt; module files into a
new &lt;code&gt;web/elm/src&lt;/code&gt; folder. After doing it, it should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web/elm
├── elm-package.json
├── elm-stuff
└── src
    ├── Commands.elm
    ├── Common
    │   └── View.elm
    ├── Contact
    │   └── View.elm
    ├── ContactList
    │   └── View.elm
    ├── Decoders.elm
    ├── Main.elm
    ├── Messages.elm
    ├── Model.elm
    ├── Routing.elm
    ├── Update.elm
    └── View.elm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, create a new &lt;code&gt;web/elm/vendor&lt;/code&gt; folder and copy there the &lt;code&gt;elm-phoenix&lt;/code&gt; source files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web/elm
├── elm-package.json
├── elm-stuff
├── src
└── vendor
    ├── Phoenix
    │   ├── Channel.elm
    │   ├── Internal
    │   │   ├── Channel.elm
    │   │   ├── Helpers.elm
    │   │   ├── Message.elm
    │   │   └── Socket.elm
    │   ├── Push.elm
    │   └── Socket.elm
    └── Phoenix.elm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have to make the &lt;strong&gt;Elm&lt;/strong&gt; compiler aware of these changes, so let&amp;#39;s update the &lt;code&gt;elm-package.json&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;// web/elm/elm-package.json

{
    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
    &amp;quot;summary&amp;quot;: &amp;quot;helpful summary of your project, less than 80 characters&amp;quot;,
    &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/user/project.git&amp;quot;,
    &amp;quot;license&amp;quot;: &amp;quot;BSD3&amp;quot;,
    &amp;quot;source-directories&amp;quot;: [
        &amp;quot;./src&amp;quot;,
        &amp;quot;./vendor&amp;quot;
    ],
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to change &lt;strong&gt;Brunch&amp;#39;s&lt;/strong&gt; configuration; otherwise, the build is not going to succeed:&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;// brunch-config.js

exports.config = {
  // ...

  // Configure your plugins
  plugins: {
    // ...

    elmBrunch: {
      elmFolder: &amp;#39;web/elm&amp;#39;,
      mainModules: [&amp;#39;src/Main.elm&amp;#39;],
      outputFolder: &amp;#39;../static/js&amp;#39;,
      makeParameters: [&amp;#39;--debug&amp;#39;],
    },

    //...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;code&gt;elm-phoenix&lt;/code&gt; depends on the &lt;a href="http://package.elm-lang.org/packages/elm-lang/websocket/latest"&gt;elm-lang/websocket&lt;/a&gt; package, so let&amp;#39;s install it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd web/elm &amp;amp;&amp;amp; elm-package install elm-lang/websocket -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After doing this and restarting the &lt;strong&gt;Phoenix&lt;/strong&gt; server, everything should be working as before. In case it does not, here is the &lt;a href="https://github.com/bigardone/phoenix-and-elm/commit/03bc44cf6c4465e650b1412c4571012200664606"&gt;commit&lt;/a&gt;
with all these changes.&lt;/p&gt;

&lt;h3&gt;The Subscriptions module&lt;/h3&gt;

&lt;p&gt;In order to listen to external input, such as mouse events or location changes, &lt;strong&gt;Elm&lt;/strong&gt; uses subscriptions. In our case, as we are using &lt;code&gt;elm-phoenix&lt;/code&gt;, we want
to handle &lt;strong&gt;WebSockets&lt;/strong&gt; events and make the application respond to them. Let&amp;#39;s create a new &lt;code&gt;Subscriptions&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/src/Subscriptions.elm

module Subscriptions exposing (..)

import Messages exposing (Msg(..))
import Model exposing (Model)
import Phoenix
import Phoenix.Channel as Channel exposing (Channel)
import Phoenix.Socket as Socket exposing (Socket)


subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Phoenix.connect (socket model.flags.socketUrl) [ contacts ]


socket : String -&amp;gt; Socket Msg
socket socketUrl =
    Socket.init socketUrl


contacts : Channel Msg
contacts =
    Channel.init &amp;quot;contacts&amp;quot;
        |&amp;gt; Channel.withDebug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;subscriptions&lt;/code&gt; function prepares the socket and the channel we want to join, using the program&amp;#39;s
flags to set the &lt;code&gt;socketUrl&lt;/code&gt;. In our case, we only have a single channel, so we do not need to add extra
configuration to check which channel or channels it has to join, but if you feel curious about how
to join multiple channels, there is an excellent &lt;a href="https://github.com/saschatimme/elm-phoenix/blob/master/example/web/elm/src/Chat.elm#L233"&gt;demo example&lt;/a&gt; in the official repo. In our case, we
are good to continue, so let&amp;#39;s update the &lt;code&gt;Main&lt;/code&gt; module, so the main program uses the new &lt;code&gt;subscriptions&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/src/Main.elm

module Main exposing (..)

import Subscriptions exposing (subscriptions)

-- ...

main : Program Flags Model Msg
main =
    Navigation.programWithFlags UrlChange
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we refresh the browser and check our browser&amp;#39;s console, we can see two log messages, one when the program tries to join the &lt;code&gt;ContactsChannel&lt;/code&gt; and
another one when the join result is successful:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix_and_elm/socket-connect.jpg" alt="Socket connection" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h3&gt;Commands refactoring&lt;/h3&gt;

&lt;p&gt;Now that we have the connection to the &lt;strong&gt;WebSocket&lt;/strong&gt; ready, we need to refactor the &lt;code&gt;Commands&lt;/code&gt; module to replace the old &lt;strong&gt;Http&lt;/strong&gt; requests with &lt;code&gt;WebSocket&lt;/code&gt; ones:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/src/Commands.elm

module Commands exposing (..)

import Phoenix exposing (..)
import Phoenix.Push as Push
-- ...

fetch : String -&amp;gt; Int -&amp;gt; String -&amp;gt; Cmd Msg
fetch socketUrl page search =
    let
        payload =
            JE.object
                [ ( &amp;quot;page&amp;quot;, JE.int page )
                , ( &amp;quot;search&amp;quot;, JE.string search )
                ]

        push =
            Push.init &amp;quot;contacts&amp;quot; &amp;quot;contacts:fetch&amp;quot;
                |&amp;gt; Push.withPayload payload
                |&amp;gt; Push.onOk FetchSuccess
                |&amp;gt; Push.onError FetchError
    in
        Phoenix.push socketUrl push


fetchContact : String -&amp;gt; Int -&amp;gt; Cmd Msg
fetchContact socketUrl id =
    let
        push =
            Push.init &amp;quot;contacts&amp;quot; (&amp;quot;contact:&amp;quot; ++ toString id)
                |&amp;gt; Push.onOk FetchContactSuccess
                |&amp;gt; Push.onError FetchContactError
    in
        Phoenix.push socketUrl push
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fetch&lt;/code&gt; function now receives one more parameter with the &lt;code&gt;socketUrl&lt;/code&gt; value that it is going to need to send
the request. It first creates a &lt;strong&gt;JSON&lt;/strong&gt; payload with the page and search, just like the old &lt;strong&gt;Http&lt;/strong&gt; one. Next, it creates
a &lt;code&gt;push&lt;/code&gt;, from the &lt;code&gt;elm-phoenix&lt;/code&gt; package, in which passes the &lt;strong&gt;Phoenix&amp;#39;s&lt;/strong&gt; channel name and the event, in this case &lt;code&gt;contacts:fetch&lt;/code&gt;.
It attaches the previously created payload using &lt;code&gt;withPayload&lt;/code&gt; and sets the messages for both the &lt;code&gt;onOk&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt; callbacks,
triggered depending on the result. Finally, it sends the push to the &lt;code&gt;socketUrl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On the other hand, &lt;code&gt;fetchContact&lt;/code&gt; is more simple. It creates a &lt;code&gt;push&lt;/code&gt; to the same channel, but for the &lt;code&gt;contact:*&lt;/code&gt; where &lt;code&gt;*&lt;/code&gt; is the id of the contact we want to fetch. It only sets the
messages for the &lt;code&gt;onOk&lt;/code&gt; and &lt;code&gt;onError&lt;/code&gt; callbacks, and finally sends the push through the &lt;code&gt;socketUrl&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Messages and the Update module&lt;/h3&gt;

&lt;p&gt;At this point, the compiler must be some errors related to the new messages we have added in the &lt;code&gt;Commands&lt;/code&gt; module, but we have not declared it yet. So let&amp;#39;s edit
the &lt;code&gt;Messages&lt;/code&gt; module to fix this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/src/Messages.elm

module Messages exposing (..)

import Json.Encode as JE
import Navigation
import Routing exposing (Route)


type Msg
    -- Remove this -&amp;gt; = FetchResult (Result Http.Error ContactList)
    = FetchSuccess JE.Value          -- Add this
    | FetchError JE.Value            -- Add this
    | Paginate Int
    | HandleSearchInput String
    | HandleFormSubmit
    | ResetSearch
    | UrlChange Navigation.Location
    | NavigateTo Route
    -- Remove this -&amp;gt; | FetchContactResult (Result Http.Error Contact)
    | FetchContactSuccess JE.Value   -- Add this
    | FetchContactError JE.Value     -- Add this
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous &lt;code&gt;FetchResult&lt;/code&gt; was receiving a &lt;code&gt;Result&lt;/code&gt;, but now both success and error callbacks, which receive a &lt;strong&gt;JSON&lt;/strong&gt; value,
which need to be decoded by the &lt;code&gt;update&lt;/code&gt; function, and we also need to update the commands calls to pass the &lt;code&gt;socketUrl&lt;/code&gt; parameter,
so let&amp;#39;s edit the &lt;code&gt;Update&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/src/Update.elm

module Update exposing (..)

-- ...

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        FetchSuccess raw -&amp;gt;
            case JD.decodeValue contactListDecoder raw of
                Ok payload -&amp;gt;
                    { model | contactList = Success payload } ! []

                Err err -&amp;gt;
                    { model | contactList = Failure &amp;quot;Error while decoding contact list&amp;quot; } ! []

        FetchError raw -&amp;gt;
            { model | contactList = Failure &amp;quot;Error while fetching contact list&amp;quot; } ! []

        Paginate pageNumber -&amp;gt;
            model ! [ fetch model.flags.socketUrl pageNumber model.search ]

        -- ...

        HandleFormSubmit -&amp;gt;
            { model | contactList = Requesting } ! [ fetch model.flags.socketUrl 1 model.search ]

        ResetSearch -&amp;gt;
            { model | search = &amp;quot;&amp;quot; } ! [ fetch model.flags.socketUrl 1 &amp;quot;&amp;quot; ]

        -- ...

        FetchContactSuccess raw -&amp;gt;
            case JD.decodeValue contactDecoder raw of
                Ok payload -&amp;gt;
                    { model | contact = Success payload } ! []

                Err err -&amp;gt;
                    { model | contact = Failure &amp;quot;Error while decoding contact&amp;quot; } ! []

        FetchContactError raw -&amp;gt;
            { model | contact = Failure &amp;quot;Contact not found&amp;quot; } ! []

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both &lt;code&gt;FetchSuccess&lt;/code&gt; and &lt;code&gt;FetchContactSuccess&lt;/code&gt; branches decode the &lt;code&gt;raw&lt;/code&gt; response received from the channel and, depending on the result,
set the corresponding key value in the new model. On the other hand, &lt;code&gt;FetchError&lt;/code&gt; and &lt;code&gt;FetchContactError&lt;/code&gt; set a friendly error message.
We are missing one thing, though; the &lt;code&gt;urlUpdate&lt;/code&gt; function needs some minor editing as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/src/Update.elm

module Update exposing (..)

-- ...

urlUpdate : Model -&amp;gt; ( Model, Cmd Msg )
urlUpdate model =
    case model.route of
        HomeIndexRoute -&amp;gt;
            case model.contactList of
                NotRequested -&amp;gt;
                    model ! [ fetch model.flags.socketUrl 1 &amp;quot;&amp;quot; ]

                _ -&amp;gt;
                    model ! []

        ShowContactRoute id -&amp;gt;
            { model | contact = Requesting } ! [ fetchContact model.flags.socketUrl id ]

        _ -&amp;gt;
            model ! []

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is pretty much it. If we now refresh the browser and navigate through the application, everything should just work as before.
Yay! If you are missing anything, please check out the branch I have prepared with all the changes for this part.
I hope you have enjoyed the series and thanks for all the support.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://phoenix-and-elm.herokuapp.com/" target="_blank" class="btn"&gt;&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; Live demo&lt;/a&gt;
  &lt;a href="https://github.com/bigardone/phoenix-and-elm" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix and Elm, a real use case (pt. 5)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/03/07/phoenix-and-elm-a-real-use-case-pt-5/"/>
    <id>http://codeloveandboards.com/blog/2017/03/07/phoenix-and-elm-a-real-use-case-pt-5/</id>
    <published>2017-03-08T06:32:00Z</published>
    <updated>2017-04-22T07:33:20+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix and Elm, a real use case&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/02/phoenix-and-elm-a-real-use-case-pt-1/"&gt;Introduction to creating a SPA with Phoenix and Elm&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/08/phoenix-and-elm-a-real-use-case-pt-2/"&gt;Rendering the initial contact list&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/14/phoenix-and-elm-a-real-use-case-pt-3/"&gt;Adding full text search and pagination navigation to the contact list&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/02/23/phoenix-and-elm-a-real-use-case-pt-4/"&gt;Better state with union types, search resetting and keyed nodes.&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/03/07/phoenix-and-elm-a-real-use-case-pt-5/"&gt;Implementing Elm routing&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/03/19/phoenix-and-elm-a-real-use-case-pt-6/"&gt;Poenix and Elm communication through WebSockets&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://phoenix-and-elm.herokuapp.com/" target="_blank"&gt;&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; Live demo&lt;/a&gt; |
  &lt;a href="https://github.com/bigardone/phoenix-and-elm" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;h2&gt;Implementing Elm routing&lt;/h2&gt;

&lt;p&gt;In the &lt;a href="/blog/2017/02/23/phoenix-and-elm-a-real-use-case-pt-4/"&gt;previous part&lt;/a&gt;, we did some enhancements to our contact list application. These changes include
union types in the model to represent more precisely what is the current state of the application,
resetting the search result and using keyed Html nodes for a more efficient rendering. Today we are
going to go a step further and implement the contact detail page, which a user can visit by clicking
on any of the contact cards. Let&amp;#39;s do this!&lt;/p&gt;

&lt;h3&gt;Phoenix changes&lt;/h3&gt;

&lt;p&gt;In regards to the backend, we need our &lt;strong&gt;API&lt;/strong&gt; to have a new route like &lt;code&gt;/api/contacts/:id&lt;/code&gt; which
returns the &lt;strong&gt;JSON&lt;/strong&gt; representation of the contact corresponding to that id. Let&amp;#39;s start by adding
the new show action to the &lt;code&gt;router.ex&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# web/router.ex

defmodule PhoenixAndElm.Router do
  use PhoenixAndElm.Web, :router

  # ...

  scope &amp;quot;/api&amp;quot;, PhoenixAndElm do
    pipe_through :api

    resources &amp;quot;/contacts&amp;quot;, ContactController, only: [:index, :show]
  end

  # ...

  scope &amp;quot;/&amp;quot;, PhoenixAndElm do
    pipe_through :browser # Use the default browser stack

    get &amp;quot;/*path&amp;quot;, PageController, :index
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take note that we are handling any route that doesn&amp;#39;t belong to the &lt;strong&gt;API&lt;/strong&gt; pipe with the &lt;code&gt;PageController&lt;/code&gt;.
The reason for this is that we want to handle all the &lt;strong&gt;URLs&lt;/strong&gt; from the frontend. Once this is ready,
let&amp;#39;s update the &lt;code&gt;ContactController&lt;/code&gt; module to add the action:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# web/controllers/contact_controller.ex

defmodule PhoenixAndElm.ContactController do
  use PhoenixAndElm.Web, :controller

  # ...

  def show(conn, %{&amp;quot;id&amp;quot; =&amp;gt; id}) do
    contact = Repo.get(Contact, id)

    render conn, contact: contact
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to update the &lt;code&gt;ContactView&lt;/code&gt; module to handle the corresponding response:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# web/views/contact_view.ex

defmodule PhoenixAndElm.ContactView do
  use PhoenixAndElm.Web, :view

  # ...

  def render(&amp;quot;show.json&amp;quot;, %{contact: contact}), do: contact
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these changes our backend is ready, so if we visit &lt;a href="http://localhost:4000/api/contacts/id"&gt;http://localhost:4000/api/contacts/id&lt;/a&gt; where
id corresponds to an existing contact id, we should see the following &lt;strong&gt;JSON&lt;/strong&gt; response in the browser:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
  picture: &amp;quot;http://api.randomuser.me/portraits/women/1.jpg&amp;quot;,
  phone_number: &amp;quot;761/266-1174&amp;quot;,
  location: &amp;quot;Denmark&amp;quot;,
  last_name: &amp;quot;Heaney&amp;quot;,
  id: 180,
  headline: &amp;quot;Est repellat omnis.&amp;quot;,
  gender: 1,
  first_name: &amp;quot;Axel&amp;quot;,
  email: &amp;quot;axel@green.org&amp;quot;,
  birth_date: &amp;quot;1975-11-03&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The Routing module&lt;/h3&gt;

&lt;p&gt;To implement routing in &lt;strong&gt;Elm&lt;/strong&gt;, we are going to need two additional packages for handling browser location
changes and routes matching. These packages are &lt;a href="http://package.elm-lang.org/packages/elm-lang/navigation/2.1.0"&gt;Elm Navigation&lt;/a&gt;
and &lt;a href="http://package.elm-lang.org/packages/evancz/url-parser/2.0.1"&gt;UrlParser&lt;/a&gt;, so let&amp;#39;s install them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;elm package install elm-lang/navigation -y
elm package install evancz/url-parser -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we are going to define the &lt;code&gt;Routing&lt;/code&gt; &lt;strong&gt;Elm&lt;/strong&gt; module, with all the functionality in regards to parsing
the browser location and matching the routes of our application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Routing.elm

module Routing exposing (..)

import Navigation
import UrlParser exposing (..)


type Route
    = HomeIndexRoute
    | NotFoundRoute


matchers : Parser (Route -&amp;gt; a) a
matchers =
    oneOf
        [ map HomeIndexRoute &amp;lt;| s &amp;quot;&amp;quot;
        ]


parse : Navigation.Location -&amp;gt; Route
parse location =
    case UrlParser.parsePath matchers location of
        Just route -&amp;gt;
            route

        Nothing -&amp;gt;
            NotFoundRoute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start by creating a new union type named &lt;code&gt;Route&lt;/code&gt;, which contains all of the possible routes of our application:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HomeIndexRoute&lt;/code&gt;, for the contact list.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotFoundRoute&lt;/code&gt;, for any other route.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Next we define the matchers function which matches the current browser&amp;#39;s location with our previously described routes,
and for the time being, we only need to map &lt;code&gt;/&lt;/code&gt; to &lt;code&gt;HomeIndexRoute&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, the &lt;code&gt;parse&lt;/code&gt; function takes the location and returns the corresponding route using the &lt;code&gt;matchers&lt;/code&gt;
function, returning &lt;code&gt;NotFoundRoute&lt;/code&gt; when the location does not correspond to any of the matched routes.&lt;/p&gt;

&lt;h3&gt;Handling Url changes&lt;/h3&gt;

&lt;p&gt;To handle these changes, we have to make some refactoring in our existing modules. The first of these changes
is in the Main module, where instead o using &lt;code&gt;Html.program&lt;/code&gt; we have to wrap our initial application in a &lt;code&gt;Navigation.program&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Main.elm

module Main exposing (..)

import Messages exposing (Msg(..))
import Model exposing (..)
import Navigation
import Routing exposing (parse)
import Update exposing (..)
import View exposing (view)


init : Navigation.Location -&amp;gt; ( Model, Cmd Msg )
init location =
    let
        currentRoute =
            parse location

        model =
            initialModel currentRoute
    in
        urlUpdate model


main : Program Never Model Msg
main =
    Navigation.program UrlChange
        { init = init
        , view = view
        , update = update
        , subscriptions = always &amp;lt;| Sub.none
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Navigation.program&lt;/code&gt; takes a new &lt;code&gt;UrlChange&lt;/code&gt; parameter which is a new message triggered every time the &lt;strong&gt;URL&lt;/strong&gt; changes,
and the init function takes the current location, parses it to a known route and sets it in the model using the &lt;code&gt;initialModel&lt;/code&gt; function,
returning the &lt;code&gt;urlUpdate&lt;/code&gt; function response. These are many changes so let&amp;#39;s start by updating the &lt;code&gt;Model&lt;/code&gt; to add the current route:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Model.elm

module Model exposing (..)

import Routing exposing (Route)

-- ...

type alias Model =
    { contactList : RemoteData String ContactList
    , search : String
    , route : Route
    }

-- ...

initialModel : Route -&amp;gt; Model
initialModel route =
    { contactList = NotRequested
    , search = &amp;quot;&amp;quot;
    , route = route
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;#39;s move on to the &lt;code&gt;Messages&lt;/code&gt; module to add the &lt;code&gt;UrlChange&lt;/code&gt; message type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Messages.elm

module Messages exposing (..)

-- ...
import Navigation


type Msg
    = FetchResult (Result Http.Error ContactList)
    -- ...
    | UrlChange Navigation.Location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we need to implement the &lt;code&gt;UrlChange&lt;/code&gt; case in the &lt;code&gt;Update&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Update.elm

module Update exposing (..)

-- ...
import Routing exposing (Route(..), parse)


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        -- ...

        UrlChange location -&amp;gt;
            let
                currentRoute =
                    parse location
            in
                urlUpdate { model | route = currentRoute }


urlUpdate : Model -&amp;gt; ( Model, Cmd Msg )
urlUpdate model =
    case model.route of
        HomeIndexRoute -&amp;gt;
            model ! [ fetch 1 &amp;quot;&amp;quot; ]

        _ -&amp;gt;
            model ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to setting the current route every time the location changes, we have added the
&lt;code&gt;urlUpdate&lt;/code&gt; function as well. This function is critical, as it returns any route-specific command
we need to run. This means that everytime a user visits the &lt;code&gt;HomeIndexRoute&lt;/code&gt; path, the application
will automatically fetch the first page of contacts (like we were doing before in the init
function of the &lt;code&gt;Main&lt;/code&gt; module). The following chart illustrates, more or less, how the
&lt;code&gt;Navigation.Program&lt;/code&gt; flow looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix_and_elm/navigation-flow.jpg" alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;browser&lt;/strong&gt; sends a &lt;strong&gt;location change&lt;/strong&gt; event to the main &lt;code&gt;Navigation.Program&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Navigation.Program&lt;/code&gt; triggers the &lt;code&gt;UrlChange&lt;/code&gt; message, handled by the &lt;code&gt;update&lt;/code&gt; function of the &lt;code&gt;Update&lt;/code&gt; module.&lt;/li&gt;
&lt;li&gt;This calls the &lt;code&gt;parse&lt;/code&gt; function of the &lt;code&gt;Routing&lt;/code&gt; module, which returns the matched &lt;code&gt;Route&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;update&lt;/code&gt; function returns the new update model and the specific commands for that route (if any).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Navigation.Program&lt;/code&gt; uses the &lt;code&gt;view&lt;/code&gt; function along with the received &lt;code&gt;model&lt;/code&gt; to render the &lt;strong&gt;Html&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;Route specific views&lt;/h3&gt;

&lt;p&gt;Our routes are going to render different Html, so we still need to update the &lt;code&gt;View&lt;/code&gt; module to implement this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/View.elm

module View exposing (..)

import ContactList.View exposing (indexView)
-- ...

view : Model -&amp;gt; Html Msg
view model =
    section
        []
        [ headerView
        , div []
            [ page model ]
        ]

-- ...

page : Model -&amp;gt; Html Msg
page model =
    case model.route of
        HomeIndexRoute -&amp;gt;
            indexView model

        NotFoundRoute -&amp;gt;
            notFoundView

notFoundView : Html Msg
notFoundView =
    text &amp;quot;Route not found&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;page&lt;/code&gt; function patterns match against the current route of the model, calling the specific view function for that route. That &lt;code&gt;notFoundView&lt;/code&gt; is very simple,
so let&amp;#39;s create a nicer one and make it look like the other warning messages we already have in the contact list search. We are probably going to
need this function in other places, therefore instead of using it directly from the &lt;code&gt;ContactList.View&lt;/code&gt;, let&amp;#39;s move it to a different module called &lt;code&gt;Common.View&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Common/View.elm

module Common.View exposing (warningMessage)

import Html exposing (..)
import Html.Attributes exposing (class)
import Messages exposing (Msg(..))


warningMessage : String -&amp;gt; String -&amp;gt; Html Msg -&amp;gt; Html Msg
warningMessage iconClasses message content =
    div
        [ class &amp;quot;warning&amp;quot; ]
        [ span
            [ class &amp;quot;fa-stack&amp;quot; ]
            [ i [ class iconClasses ] [] ]
        , h4
            []
            [ text message ]
        , content
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;#39;t forget to remove it from the &lt;code&gt;ContactList.View&lt;/code&gt; and add the necessary import in it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/ContactList/View.elm

module ContactList.View exposing (indexView)

import Common.View exposing (warningMessage)

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can refactor the previously created &lt;code&gt;notFoundView&lt;/code&gt; function in order to make it look how we want:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/View.elm

module View exposing (..)

import Common.View exposing (warningMessage)

-- ...

notFoundView : Html Msg
notFoundView =
    warningMessage
        &amp;quot;fa fa-meh-o fa-stack-2x&amp;quot;
        &amp;quot;Page not found&amp;quot;
        backToHomeLink

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool! We do not only want to show the message but also give the user the chance to go back to
the index route and display the contact list, that is why we have also added that convenient
&lt;code&gt;backToHomeLink&lt;/code&gt; function call as the last parameter of &lt;code&gt;warningMessage&lt;/code&gt;. Let&amp;#39;s add its implementation
in the &lt;code&gt;Common.View&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Common/View.elm

module Common.View exposing (warningMessage, backToHomeLink)

-- ...


backToHomeLink : Html Msg
backToHomeLink =
    a
        [ onClick &amp;lt;| NavigateTo HomeIndexRoute ]
        [ text &amp;quot;← Back to contact list&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, it is just a basic link that triggers the &lt;code&gt;NavigateTo&lt;/code&gt; message passing it the route to navigate to,
in this case, the &lt;code&gt;HomeIndexRoute&lt;/code&gt;. Let&amp;#39;s add its definition to the &lt;code&gt;Messages&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Messages.elm

module Messages exposing (..)

import Routing exposing (Route)
-- ...

type Msg
    = FetchResult (Result Http.Error ContactList)
    -- ...
    | NavigateTo Route
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, we have to add it&amp;#39;s implementation in the &lt;code&gt;Update&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Upate.elm

module Update exposing (..)

import Navigation

-- ...

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        -- ...

        NavigateTo route -&amp;gt;
            model ! [ Navigation.newUrl &amp;lt;| toPath route ]

-- ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, it is returning the model and a command created by the &lt;code&gt;newUrl&lt;/code&gt; function from the &lt;code&gt;Navigation&lt;/code&gt;
module, which receives an &lt;strong&gt;URL&lt;/strong&gt; string and adds it to the browser history, creating a location change and
triggering all the flow we have seen earlier again. However, how can we get a string &lt;strong&gt;URL&lt;/strong&gt; having only a &lt;code&gt;Route&lt;/code&gt;?
That is where toPath function comes into play. Let&amp;#39;s create it in the &lt;code&gt;Routing&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Routing.elm

module Routing exposing (..)

-- ...

toPath : Route -&amp;gt; String
toPath route =
    case route of
        HomeIndexRoute -&amp;gt;
            &amp;quot;/&amp;quot;

        NotFoundRoute -&amp;gt;
            &amp;quot;/not-found&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using pattern matching against the received route, it returns an &lt;strong&gt;URL&lt;/strong&gt;.As easy as pie! If we are not missing
anything and after the compiler ends compiling, this is what happens if we visit an
incorrect route like &lt;a href="http://localhost:4000/foo"&gt;http://localhost:4000/foo&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix_and_elm/404.jpg" alt="404" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h3&gt;Show contact route&lt;/h3&gt;

&lt;p&gt;Now that we have covered the &lt;code&gt;HomeIndexRoute&lt;/code&gt; and &lt;code&gt;NotFoundRoute&lt;/code&gt; routes, let&amp;#39;s update the &lt;code&gt;Routing&lt;/code&gt; module to add the changes we need
to add a new route, which shows a contact&amp;#39;s detail page:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Routing.elm

module Routing exposing (..)

-- ...

type Route
    = HomeIndexRoute
    -- ...
    | ShowContactRoute Int

toPath : Route -&amp;gt; String
toPath route =
    case route of
        -- ...

        ShowContactRoute id -&amp;gt;
            &amp;quot;/contacts/&amp;quot; ++ toString id

        -- ...

matchers : Parser (Route -&amp;gt; a) a
matchers =
    oneOf
        [ -- ...
        , map ShowContactRoute &amp;lt;| s &amp;quot;contacts&amp;quot; &amp;lt;/&amp;gt; int
        ]

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So when the user visits a path like &lt;code&gt;/contacts/id&lt;/code&gt;, we need to retrieve that contact&amp;#39;s data from the &lt;strong&gt;API&lt;/strong&gt;
endpoint we created at the beginning of this post, and store it somewhere in our program model.
Let&amp;#39;s update the &lt;code&gt;Model&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Model.elm

module Model exposing (..)

-- ...

type alias Model =
    { -- ...
    , contact : RemoteData String Contact
    }

-- ...

initialModel : Route -&amp;gt; Model
initialModel route =
    {
    , contact = NotRequested
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following the same pattern we set up in the previous part for handling remote data, we have added a new
contact to the &lt;code&gt;Model&lt;/code&gt; record, initialized with &lt;code&gt;NotRequested&lt;/code&gt;. Now that we know how the flow works, next step
is creating the command which is returned along with the model once the new route is visited.
This command sends the Http request asking for the given user&amp;#39;s data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Commands.elm

module Commands exposing (..)

import Decoders exposing (contactListDecoder, contactDecoder)

-- ...

fetchContact : Int -&amp;gt; Cmd Msg
  fetchContact id =
      let
          apiUrl =
              &amp;quot;/api/contacts/&amp;quot; ++ toString id

          request =
              Http.get apiUrl contactDecoder
      in
          Http.send FetchContactResult request
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The response gets parsed with the &lt;code&gt;contactDecoder&lt;/code&gt;, and the result handled with the &lt;code&gt;FetchContactResult&lt;/code&gt; message,
which we need to add to the &lt;code&gt;Messages&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Messages.elm

module Messages exposing (..)

import Model exposing (ContactList, Contact)
-- ...


type Msg
    -- ...
    | FetchContactResult (Result Http.Error Contact)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to edit the &lt;code&gt;Update&lt;/code&gt; module to implement these results:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Update.elm

module Update exposing (..)

import Commands exposing (fetch, fetchContact)
-- ...

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        -- ...

        FetchContactResult (Ok response) -&amp;gt;
            { model | contact = Success response } ! []

        FetchContactResult (Err error) -&amp;gt;
            { model | contact = Failure &amp;quot;Contact not found&amp;quot; } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result of the &lt;strong&gt;Http&lt;/strong&gt; request and decoding is &lt;code&gt;Ok&lt;/code&gt; then it sets the current contact in the model.
On the other hand, if it fails, it establishes a friendly message to show to the user. However, there&amp;#39;s
something we are missing here. How is the &lt;code&gt;fetchContact&lt;/code&gt; going to be triggered? Well, we have to do it
whenever a user visits the show contact route, and this gets done in two different ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;By clicking on a contact&amp;#39;s card in the contact list.&lt;/li&gt;
&lt;li&gt;Visiting the Url directly from the browser.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In any of these cases we have to fetch the contact when the &lt;strong&gt;Url&lt;/strong&gt; corresponds to the &lt;code&gt;ShowContactRoute&lt;/code&gt;, so let&amp;#39;s update once more the &lt;code&gt;Update&lt;/code&gt; module
to implement this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Update.elm

module Update exposing (..)

import Commands exposing (fetch, fetchContact)

-- ...

urlUpdate : Model -&amp;gt; ( Model, Cmd Msg )
  urlUpdate model =
      case model.route of
          HomeIndexRoute -&amp;gt;
              model ! [ fetch 1 &amp;quot;&amp;quot; ]

          ShowContactRoute id -&amp;gt;
              { model | contact = Requesting } ! [ fetchContact id ]

          _ -&amp;gt;
              model ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s move on to the &lt;code&gt;Contact.View&lt;/code&gt; and add the &lt;code&gt;onClick&lt;/code&gt; handler to the card:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Contact/View.elm

module Contact.View exposing (..)

-- ...

contactView : Contact -&amp;gt; ( String, Html Msg )
contactView model =
    let
        -- ...
    in
        ( toString model.id
        , div
            [ classes
            , onClick &amp;lt;| NavigateTo &amp;lt;| ShowContactRoute model.id
            ]

            -- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that int the main &lt;code&gt;View&lt;/code&gt; module we are using route-specific view functions, so let&amp;#39;s add the handler for the
&lt;code&gt;ShowContactRoute&lt;/code&gt; route:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/View.elm

module View exposing (..)

import Contact.View exposing (showContactView)

-- ...

page : Model -&amp;gt; Html Msg
page model =
    case model.route of
        -- ...

        ShowContactRoute id -&amp;gt;
            showContactView model

        -- ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we are using a &lt;code&gt;showContactView&lt;/code&gt; function from the &lt;code&gt;Contact.View&lt;/code&gt; module that we need to implement:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Contact/View.elm

module Contact.View exposing (..)

-- ...

showContactView : Model -&amp;gt; Html Msg
  showContactView model =
      case model.contact of
          Success contact -&amp;gt;
              let
                  classes =
                      classList
                          [ ( &amp;quot;person-detail&amp;quot;, True )
                          , ( &amp;quot;male&amp;quot;, contact.gender == 0 )
                          , ( &amp;quot;female&amp;quot;, contact.gender == 1 )
                          ]

                  ( _, content ) =
                      contactView contact
              in
                  div
                      [ id &amp;quot;contacts_show&amp;quot; ]
                      [ header []
                          [ h3
                              []
                              [ text &amp;quot;Person detail&amp;quot; ]
                          ]
                      , backToHomeLink
                      , div
                          [ classes ]
                          [ content ]
                      ]

          Requesting -&amp;gt;
              warningMessage
                  &amp;quot;fa fa-spin fa-cog fa-2x fa-fw&amp;quot;
                  &amp;quot;Fetching contact&amp;quot;
                  (text &amp;quot;&amp;quot;)

          Failure error -&amp;gt;
              warningMessage
                  &amp;quot;fa fa-meh-o fa-stack-2x&amp;quot;
                  error
                  backToHomeLink

          NotRequested -&amp;gt;
              text &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following the same RemoteData pattern that in the &lt;code&gt;ContactList.View&lt;/code&gt; main function, we handle all the
possible different values of the model&amp;#39;s contact. The &lt;code&gt;Success&lt;/code&gt; branch wraps the existing &lt;code&gt;contactView&lt;/code&gt;
function in an &lt;strong&gt;Html&lt;/strong&gt; div with its header and back-to-home link, to navigate back to the &lt;code&gt;HomeIndexRoute&lt;/code&gt; route.
After the compilation ends, we can refresh our browser, click on any of the contact cards and see
how the list disappears to show only our selected contact:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix_and_elm/show-contact.gif" alt="Show contact" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;I&amp;#39;s working like a charm. But if you paginate or make a search, click on a contact and then
return back to the contact list, you will notice that the current search and pagination is lost.
This is becacuse we are always fetching the first page in the &lt;code&gt;urlUpdate&lt;/code&gt; function, so let&amp;#39;s do a little refactor to solve this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- web/elm/Update.elm

module Update exposing (..)

-- ...

urlUpdate : Model -&amp;gt; ( Model, Cmd Msg )
  urlUpdate model =
      case model.route of
          HomeIndexRoute -&amp;gt;
              case model.contactList of
                  NotRequested -&amp;gt;
                      model ! [ fetch 1 &amp;quot;&amp;quot; ]

                  _ -&amp;gt;
                      model ! []

          -- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this little change, we are only resetting the pagination and search only when the contact list has
not been requested previously. Let&amp;#39;s get back to the browser and see what happens now:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix_and_elm/show-contact-2.gif" alt="Show contact" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;We have our &lt;strong&gt;Elm&lt;/strong&gt; routes completely working, yay! This is all for now, but in the next part of the series,
we are going to add support for one of the features that makes Phoenix so awesome, &lt;strong&gt;WebSockets&lt;/strong&gt;, removing
the &lt;strong&gt;API&lt;/strong&gt; controller and replacing it with a &lt;strong&gt;Phoenix&lt;/strong&gt; channel, seeing how to connect to it from &lt;strong&gt;Elm&lt;/strong&gt; and send
messages through it. In the meantime, here&amp;#39;s &lt;a href="https://github.com/bigardone/phoenix-and-elm/tree/tutorial/part-5"&gt;the source code&lt;/a&gt; of what we have done so far.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://phoenix-and-elm.herokuapp.com/" target="_blank" class="btn"&gt;&lt;i class="fa fa-cloud"&gt;&lt;/i&gt; Live demo&lt;/a&gt;
  &lt;a href="https://github.com/bigardone/phoenix-and-elm" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>

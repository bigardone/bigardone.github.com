<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code, Love &amp; Boards</title>
  <subtitle>A blog about coding web apps, loving life and board sports</subtitle>
  <id>http://codeloveandboards.com/blog</id>
  <link href="http://codeloveandboards.com/blog"/>
  <link href="http://codeloveandboards.com/feed.xml" rel="self"/>
  <updated>2018-06-20T07:00:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Elixir and Phoenix basic passwordless and databaseless authentication (pt.2)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2/"/>
    <id>http://codeloveandboards.com/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2/</id>
    <published>2018-06-20T07:00:00Z</published>
    <updated>2018-09-01T07:53:25+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Elixir and Phoenix basic passwordless and databaseless authentication&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;Project setup and the initial functionality for storing and verifying authentication tokens&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2"&gt;Sending authentication link emails and the user socket connection&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/09/01/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3"&gt;Setting up webpack as our asset bundler and the Elm single-page application&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;previous part&lt;/a&gt; of the series, we set up the umbrella application for our new project and created the necessary modules for storing and generating authentication tokens. Having this done, the next step is sending emails to valid users, containing the sign-in link that will authenticate them into the system once clicked.&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result" src="https://monosnap.com/image/5VUT424b4Hu9ITi8r1SGae7HQleCPT.png" /&gt;&lt;/p&gt;

&lt;h3&gt;Sending emails&lt;/h3&gt;

&lt;p&gt;To send emails in an Elixir application I usually rely on &lt;a href="https://github.com/thoughtbot/bamboo"&gt;Bamboo&lt;/a&gt; from the awesome team at &lt;a href="https://thoughtbot.com/"&gt;thoughtbot&lt;/a&gt;, which is not only simple and powerful, but very customizable as well. Let&amp;#39;s go ahead and add the dependency to the project, under the &lt;code&gt;PasswordlessAuthWeb&lt;/code&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/mix.exs

defmodule PasswordlessAuthWeb.Mixfile do
  use Mix.Project

  # ...

  defp deps do
    [
      {:phoenix, &amp;quot;~&amp;gt; 1.3.2&amp;quot;},
      {:phoenix_pubsub, &amp;quot;~&amp;gt; 1.0&amp;quot;},
      {:phoenix_html, &amp;quot;~&amp;gt; 2.10&amp;quot;},
      {:phoenix_live_reload, &amp;quot;~&amp;gt; 1.0&amp;quot;, only: :dev},
      {:gettext, &amp;quot;~&amp;gt; 0.11&amp;quot;},
      {:passwordless_auth, in_umbrella: true},
      {:cowboy, &amp;quot;~&amp;gt; 1.0&amp;quot;},
      {:bamboo, &amp;quot;~&amp;gt; 0.8&amp;quot;}
    ]
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;#39;t forget to run the necessary &lt;code&gt;deps.get&lt;/code&gt; mix task in order to install it. Next step is configuring Bamboo:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/config/config.exs

use Mix.Config

# ...

# Bamboo mailer configuration
config :passwordless_auth_web,
       PasswordlessAuthWeb.Service.Mailer,
       adapter: Bamboo.LocalAdapter

# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the configuration we are specifying two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The name of the module we are going to use as an interface with &lt;code&gt;Bamboo&lt;/code&gt;&amp;#39;s functionality.&lt;/li&gt;
&lt;li&gt;The adapter we want to use to send emails.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For our particular case and while developing the project, we are going to take advantage of the &lt;a href="https://hexdocs.pm/bamboo/Bamboo.LocalAdapter.html"&gt;LocalAdapter&lt;/a&gt; which stores sent emails in memory and offers us a small inbox application where we can view them. In order to have access to this inbox application, we need to mount a new route it in the router, which will be only accessible in the &lt;code&gt;:dev&lt;/code&gt; environment:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/router.ex

defmodule PasswordlessAuthWeb.Router do
  use PasswordlessAuthWeb, :router

  if Mix.env() == :dev, do: forward(&amp;quot;/sent_emails&amp;quot;, Bamboo.EmailPreviewPlug)

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only part we are missing is creating the &lt;code&gt;Mailer&lt;/code&gt; module, so let&amp;#39;s go ahead and add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/service/mailer.ex

defmodule PasswordlessAuthWeb.Service.Mailer do
  use Bamboo.Mailer, otp_app: :passwordless_auth_web
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we start the Phoenix server at this point and visit &lt;a href="http://localhost:4000/sent_emails"&gt;http://localhost:4000/sent_emails&lt;/a&gt;, we should see the following message:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Empty inbox" src="https://monosnap.com/image/gB604OQdzH4yWfhptA9PyaxD16M3AD.png" /&gt;&lt;/p&gt;

&lt;p&gt;This is completely fine, as we haven&amp;#39;t sent any emails yet, so let&amp;#39;s go ahead and create the necessary functionality to build up an email containing the authentication link using an email address and a token:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/emails/auth_email.


defmodule PasswordlessAuthWeb.Emails.AuthEmail do
  import Bamboo.Email, only: [new_email: 1]
  import PasswordlessAuthWeb.Router.Helpers, only: [page_url: 4]

  @from &amp;quot;support@passwordlessauth.com&amp;quot;

  def build(email, token) do
    url = page_url(PasswordlessAuthWeb.Endpoint, :index, [], token: token)

    new_email(
      to: email,
      from: @from,
      subject: &amp;quot;Your authentication link&amp;quot;,
      html_body: &amp;quot;&amp;quot;&amp;quot;
      &amp;lt;p&amp;gt;Here is your authentication link:&amp;lt;/p&amp;gt;
      &amp;lt;a href=&amp;quot;#{url}&amp;quot;&amp;gt;#{url}&amp;lt;/a&amp;gt;
      &amp;lt;p&amp;gt;It is valid for 5 minutes.&amp;lt;/p&amp;gt;
      &amp;quot;&amp;quot;&amp;quot;,
      text_body: &amp;quot;&amp;quot;&amp;quot;
      Here is your authentication link: \n
      #{url}\n
      It is valid for 5 minutes.
      &amp;quot;&amp;quot;&amp;quot;
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the token parameter and thanks to Phoenix&amp;#39;s route helpers, we build the new Bamboo email which has the authentication link in its body, and which addressee is the email parameter. For the time being, let&amp;#39;s use the default route that comes with Phoenix out of the box, and which points to &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s test this out by starting the Phoenix server again and sending a new email:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;$ iex -S mix phx.server
Erlang/OTP 21 [erts-10.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

[info] Running PasswordlessAuthWeb.Endpoint with Cowboy using http://0.0.0.0:4000
Interactive Elixir (1.6.6) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; email = PasswordlessAuthWeb.Emails.AuthEmail.build(&amp;quot;foo@email.com&amp;quot;, &amp;quot;token&amp;quot;)
%Bamboo.Email{
  assigns: %{},
  bcc: nil,
  cc: nil,
  from: &amp;quot;support@passwordlessauth.com&amp;quot;,
  headers: %{},
  html_body: &amp;quot;&amp;lt;p&amp;gt;Here is your authentication link:&amp;lt;/p&amp;gt;\n&amp;lt;a href=\&amp;quot;http://localhost:4000/?token=token\&amp;quot;&amp;gt;http://localhost:4000/?token=token&amp;lt;/a&amp;gt;\n&amp;lt;p&amp;gt;It is valid for 5 minutes.&amp;lt;/p&amp;gt;\n&amp;quot;,
  private: %{},
  subject: &amp;quot;Your authentication link&amp;quot;,
  text_body: &amp;quot;Here is your authentication link: \n\nhttp://localhost:4000/?token=token\n\nIt is valid for 5 minutes.\n&amp;quot;,
  to: &amp;quot;foo@email.com&amp;quot;
}
iex(2)&amp;gt; PasswordlessAuthWeb.Service.Mailer.deliver_later email
[debug] Sending email with Bamboo.LocalAdapter:

%Bamboo.Email{assigns: %{}, bcc: [], cc: [], from: {nil, &amp;quot;support@passwordlessauth.com&amp;quot;}, headers: %{}, html_body: &amp;quot;&amp;lt;p&amp;gt;Here is your authentication link:&amp;lt;/p&amp;gt;\n&amp;lt;a href=\&amp;quot;http://localhost:4000/?token=token\&amp;quot;&amp;gt;http://localhost:4000/?token=token&amp;lt;/a&amp;gt;\n&amp;lt;p&amp;gt;It is valid for 5 minutes.&amp;lt;/p&amp;gt;\n&amp;quot;, private: %{}, subject: &amp;quot;Your authentication link&amp;quot;, text_body: &amp;quot;Here is your authentication link: \n\nhttp://localhost:4000/?token=token\n\nIt is valid for 5 minutes.\n&amp;quot;, to: [nil: &amp;quot;foo@email.com&amp;quot;]}

iex(3)&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we revisit &lt;a href="http://localhost:4000/sent_emails"&gt;http://localhost:4000/sent_emails&lt;/a&gt;, we can see the email that we just sent:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Bamboo inbox" src="https://monosnap.com/image/PLsLxEljpZnc3KHuJLc7oR3Tl0CLPK.png" /&gt;&lt;/p&gt;

&lt;p&gt;But, how are the users going to request the authentication email?&lt;/p&gt;

&lt;h3&gt;The authentication controller&lt;/h3&gt;

&lt;p&gt;Despite the admin site being an Elm single page application, that relies on a socket connection, we still need to provide a mechanism so users can request the authentication email. Let&amp;#39;s use a controller for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/controllers/authentication_controller.ex

defmodule PasswordlessAuthWeb.AuthenticationController do
  use PasswordlessAuthWeb, :controller

  alias PasswordlessAuthWeb.{Emails.AuthEmail, Service.Mailer}

  @email_regex ~r/^[A-Za-z0-9._%+-+&amp;#39;]+@[A-Za-z0-9.-]+\.[A-Za-z]+$/

  def create(conn, params) do
    with %{&amp;quot;email&amp;quot; =&amp;gt; email} &amp;lt;- params,
         true &amp;lt;- valid_email?(email),
         {:ok, token} &amp;lt;- PasswordlessAuth.provide_token_for(email) do
      build_and_deliver_email(email, token)
    end

    json(conn, %{message: gettext(&amp;quot;auth.message&amp;quot;)})
  end

  def valid_email?(email), do: Regex.match?(@email_regex, email)

  defp build_and_deliver_email(email, token) do
    email
    |&amp;gt; AuthEmail.build(token)
    |&amp;gt; Mailer.deliver_later()
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the received parameters contain the &lt;code&gt;email&lt;/code&gt; with a valid format, it provides a token, builds and delivers the authentication email. On the contrary, for security reasons we don&amp;#39;t want to give any clues to the user if the email provided has a wrong format or it does not exist, so it just returns the same success message. Let&amp;#39;s add a new route for this controller and action:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/router.ex

defmodule PasswordlessAuthWeb.Router do
  use PasswordlessAuthWeb, :router

    if Mix.env() == :dev, do: forward(&amp;quot;/sent_emails&amp;quot;, Bamboo.EmailPreviewPlug)

    # ...

    pipeline :api do
        plug(:accepts, [&amp;quot;json&amp;quot;])
    end

    # ...

    scope &amp;quot;/api&amp;quot;, PasswordlessAuthWeb do
        pipe_through(:api)

        post(&amp;quot;/auth&amp;quot;, AuthenticationController, :create)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, to check that everything works as we expect, let&amp;#39;s add a new test module for the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/test/passwordless_auth_web/controllers/authentication_controller_test.exs

defmodule PasswordlessAuthWeb.AuthenticationControllerTest do
  use PasswordlessAuthWeb.ConnCase
  use Bamboo.Test

  import PasswordlessAuthWeb.Gettext

  alias PasswordlessAuth.Repo
  alias PasswordlessAuthWeb.Emails.AuthEmail

  describe &amp;quot;POST /api/auth&amp;quot; do
    test &amp;quot;always returns success message no matter what parameters receives&amp;quot;, %{conn: conn} do
      conn = post(conn, authentication_path(conn, :create), email: &amp;quot;foo@test.com&amp;quot;)
      assert %{&amp;quot;message&amp;quot; =&amp;gt; _} = json_response(conn, 200)

      conn = post(conn, authentication_path(conn, :create), %{})
      assert assert %{&amp;quot;message&amp;quot; =&amp;gt; _} = json_response(conn, 200)
    end

    test &amp;quot;delivers the email only when valid email&amp;quot;, %{conn: conn} do
      email = &amp;quot;#{__MODULE__}@email.com&amp;quot;
      Repo.add_email(email)

      post(conn, authentication_path(conn, :create), email: email)

      {:ok, token} = Repo.fetch(email)

      assert_delivered_email(AuthEmail.build(email, token))
    end

    test &amp;quot;does not deliver the email only when invalid email format&amp;quot;, %{conn: conn} do
      email = &amp;quot;#{__MODULE__}emailcom&amp;quot;
      Repo.add_email(email)

      post(conn, authentication_path(conn, :create), email: email)

      {:ok, token} = Repo.fetch(email)

      refute_delivered_email(AuthEmail.build(email, token))
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run it, we can check that it is actually working fine:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth_web/controllers/authentication_controller_test.exs
==&amp;gt; passwordless_auth
Test patterns did not match any file: test/passwordless_auth_web/controllers/authentication_controller_test.exs
==&amp;gt; passwordless_auth_web
...

Finished in 0.1 seconds
3 tests, 0 failures

Randomized with seed 547795
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yay! Now that we have the email generation and delivery sorted out, let&amp;#39;s move on the next important part of our application, the user socket.&lt;/p&gt;

&lt;h3&gt;Authenticating the user socket connection&lt;/h3&gt;

&lt;p&gt;Phoenix creates a default &lt;code&gt;UserSocket&lt;/code&gt; module while bootstrapping a new project, so let&amp;#39;s edit it to add the authentication logic:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/lib/passwordless_auth_web/channels/user_socket.ex

defmodule PasswordlessAuthWeb.UserSocket do
  use Phoenix.Socket

  alias PasswordlessAuth

  ## Transports
  transport(:websocket, Phoenix.Transports.WebSocket)

  def connect(%{&amp;quot;token&amp;quot; =&amp;gt; token}, socket) do
    case PasswordlessAuth.verify_token(token) do
      {:ok, email} -&amp;gt;
        {:ok, assign(socket, :user, %{email: email})}

      _ -&amp;gt;
        :error
    end
  end

  def connect(_, _socket), do: :error

  def id(socket), do: &amp;quot;user_socket:#{socket.assigns.user.email}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;connect/2&lt;/code&gt; callback function receives a &lt;code&gt;token&lt;/code&gt; parameter, and using &lt;code&gt;PasswordlessAuth.verify_token/1&lt;/code&gt; checks whether this token is valid or not, assigning to the socket the corresponding email on success. On the other hand, if no &lt;code&gt;token&lt;/code&gt; parameter is received or the verification goes wrong, it returns &lt;code&gt;:error&lt;/code&gt; rejecting the connection. Let&amp;#39;s add some unit tests to ensure that it works as we expect:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth_web/test/passwordless_auth_web/channels/user_socket_test.exs

defmodule PasswordlessAuthWeb.UserSocketTest do
  use PasswordlessAuthWeb.ChannelCase, async: true

  alias Phoenix.Socket
  alias PasswordlessAuth.Repo
  alias PasswordlessAuthWeb.UserSocket

  describe &amp;quot;connect/2&amp;quot; do
    test &amp;quot;errors when passing invalid params or token&amp;quot; do
      assert :error = connect(UserSocket, %{})
      assert :error = connect(UserSocket, %{&amp;quot;token&amp;quot; =&amp;gt; &amp;quot;invalid-token&amp;quot;})
    end

    test &amp;quot;joins when passing valid token&amp;quot; do
      email = &amp;quot;foo@#{__MODULE__}.com&amp;quot;
      :ok = Repo.add_email(email)
      {:ok, token} = PasswordlessAuth.provide_token_for(email)

      assert {:ok, %Socket{assigns: %{user: %{email: ^email}}}} =
               connect(UserSocket, %{&amp;quot;token&amp;quot; =&amp;gt; token})
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run them to check the result:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth_web/channels/user_socket_test.exs
==&amp;gt; passwordless_auth
Test patterns did not match any file: test/passwordless_auth_web/channels/user_socket_test.exs
==&amp;gt; passwordless_auth_web
..

Finished in 0.06 seconds
2 tests, 0 failures

Randomized with seed 589379
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, it works! I think this is all for today. In the next part, we will work on the front end side, configuring &lt;a href="https://webpack.js.org/"&gt;webpack&lt;/a&gt; as our asset build tool of choice, adding Elm support to start building the admin single page application, using everything we have done until now to authenticate users. In the meantime, don&amp;#39;t forget to check out the source code with the final result:&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Elixir and Phoenix basic passwordless and databaseless authentication (pt.1)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1/"/>
    <id>http://codeloveandboards.com/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1/</id>
    <published>2018-06-09T07:00:00Z</published>
    <updated>2018-09-01T07:53:23+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Elixir and Phoenix basic passwordless and databaseless authentication&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/09/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-1"&gt;Project setup and the initial functionality for storing and verifying authentication tokens&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/06/20/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-2"&gt;Sending authentication link emails and the user socket connection&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/09/01/elixir-and-phoenix-basic-passwordless-and-databaseless-authentication-pt-3"&gt;Setting up webpack as our asset bundler and the Elm single-page application&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Have you found yourself working on a small project where, at some point,
you are asked to give access to some users to a private part of the
application or a small admin panel of some sort? Depending on the
project&amp;#39;s constraints, we can resolve this situation in many different
ways. For instance, if having administrator profiles and roles forms part
of the business logic and the scope of the project, having a standard
authorization and authentication system is probably the way to go. On the
other hand, if we only need administrator users to authenticate and let
them have access to a private part, we can rely on other simple
alternatives like HTTP basic authentication, which might not be as
flexible and secure as we might need them to be.&lt;/p&gt;

&lt;h3&gt;Passwordless authentication&lt;/h3&gt;

&lt;p&gt;A couple of years ago I read &lt;a href="https://www.smashingmagazine.com/2016/06/the-current-state-of-authentication-we-have-a-password-problem/"&gt;this excellent article&lt;/a&gt; about the current
state of authentication where it showcases the most common ways of
authenticating users, describing their strengths and weaknesses.
Between all of them, passwordless authentication is the one that I liked
the most, as the perfect balance between ease of implementation and security
strength, using this approach in many different projects since then.
If you are not familiar with this technique, it mainly
consists of asking the user for an email address and sending a link
which will automatically authenticate them into the application, just like
Slack does. I&amp;#39;m very pleased with the result so far, as my users
don&amp;#39;t need to remember passwords anymore (which tend to be frequently
forgotten), and I don&amp;#39;t have to deal with credentials storage, validation and
recovery any longer.&lt;/p&gt;

&lt;h3&gt;Databaseless authentication&lt;/h3&gt;

&lt;p&gt;As I said before, sometimes we don&amp;#39;t need a complex authentication system
which involves modifying the database schema or altering the existing
business logic to let a few users access a particular part of the
application. Therefore, I want to experiment alternative ways of storing
credentials, and Elixir is perfect for this particular use case.&lt;/p&gt;

&lt;h3&gt;What are we building&lt;/h3&gt;

&lt;p&gt;For this experiment, we are building a small &lt;a href="https://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-projects.html#umbrella-projects"&gt;Elixir umbrella project&lt;/a&gt;
which consists of two applications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;passwordless_auth&lt;/strong&gt;: Responsible for token generation, storage and
authentication logic.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;passwordless_auth_web&lt;/strong&gt;: Responsible for sending authentication emails and serving the Elm SPA to test out our auth experiment against a Phoenix socket.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The final result looks something like this:&lt;/p&gt;

&lt;p&gt;&lt;img alt="Final result" src="https://monosnap.com/image/5VUT424b4Hu9ITi8r1SGae7HQleCPT.png" /&gt;&lt;/p&gt;

&lt;p&gt;We are going to have three screens:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The last screen in the image corresponds to the root path of the admin panel, which is only displayed to authenticated users.&lt;/li&gt;
&lt;li&gt;The first screen corresponds to &amp;#39;/sign-in&amp;#39;, displayed to any user trying to access &amp;#39;/&amp;#39; while not authenticated.&lt;/li&gt;
&lt;li&gt;The second screen corresponds to the success message showed to the user after requesting the magic link.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bear in mind that these screens might change while we are going through the tutorial, as I keep making changes and refactoring things. Without further ado, let&amp;#39;s do this!&lt;/p&gt;

&lt;h3&gt;Project setup&lt;/h3&gt;

&lt;p&gt;First things first. Let&amp;#39;s build a new Phoenix project with the following options:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix phx.new passwordless_auth --umbrella --no-ecto --no-brunch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--umbrella&lt;/code&gt; tells the mix task to generate an umbrella project instead of a regular one. As we don&amp;#39;t need to handle any database connections, we use the &lt;code&gt;--no-ecto&lt;/code&gt; option to prevent having &lt;code&gt;Ecto&lt;/code&gt; installed, and a default repository created. Finally, I&amp;#39;ve been having some issues related to assets building with Brunch, so let&amp;#39;s remove it with the &lt;code&gt;--no-brunch&lt;/code&gt; option for the moment as we are going to be using a customized Webpack build when we get to that point.&lt;/p&gt;

&lt;p&gt;After running the mix task, we can see that we have our new umbrella project with the two applications inside the &lt;code&gt;/apps&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;passwordless-auth
├── README.md
├── apps
│   ├── passwordless_auth
│   └── passwordless_auth_web
├── config
│   ├── config.exs
│   ├── dev.exs
│   ├── prod.exs
│   └── test.exs
├── mix.exs
└── mix.lock
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The authentication repository&lt;/h3&gt;

&lt;p&gt;We are not relying on a database to store admitted user emails and their corresponding authentication tokens, but we have to store them somewhere else. Erlang/Elixir offer a simple and straightforward solution for in-memory storage, the &lt;a href="https://hexdocs.pm/elixir/GenServer.html"&gt;GenServer&lt;/a&gt; behaviour, which seems to fit perfectly for our needs. Let&amp;#39;s go ahead and create the &lt;code&gt;Repo&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/repo.ex

defmodule PasswordlessAuth.Repo do
  use GenServer
  @name __MODULE__

  def start_link(opts) do
    opts = Keyword.put_new(opts, :name, @name)
    {:ok, emails} = Keyword.fetch(opts, :emails)

    GenServer.start_link(__MODULE__, emails, opts)
  end

  @impl true
  def init(emails) when is_list(emails) and length(emails) &amp;gt; 0 do
    state = Enum.reduce(emails, %{}, &amp;amp;Map.put(&amp;amp;2, &amp;amp;1, nil))

    {:ok, state}
  end

  def init(_), do: {:stop, &amp;quot;Invalid list of emails&amp;quot;}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;start_link&lt;/code&gt; function receives the options to spawn the &lt;code&gt;GenServer&lt;/code&gt; process of the repository. These options consist of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:name&lt;/code&gt; which is optional and used for registering the process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:emails&lt;/code&gt; which is mandatory, represents the list of admitted emails, and which we are using in the &lt;code&gt;init&lt;/code&gt; function to build the initial state of the process.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;init&lt;/code&gt; function receives a list of emails and creates a &lt;code&gt;Map&lt;/code&gt; where keys are the emails, and the values will store the authentication tokens, but at the moment we are setting them to &lt;code&gt;nil&lt;/code&gt;. On the contrary, if what receives is not a list, we want it to return &lt;code&gt;{:stop, &amp;quot;Invalid list of emails&amp;quot;}&lt;/code&gt;, exiting the process and not letting the application to start.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s create a test module to test this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/repo_test.exs

defmodule PasswordlessAuth.RepoTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  describe &amp;quot;.init/1&amp;quot; do
    test &amp;quot;returns error when emails are wrong&amp;quot; do
      Process.flag(:trap_exit, true)

      name = :repo_test_1
      Repo.start_link(name: name, emails: &amp;quot;&amp;quot;)

      assert_receive {:EXIT, _, &amp;quot;Invalid list of emails&amp;quot;}
    end

    test &amp;quot;starts the repo when emails is a list&amp;quot; do
      name = :repo_test_1
      assert {:ok, _pid} = Repo.start_link(name: name, emails: [&amp;quot;foo@email.com&amp;quot;])
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the test shows that everything works as we expect:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/repo_test.exs
==&amp;gt; passwordless_auth
..

Finished in 0.1 seconds
2 tests, 0 failures

Randomized with seed 407876
==&amp;gt; passwordless_auth_web
Test patterns did not match any file: test/passwordless_auth/repo_test.exs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool! Now we need to spawn the &lt;code&gt;Repo&lt;/code&gt; process once the application starts, so let&amp;#39;s add it to the main supervision tree:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/application.ex

defmodule PasswordlessAuth.Application do
  use Application

  def start(_type, _args) do
    import Supervisor.Spec, warn: false

    children = [
      worker(
        PasswordlessAuth.Repo,
        [[emails: emails()]]
      )
    ]

    Supervisor.start_link(children, strategy: :one_for_one, name: PasswordlessAuth.Supervisor)
  end

  defp emails, do: Application.get_env(:passwordless_auth, :repo)[:emails]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try to start the application at this point, it will not do it, due to we have not set the emails in the configuration yet, just like we have asserted in the previous test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix
Erlang/OTP 21 [RELEASE CANDIDATE 1] [erts-10.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

[info] Application passwordless_auth exited: PasswordlessAuth.Application.start(:normal, []) returned an error: shutdown: failed to start child: PasswordlessAuth.Repo
    ** (EXIT) &amp;quot;Invalid list of emails&amp;quot;
** (Mix) Could not start application passwordless_auth: PasswordlessAuth.Application.start(:normal, []) returned an error: shutdown: failed to start child: PasswordlessAuth.Repo
    ** (EXIT) &amp;quot;Invalid list of emails&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s add a list of emails to the configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/config/config.exs

use Mix.Config

config :passwordless_auth,
       :repo,
       emails: ~w(foo@email.com bar@email.com baz@email.com)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And try to start it again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix
Erlang/OTP 21 [RELEASE CANDIDATE 1] [erts-10.0] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [hipe]

Interactive Elixir (1.6.5) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works as expected, so let&amp;#39;s move on to adding some logic to the &lt;code&gt;Repo&lt;/code&gt; module.&lt;/p&gt;

&lt;h3&gt;Repo logic&lt;/h3&gt;

&lt;p&gt;Before continuing, let&amp;#39;s start the application and check how the current state of the &lt;code&gt;Repo&lt;/code&gt; process looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ iex -S mix
...
iex(1)&amp;gt; :sys.get_state PasswordlessAuth.Repo
%{&amp;quot;bar@email.com&amp;quot; =&amp;gt; nil, &amp;quot;baz@email.com&amp;quot; =&amp;gt; nil, &amp;quot;foo@email.com&amp;quot; =&amp;gt; nil}
iex(2)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is the map where we are going to store the authentication tokens. Let&amp;#39;s continue by adding some functionality to validate if an email is valid, save and fetch token values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/application.ex

defmodule PasswordlessAuth.Application do
  use Application

  #...

  def exists?(pid \\ @name, email),
    do: GenServer.call(pid, {:exists, email})

  def save(pid \\ @name, email, token),
    do: GenServer.call(pid, {:save, email, token})

  def fetch(pid \\ @name, email),
    do: GenServer.call(pid, {:fetch, email})

  # ...

  @impl true
  def handle_call({:exists, email}, _from, state) do
    {:reply, Map.has_key?(state, email), state}
  end

  def handle_call({:save, email, token}, _from, state) do
    if Map.has_key?(state, email) do
      {:reply, :ok, Map.put(state, email, token)}
    else
      {:reply, {:error, :invalid_email}, state}
    end
  end

  def handle_call({:fetch, email}, _from, state) do
    {:reply, Map.fetch(state, email), state}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exists?/2&lt;/code&gt; takes an email and checks if it belongs to the state&amp;#39;s keys.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save/3&lt;/code&gt; takes an email and a token, and tries to store it into the state, returning &lt;code&gt;:ok&lt;/code&gt; if the email exists or &lt;code&gt;{:error, :invalid_email}&lt;/code&gt; if it does not.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fetch/2&lt;/code&gt; takes an email and fetches the state for its token value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s add some tests for the new functionality:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/repo_test.exs

defmodule PasswordlessAuth.RepoTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  # ...

    describe &amp;quot;.exists?/2&amp;quot; do
    test &amp;quot;returns true when passed email is in the repo&amp;#39;s state&amp;quot; do
      name = :repo_test_2
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      assert Repo.exists?(name, email)
    end

    test &amp;quot;returns false when passed email no it repo&amp;#39;s state&amp;quot; do
      name = :repo_test_3
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      refute Repo.exists?(name, &amp;quot;not_found@test.com&amp;quot;)
    end
  end

  describe &amp;quot;.save/3&amp;quot; do
    test &amp;quot;returns :ok and sets token value in state when email exists&amp;quot; do
      name = :repo_test_4
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      assert :ok = Repo.save(name, email, token)
      assert %{&amp;quot;foo@test.com&amp;quot; =&amp;gt; ^token} = :sys.get_state(name)
    end

    test &amp;quot;returns {:error, :invalid_email} when email does not exist&amp;quot; do
      name = :repo_test_5
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])

      assert {:error, :invalid_email} = Repo.save(name, &amp;quot;bar@test.com&amp;quot;, token)
    end
  end

  describe &amp;quot;.fetch/2&amp;quot; do
    test &amp;quot;returns {:ok, token} for passed email&amp;quot; do
      name = :repo_test_6
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert {:ok, ^token} = Repo.fetch(name, email)
    end

    test &amp;quot;returns :error when token not found&amp;quot; do
      name = :repo_test_7
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert :error = Repo.fetch(name, &amp;quot;not_found@test.com&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And check that they all pass:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/repo_test.exs
==&amp;gt; passwordless_auth
........

Finished in 0.1 seconds
8 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Token logic&lt;/h3&gt;

&lt;p&gt;It looks like we have the basic stuff covered, for now, so let&amp;#39;s create the &lt;code&gt;Token&lt;/code&gt; module to handle token generation and verification. Phoenix has a convenient module for these purposes, &lt;a href="https://hexdocs.pm/phoenix/Phoenix.Token.html"&gt;Phoenix.Token&lt;/a&gt;, and we can build our module wrapping it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/token.ex

defmodule PasswordlessAuth.Token do
  alias Phoenix.Token, as: PhoenixToken

  @salt &amp;quot;token salt&amp;quot;
  @max_age :timer.minutes(5) / 1000
  @secret Application.get_env(:passwordless_auth, __MODULE__)[:secret_key_base]

  def generate(data) when data in [nil, &amp;quot;&amp;quot;], do: {:error, :invalid}

  def generate(data) do
    {:ok, PhoenixToken.sign(@secret, @salt, data)}
  end

  def verify(token, data, max_age \\ @max_age) do
    case PhoenixToken.verify(
           @secret,
           @salt,
           token,
           max_age: max_age
         ) do
      {:ok, ^data} -&amp;gt;
        {:ok, data}

      {:ok, _other} -&amp;gt;
        {:error, :invalid}

      {:error, reason} -&amp;gt;
        {:error, reason}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generate/1&lt;/code&gt; takes some &lt;code&gt;data&lt;/code&gt; and returns &lt;code&gt;{:ok, token}&lt;/code&gt; with the token generated using &lt;code&gt;Phoenix.Token.sign/4&lt;/code&gt; unless the &lt;code&gt;data&lt;/code&gt; it is receiving is either &lt;code&gt;nil&lt;/code&gt; or and empty string, in which case it returns the corresponding &lt;code&gt;{:error, :invalid}&lt;/code&gt; tuple.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verify/3&lt;/code&gt; takes a &lt;code&gt;token&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and a &lt;code&gt;max_age&lt;/code&gt; and uses &lt;code&gt;Phoenix.Token.verify/4&lt;/code&gt; to check id the &lt;code&gt;token&lt;/code&gt; corresponds to &lt;code&gt;data&lt;/code&gt;, and it has not expired yet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s add a test module to check that everything works as it should:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/token_test.exs

defmodule PasswordlessAuth.TokenTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Token

  describe &amp;quot;.generate/1&amp;quot; do
    test &amp;quot;returns {:error, :invalid} when value is nil&amp;quot; do
      assert {:error, :invalid} = Token.generate(nil)
      assert {:error, :invalid} = Token.generate(&amp;quot;&amp;quot;)
    end

    test &amp;quot;returns {:ok, token}&amp;quot; do
      assert {:ok, _token} = Token.generate(&amp;quot;foo&amp;quot;)
    end
  end

  describe &amp;quot;.verify/3&amp;quot; do
    test &amp;quot;returns {:ok, data} when token is valid&amp;quot; do
      {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)

      assert {:ok, &amp;quot;foo&amp;quot;} = Token.verify(token, &amp;quot;foo&amp;quot;)
    end

    test &amp;quot;returns {:error, :invalid} when token is not valid&amp;quot; do
      {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)

      assert {:error, :invalid} = Token.verify(token, &amp;quot;bar&amp;quot;)
    end

    test &amp;quot;returns {:error, reason} when token expires&amp;quot; do
      {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)

      Process.sleep(150)
      assert {:error, :expired} = Token.verify(token, &amp;quot;foo&amp;quot;, 0.1)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run the tests and see the result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix test test/passwordless_auth/token_test.exs
==&amp;gt; passwordless_auth


  1) test .verify/3 returns {:error, reason} when token expires (PasswordlessAuth.TokenTest)
     test/passwordless_auth/token_test.exs:30
     ** (UndefinedFunctionError) function nil.config/1 is undefined or private
     code: {:ok, token} = Token.generate(&amp;quot;foo&amp;quot;)
     stacktrace:
       nil.config(:secret_key_base)
       (phoenix) lib/phoenix/token.ex:202: Phoenix.Token.get_endpoint_key_base/1
       (phoenix) lib/phoenix/token.ex:111: Phoenix.Token.sign/4
       (passwordless_auth) lib/passwordless_auth/token.ex:25: PasswordlessAuth.Token.generate/1
       test/passwordless_auth/token_test.exs:31: (test)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It looks like we forgot adding the &lt;code&gt;:secret&lt;/code&gt; value in the configuration, so let&amp;#39;s go ahead and set it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/config/config.exs

# ...

config :passwordless_auth,
       PasswordlessAuth.Token,
       secret_key_base: &amp;quot;your_secret_key_base&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To generate the &lt;code&gt;secret_key_base&lt;/code&gt; value, you can use the &lt;code&gt;phx.gen.secret&lt;/code&gt; mix task. After setting the value and running once more the tests, everything should be working fine now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/token_test.exs
==&amp;gt; passwordless_auth
.....

Finished in 0.2 seconds
5 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Providing and verifying tokens&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s edit the main &lt;code&gt;PasswordlessAuth&lt;/code&gt; module and add a new function to provide new tokens by using what we have done so far:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth.ex

defmodule PasswordlessAuth do
  alias PasswordlessAuth.{Repo, Token}

  def provide_token_for(repo \\ Repo, email)
  def provide_token_for(_, email) when email in [nil, &amp;quot;&amp;quot;], do: {:error, :invalid_email}

  def provide_token_for(repo, email) do
    with true &amp;lt;- Repo.exists?(repo, email),
         {:ok, token} &amp;lt;- Token.generate(email),
         :ok &amp;lt;- Repo.save(repo, email, token) do
      {:ok, token}
    else
      false -&amp;gt;
        {:error, :not_found}

      other -&amp;gt;
        {:error, :internal_error, other}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before moving on to adding the verification logic, let&amp;#39;s stop for a second and think about what we need. The function will receive a token, and we want to check not only it corresponds to any of the stored ones in the &lt;code&gt;Repo&lt;/code&gt;, but also that the token&amp;#39;s signed value corresponds to the email key under which is stored. Therefore, let&amp;#39;s add a new function to return an email by its token from the &lt;code&gt;Repo&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth/repo.ex

defmodule PasswordlessAuth.Repo do
  # ...

  def find_by_token(pid \\ @name, token),
    do: GenServer.call(pid, {:find_by_token, token})

  # ...

  def handle_call({:find_by_token, token}, _from, state) do
    {:reply, Enum.find(state, &amp;amp;(elem(&amp;amp;1, 1) == token)), state}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find_by_token/2&lt;/code&gt; checks if there is an element it the state with the value, returning the tuple of &lt;code&gt;{email, token}&lt;/code&gt; or nil if not found. This might not be the most performant way of doing it, but as we have already agreed on that the repo is only going to store a few emails, let&amp;#39;s keep it like this for simplicity&amp;#39;s sake. Let&amp;#39;s test it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth/repo_test.exs

defmodule PasswordlessAuth.RepoTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  # ...

  describe &amp;quot;.find_by_token/2&amp;quot; do
    test &amp;quot;returns {email, token} when token exists&amp;quot; do
      name = :repo_test_8
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert {^email, ^token} = Repo.find_by_token(name, token)
    end

    test &amp;quot;returns nil when token not found&amp;quot; do
      name = :repo_test_9
      email = &amp;quot;foo@test.com&amp;quot;
      token = &amp;quot;token-value&amp;quot;
      {:ok, _pid} = Repo.start_link(name: name, emails: [email])
      :ok = Repo.save(name, email, token)

      assert nil == Repo.find_by_token(name, &amp;quot;other-token&amp;quot;)
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth/repo_test.exs
==&amp;gt; passwordless_auth
..........

Finished in 0.1 seconds
10 tests, 0 failures
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to continue where we left it, so let&amp;#39;s go ahead and add the verification functionality to the &lt;code&gt;PasswordlessAuth&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/lib/passwordless_auth.ex

defmodule PasswordlessAuth do
  alias PasswordlessAuth.{Repo, Token}

  # ...

  def verify_token(repo \\ Repo, token) do
    repo
    |&amp;gt; Repo.find_by_token(token)
    |&amp;gt; do_verify()
  end

  # ...

  defp do_verify(nil), do: {:error, :not_found}
  defp do_verify({email, token}), do: Token.verify(token, email)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we&amp;#39;ve been doing so far, let&amp;#39;s create a test module for the &lt;code&gt;PasswordlessAuth&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# apps/passwordless_auth/test/passwordless_auth_test.exs

defmodule PasswordlessAuthTest do
  use ExUnit.Case, async: true

  alias PasswordlessAuth.Repo

  describe &amp;quot;provide_token_for/2&amp;quot; do
    test &amp;quot;returns error when email is blank&amp;quot; do
      assert {:error, :invalid_email} = PasswordlessAuth.provide_token_for(nil)
      assert {:error, :invalid_email} = PasswordlessAuth.provide_token_for(&amp;quot;&amp;quot;)
    end

    test &amp;quot;returns error when email does not exist&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_1&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])

      assert {:error, :not_found} =
               PasswordlessAuth.provide_token_for(repo, &amp;quot;not-found-email@test.com&amp;quot;)
    end

    test &amp;quot;returns token when valid email&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_2&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])

      assert {:ok, token} = PasswordlessAuth.provide_token_for(repo, email)
      assert byte_size(token) &amp;gt; 0
    end
  end

  describe &amp;quot;verify_token/2&amp;quot; do
    test &amp;quot;returns error when token not found&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_3&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])
      {:ok, _token} = PasswordlessAuth.provide_token_for(repo, email)

      assert {:error, :not_found} = PasswordlessAuth.verify_token(repo, &amp;quot;not-found-token&amp;quot;)
    end

    test &amp;quot;returns value when token valid&amp;quot; do
      repo = :&amp;quot;repo_test_#{__MODULE__}_4&amp;quot;
      email = &amp;quot;foo@test.com&amp;quot;
      {:ok, _pid} = Repo.start_link(name: repo, emails: [email])
      {:ok, token} = PasswordlessAuth.provide_token_for(repo, email)

      assert {:ok, ^email} = PasswordlessAuth.verify_token(repo, token)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally run it to confirm that everything is working as it should:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ mix test test/passwordless_auth_test.exs
==&amp;gt; passwordless_auth
.....

Finished in 0.07 seconds
5 tests, 0 failures

Randomized with seed 291795
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yay! Let&amp;#39;s leave it here for now. In the next part of the series, we will take care of sending the authentication link via email to the user, and use this link to verify the token and authenticate a Phoenix Socket connection. In the meantime, don&amp;#39;t forget to check out the source code with the final result of our small experiment:&lt;/p&gt;

&lt;div class="btn-wrapper"&gt;
  &lt;a href="https://github.com/bigardone/passwordless-auth" target="_blank" class="btn"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix &amp; Elm landing page (pt.3)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"/>
    <id>http://codeloveandboards.com/blog/2018/01/06/phoenix-elm-landing-page-pt-3/</id>
    <published>2018-01-07T07:06:00Z</published>
    <updated>2018-01-14T08:27:17+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix &amp; Elm landing page&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"&gt;Bootstrapping the project and the basic API functionality to save our first leads&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/"&gt;Building the landing page UI and the basic Elm subscription form&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"&gt;Adding Google reCAPTCHA support to avoid spambots&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/&amp;amp;lt;Paste"&gt;previous part&lt;/a&gt; of the series, we created the landing page main
layout and implemented the Elm subscription form, which lets visitors
subscribe, saving their name and email in the leads database table. We do
not want spambots to subscribe, therefore, in this part we are going
to add a protective layer to the subscription process using &lt;a href="https://developers.google.com/recaptcha/"&gt;Google&amp;#39;s
reCAPTCHA&lt;/a&gt;, which consists of two different steps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adding the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; widget to the Elm subscription form, and sending
the user&amp;#39;s response along with the name and email.&lt;/li&gt;
&lt;li&gt;Verifying in the server-side the user&amp;#39;s response against &lt;strong&gt;Google&amp;#39;s RECAPTCHA API&lt;/strong&gt; to verify whether is valid or not&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Without further ado, let&amp;#39;s do this!&lt;/p&gt;

&lt;h3&gt;Adding the reCAPTCHA widget to the form&lt;/h3&gt;

&lt;p&gt;First of all, we need to head to &lt;a href="https://www.google.com/recaptcha/admin"&gt;Google&amp;#39;s reCAPTCHA admin
site&lt;/a&gt; and register our website,
using localhost as the domain, to get the necessary keys that we need.&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/recaptcha-admin.jpg"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Next, we have to add &lt;strong&gt;Google&amp;#39;s reCAPTCHA&lt;/strong&gt; script in the main template, so
let&amp;#39;s edit it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/templates/layout/app.html.eex

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;!--... --&amp;gt;

  &amp;lt;body class=&amp;quot;landing-page&amp;quot;&amp;gt;
    &amp;lt;!--... --&amp;gt;

    &amp;lt;script src=&amp;quot;https://www.google.com/recaptcha/api.js?onload=onloadCallback&amp;amp;render=explicit&amp;quot; async defer&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are not only adding the script but passing the &lt;code&gt;onload&lt;/code&gt; and &lt;code&gt;render&lt;/code&gt;
parameters to render the widget explicitly and to call the
&lt;code&gt;onloadCallback&lt;/code&gt; function once the script gets loaded. The plan is to
render the widget inside the Elm form, and for that we need the script to
be loaded before rendering it, so let&amp;#39;s edit the main &lt;code&gt;app.js&lt;/code&gt; file to
achieve this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/js/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    const app = Elm.Main.embed(formContainer);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the &lt;strong&gt;Elm&lt;/strong&gt; program is embedded once the script is ready, we have to
render the widget somehow using its internal API. Before continuing any
further, let&amp;#39;s update the &lt;code&gt;View&lt;/code&gt; module and add a new div where we want to
render the widget:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;# assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
        -- ...

        , Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.div
                        [ Html.id &amp;quot;recaptcha&amp;quot; ]
                        []
                , validationErrorView &amp;quot;recaptcha_token&amp;quot; validationErrors
                ]

        -- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How can we tell the external &lt;strong&gt;reCAPTCHA&lt;/strong&gt; script that we want it to
render the widget inside the div with &lt;code&gt;recaptcha&lt;/code&gt; id? In Elm, the proper way
of communicating with external &lt;strong&gt;JavaScript&lt;/strong&gt; is by using &lt;strong&gt;ports&lt;/strong&gt;, so let&amp;#39;s go
ahead and create a new module with a port to initialize the widget:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Ports.elm

port module Ports exposing (..)

-- OUT PORTS


port initRecaptcha : String -&amp;gt; Cmd msg

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;initRecaptcha&lt;/code&gt; port function receives a string which is the id of the
container where we want to render the widget and returns a command.
Therefore, we can use it in the main &lt;code&gt;init&lt;/code&gt; function, and the port will get
called once the program starts for the first time:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

module Main exposing (main)

import Ports
-- ...

init : ( Model, Cmd Msg )
init =
    initialModel ! [ Ports.initRecaptcha &amp;quot;recaptcha&amp;quot; ]

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can go back to the &lt;code&gt;app.js&lt;/code&gt; script and subscribe to the
&lt;code&gt;initRecaptcha&lt;/code&gt; port:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/javascript/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    const app = Elm.Main.embed(formContainer);
    let recaptcha;

    app.ports.initRecaptcha.subscribe(id =&amp;gt; {
      window.requestAnimationFrame(() =&amp;gt; {
        recaptcha = grecaptcha.render(id, {
          sitekey: &amp;#39;YOUR_SITE_KEY&amp;#39;,
        });
      });
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;app.ports&lt;/code&gt; contains all the ports from the Elm program. By subscribing to
any of them, we are making the passed function to get called anytime
a port gets triggered by the Elm runtime. In our case, it is using
&lt;strong&gt;Google&amp;#39;s reCAPTCHA&lt;/strong&gt; script to render the widget inside the specified id,
using the &lt;code&gt;sitekey&lt;/code&gt; we created previously from the admin site. Also, note
that we are wrapping the render function inside
&lt;code&gt;window.requestAnimationFrame&lt;/code&gt;, forcing the script to initialize the widget
immediately after the form renders for the first time. Not doing it like
so may create race conditions between Elm programs and external JavaScript
components, so don&amp;#39;t forget using it. Let&amp;#39;s jump to the browser and see
the result:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/landing-page.jpg" alt="Landing
page" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;The widget renders as expected, yay!&lt;/p&gt;

&lt;h3&gt;Setting the reCAPTCHA token&lt;/h3&gt;

&lt;p&gt;When a visitor clicks on the widget, it generates a token that we need to
validate against Google reCAPTCHA API, so we need to send it to the server
along with the &lt;code&gt;full_name&lt;/code&gt; and the &lt;code&gt;email&lt;/code&gt;. Before this, let&amp;#39;s edit the model
module to add a new key in the &lt;code&gt;SubscribeForm&lt;/code&gt; so we can store the token:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Model.elm

module Model exposing (..)


type alias FormFields =
    { fullName : String
    , email : String
    , recaptchaToken : Maybe String
    }

-- ...

emptyFormFields : FormFields
emptyFormFields =
    { fullName = &amp;quot;&amp;quot;
    , email = &amp;quot;&amp;quot;
    , recaptchaToken = Nothing
    }

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How can we store in it the token received from the external &lt;strong&gt;reCAPTCHA&lt;/strong&gt;
widget? As sending messages to external &lt;strong&gt;JavaScript&lt;/strong&gt;, &lt;strong&gt;Elm&lt;/strong&gt; can also receive
messages from the outer world by subscribing to incoming ports. Knowing
this, let&amp;#39;s create a new port which receives the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; token from the
widget:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Ports.elm

port module Ports exposing (..)

-- ...


-- IN PORTS


port setRecaptchaToken : (String -&amp;gt; msg) -&amp;gt; Sub msg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;strong&gt;Elm&lt;/strong&gt; receives the &lt;code&gt;setRecaptchaToken&lt;/code&gt; port, we want it to set the token
in the model, and for that, we need to create a new message type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Messages.elm

type Msg
    = HandleFullNameInput String
    -- ...
    | SetRecaptchaToken String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to handle this message in the &lt;code&gt;update&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    -- ...

    SetRecaptchaToken token -&amp;gt;
        { model | subscribeForm = Editing { formFields | recaptchaToken = Just token } } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned before, &lt;strong&gt;Elm&lt;/strong&gt; needs to subscribe to incoming ports, so let&amp;#39;s go
ahead and define the &lt;code&gt;subscriptions&lt;/code&gt; function to put all the pieces together:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

-- ...

subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Ports.setRecaptchaToken SetRecaptchaToken
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing left is sending the token from &lt;strong&gt;JavaScript&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/javascript/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  // ...

    app.ports.initRecaptcha.subscribe(id =&amp;gt; {
      window.requestAnimationFrame(() =&amp;gt; {
        recaptcha = grecaptcha.render(id, {
          sitekey: &amp;#39;YOUR_SITE_KEY&amp;#39;,
          callback: app.ports.setRecaptchaToken.send, // &amp;lt;- CHECK THIS OUT
        });
      });
    });

  // ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;strong&gt;reCAPTCHA&lt;/strong&gt; widget has a callback option which is a function that gets
called after checking the visitor&amp;#39;s response and which contains the token,
and which we can use to send the &lt;code&gt;setRecaptchaToken&lt;/code&gt; port message to &lt;strong&gt;Elm&lt;/strong&gt;.
Let&amp;#39;s check that everything is working as expected:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/settoken-port.gif"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Using &lt;strong&gt;Elm&amp;#39;s debugger&lt;/strong&gt;, we can verify that when we click on the &lt;strong&gt;reCAPTCHA
widget&lt;/strong&gt;, ELm handles the &lt;code&gt;SetRecaptchaToken&lt;/code&gt; message, setting the
&lt;code&gt;recaptchaToken&lt;/code&gt; received through the &lt;code&gt;setRecaptchaToken&lt;/code&gt; port in the model.
The only thing left, for now, is preventing sending the form while the
&lt;code&gt;recaptchaToken&lt;/code&gt; is not set, so let&amp;#39;s fix this in the view module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
    let
        { fullName, email, recaptchaToken } =
            extractFormFields subscribeForm


        -- ...

        buttonDisabled =
            fullName
                == &amp;quot;&amp;quot;
                || email
                == &amp;quot;&amp;quot;
                || recaptchaToken
                == Nothing
                || recaptchaToken
                == Just &amp;quot;&amp;quot;
                || saving
                || invalid

        -- ...
    in
        -- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we have to include the &lt;code&gt;recaptchaToken&lt;/code&gt; value to the HTTP request body:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Commands.elm

module Commands exposing (subscribe)

-- ...

encodeModel : FormFields -&amp;gt; JD.Value
encodeModel { fullName, email, recaptchaToken } =
    JE.object
        [ ( &amp;quot;lead&amp;quot;
          , JE.object
                -- ...

                , ( &amp;quot;recaptcha_token&amp;quot;, JE.string &amp;quot;foo&amp;quot; )
                ]
          )
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Server-side reCAPTCHA token validation&lt;/h3&gt;

&lt;p&gt;Now that the form is sending the token, we can implement the second step
of the process, which is validating it against &lt;strong&gt;Google&amp;#39;s API&lt;/strong&gt;. Although we
are somehow forcing the &lt;code&gt;recaptcha_token&lt;/code&gt; value to have a non-empty value,
let&amp;#39;s add a validation check on the backend, so no leads with empty tokens
can get saved. As we only need to validate it, and not save it, we can add
a virtual field to the &lt;code&gt;Lead&lt;/code&gt; schema:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/lead.ex

defmodule LandingPage.Marketing.Lead do
  use Ecto.Schema
  import Ecto.Changeset
  alias LandingPage.Marketing.Lead

  @derive {Poison.Encoder, only: [:full_name, :email]}

  schema &amp;quot;leads&amp;quot; do
    field(:email, :string)
    field(:full_name, :string)

    field(:recaptcha_token, :string, virtual: true)

    timestamps()
  end

  @fields ~w(full_name email recaptcha_token)a

  @doc false
  def changeset(%Lead{} = lead, attrs) do
    lead
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@fields)
    |&amp;gt; unique_constraint(:email)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This change breaks the tests, so let&amp;#39;s go ahead and fix them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page/marketing/marketing_test.exs

defmodule LandingPage.MarketingTest do
  use LandingPage.DataCase

  # ...

  @valid_attrs %{
    &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;some email&amp;quot;,
    &amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;some full_name&amp;quot;,
    &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;foo&amp;quot;
  }
  @invalid_attrs %{email: nil, full_name: nil, recaptcha_token: nil}

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page_web/controllers/v1/lead_controller_test.exs

defmodule LandingPageWeb.V1.LeadControllerTest do
  use LandingPageWeb.ConnCase

  # ...


  describe &amp;quot;POST /api/v1/leads&amp;quot; do
    test &amp;quot;returns error response with invalid params&amp;quot;, %{conn: conn} do
      conn = post(conn, lead_path(conn, :create), %{&amp;quot;lead&amp;quot; =&amp;gt; %{}})

      assert json_response(conn, 422) == %{
               &amp;quot;full_name&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;],
               &amp;quot;email&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;],
               &amp;quot;recaptcha_token&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;]
             }
    end

    test &amp;quot;returns success response with valid params&amp;quot;, %{conn: conn} do
      params = %{
        &amp;quot;lead&amp;quot; =&amp;gt; %{&amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;, &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;, &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;foo&amp;quot;}
      }

      conn = post(conn, lead_path(conn, :create), params)
      assert json_response(conn, 200) == %{&amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;, &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we now run the test suite, we can see that every test is passing now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;➜ mix test
...........

Finished in 0.1 seconds
11 tests, 0 failures

Randomized with seed 66361
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check whether Google has verified the user, we have to send an HTTP
request to &lt;code&gt;https://www.google.com/recaptcha/api/siteverify&lt;/code&gt; with the
token. For that we first need to install an HTTP client like
&lt;a href="https://github.com/edgurgel/httpoison"&gt;HTTPoison&lt;/a&gt;, so let&amp;#39; go ahead and add
it to the dependencies list:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# mix.exs

# ...

  defp deps do
    [
      # ...
      {:httpoison, &amp;quot;~&amp;gt; 0.13&amp;quot;}
    ]
  end

# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running the necessary &lt;code&gt;mix deps.get&lt;/code&gt; task, we are ready to implement
our &lt;strong&gt;Google&amp;#39;s HTTP client&lt;/strong&gt;, so let&amp;#39;s create the following module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/clients/google/recaptcha_http.ex

defmodule LandingPage.Clients.GoogleRecaptchaHttp do
  use HTTPoison.Base

  @secret_key Application.get_env(:landing_page, :google_recaptcha)[:secret_key]

  def verify(token) do
    params = %{
      secret: @secret_key,
      response: token
    }

    &amp;quot;/siteverify&amp;quot;
    |&amp;gt; get!([], params: params)
    |&amp;gt; case do
         %{status_code: 200, body: body} -&amp;gt;
           {:ok, body}

         response -&amp;gt;
           {:error, response}
       end
  end

  def process_url(url) do
    &amp;quot;https://www.google.com/recaptcha/api&amp;quot; &amp;lt;&amp;gt; url
  end

  def process_response_body(body), do: Poison.decode!(body, keys: :atoms)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using &lt;code&gt;HTTPoison.Base&lt;/code&gt; gives us mostly all the functionality that we need
out of the box. The &lt;code&gt;verify/1&lt;/code&gt; function receives a token and sends an HTTP
request against the specified URL, with the &lt;code&gt;secret_key&lt;/code&gt; and the user&amp;#39;s
token. Depending on the result, it returns a tuple with the &lt;code&gt;:ok&lt;/code&gt; atom and
the processed body using the &lt;code&gt;process_response_body/1&lt;/code&gt; function, or one
containing &lt;code&gt;:error&lt;/code&gt; and the response. To finish the client, we need to set
the value of &lt;code&gt;@secret_key&lt;/code&gt; in the application&amp;#39;s config:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# config/config.exs

# ...

config :landing_page,
  google_recaptcha: [
    secret_key: &amp;quot;SET_HERE_YOUR_SECRET_KEY&amp;quot;
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jumping back to the &lt;a href="https://developers.google.com/recaptcha/docs/verify"&gt;reCAPTCHA
docs&lt;/a&gt;, we can see that
the response body looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;{
  &amp;quot;success&amp;quot;: true|false,
  &amp;quot;challenge_ts&amp;quot;: timestamp,  // timestamp of the challenge load (ISO format yyyy-MM-dd&amp;#39;T&amp;#39;HH:mm:ssZZ)
  &amp;quot;hostname&amp;quot;: string,         // the hostname of the site where the reCAPTCHA was solved
  &amp;quot;error-codes&amp;quot;: [...]        // optional
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having this in mind, we can go ahead and create a new function in the
&lt;code&gt;Marketing&lt;/code&gt; module to subscribe and create new leads:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/marketing.ex

alias LandingPage.Clients.GoogleRecaptchaHttp
# ...

defmodule LandingPage.Marketing do
  # ...

  def subscribe(lead_params) do
    token = Map.get(lead_params, &amp;quot;recaptcha_token&amp;quot;)

    with %Ecto.Changeset{valid?: true} = changeset &amp;lt;- Lead.changeset(%Lead{}, lead_params),
         {:ok, %{success: true}} &amp;lt;- GoogleRecaptchaHttp.verify(token),
         {:ok, lead} &amp;lt;- Repo.insert(changeset) do
      {:ok, lead}
    else
      {:ok, %{success: false}} -&amp;gt;
        {:error, :invalid_recaptcha_token}

      {:error, response} -&amp;gt;
        {:error, response}

      other -&amp;gt;
        {:error, other}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, if everything goes as expected, &lt;code&gt;subscribe/1&lt;/code&gt; receives the
&lt;code&gt;lead_params&lt;/code&gt; and validates them against a lead changeset, verifying the
token using the client, inserting the lead and returning a tuple
containing it. On the other hand, if the token validation returns &lt;code&gt;{:ok,
    %{success: false}}&lt;/code&gt;, which means that is not valid, it returns a &lt;code&gt;{:error,
:invalid_recaptcha_token}&lt;/code&gt; tuple.&lt;/p&gt;

&lt;p&gt;Let&amp;#39; write some tests to check that everything is currently behaving as it
should:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page/marketing/marketing_test.exs

defmodule LandingPage.MarketingTest do
  use LandingPage.DataCase

  # ...

  describe &amp;quot;leads&amp;quot; do
    # ...

    test &amp;quot;subscribe/1 with valid data and token creates a lead&amp;quot; do
      assert {:ok, %Lead{}} = Marketing.subscribe(@valid_attrs)
    end

    test &amp;quot;subscribe/1 with invalid token returns error changeset&amp;quot; do
      params = %{@valid_attrs | &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;invalid&amp;quot;}
      assert {:error, :invalid_recaptcha_token} = Marketing.subscribe(params)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before running the test, let&amp;#39;s think about our current solution for
a second. Every time that we run the tests, the &lt;code&gt;GoogleRecaptchaHttp&lt;/code&gt; client
is going to be sending requests, slowing down the test suite, and we do
not really want that. Moreover, knowing beforehand what the Google&amp;#39;s API
returns, we no longer need to send a real request to test what we need.
There are many ways of implementing a workaround for this, but one of my
favorite ones is creating a mock client, which returns fake responses,
based on the API specification, and use either of the clients depending on
the environment. Let&amp;#39;s stick to this approach, and create a new mock
client:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/clients/google/recaptcha_mock.ex

defmodule LandingPage.Clients.GoogleRecaptchaMock do
  def verify(&amp;quot;invalid&amp;quot;), do: {:ok, %{success: false}}
  def verify(_token), do: {:ok, %{success: true}}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use a specific client depending on the current environment that the
application is running in, we can just set the module we want to use in
that environment configuration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# config/config.exs

# ...

config :landing_page,
  google_recaptcha: [
    secret_key: &amp;quot;SET_HERE_YOUR_SECRET_KEY&amp;quot;,
    client: LandingPage.Clients.GoogleRecaptchaHttp
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# config/test.exs

# ...

config :landing_page,
  google_recaptcha: [
    client: LandingPage.Clients.GoogleRecaptchaMock
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;#39;s refactor the &lt;code&gt;Marketing&lt;/code&gt; module to use the client set in the
environment:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/marketing.ex

alias LandingPage.Clients.GoogleRecaptchaHttp
# ...

@google_recaptcha_client Application.get_env(:landing_page, :google_recaptcha)[:client]

defmodule LandingPage.Marketing do
  # ...

  def subscribe(lead_params) do
    token = Map.get(lead_params, &amp;quot;recaptcha_token&amp;quot;)

    with %Ecto.Changeset{valid?: true} = changeset &amp;lt;- Lead.changeset(%Lead{}, lead_params),
         {:ok, %{success: true}} &amp;lt;- @google_recaptcha_client.verify(token),
         {:ok, lead} &amp;lt;- Repo.insert(changeset) do
      {:ok, lead}
    else
      # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@google_recaptcha_client&lt;/code&gt; contains the client module, which in the test
environment is the mock client, so we can non safely run the tests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜ mix test test/landing_page/marketing/marketing_test.exs
....

Finished in 0.1 seconds
4 tests, 0 failures

Randomized with seed 506123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And they all pass, yay!&lt;/p&gt;

&lt;p&gt;We are still missing an important part though. We need to update the
&lt;code&gt;LeadController&lt;/code&gt; module to use the new &lt;code&gt;subscribe&lt;/code&gt; function we just
created:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/v1/lead_controller.ex

defmodule LandingPageWeb.V1.LeadController do
  use LandingPageWeb, :controller

  alias LandingPage.Marketing

  plug(:scrub_params, &amp;quot;lead&amp;quot;)

  def create(conn, %{&amp;quot;lead&amp;quot; =&amp;gt; params}) do
    with {:ok, lead} &amp;lt;- Marketing.subscribe(params) do
      json(conn, lead)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to handle in the &lt;code&gt;FallbackController&lt;/code&gt; module the &lt;code&gt;{:error,
:invalid_recaptcha_token}&lt;/code&gt; response resulting from an invalid token check:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/fallback_controller.ex

defmodule LandingPageWeb.FallbackController do
  use LandingPageWeb, :controller

  # ...

  def call(conn, {:error, :invalid_recaptcha_token}) do
    conn
    |&amp;gt; put_status(:unprocessable_entity)
    |&amp;gt; render(LandingPageWeb.ErrorView, &amp;quot;invalid_recaptcha_token.json&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;#39;s edit the &lt;code&gt;ErrorView&lt;/code&gt; module in order to add the
necessary render function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/views/error_view.ex

defmodule LandingPageWeb.ErrorView do
  # ...

  def render(&amp;quot;invalid_recaptcha_token.json&amp;quot;, _) do
    %{recaptcha_token: [&amp;quot;the response is invalid&amp;quot;]}
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following the same convention for validation errors, we return a map with
the error we want to render below the &lt;strong&gt;reCAPTCHA widget&lt;/strong&gt;. Let&amp;#39;s add a test
to check that it works:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page_web/controllers/v1/lead_controller_test.exs

defmodule LandingPageWeb.V1.LeadControllerTest do
  use LandingPageWeb.ConnCase

  describe &amp;quot;POST /api/v1/leads&amp;quot; do
    # ...

    test &amp;quot;returns error response with invalid token&amp;quot;, %{conn: conn} do
      params = %{
        &amp;quot;lead&amp;quot; =&amp;gt; %{
          &amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;,
          &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;,
          &amp;quot;recaptcha_token&amp;quot; =&amp;gt; &amp;quot;invalid&amp;quot;
        }
      }

      conn = post(conn, lead_path(conn, :create), params)

      assert json_response(conn, 422) == %{
               &amp;quot;recaptcha_token&amp;quot; =&amp;gt; [&amp;quot;the response is invalid&amp;quot;]
             }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;➜ mix test  test/landing_page_web/controllers/v1/lead_controller_test.exs
...

Finished in 0.1 seconds
3 tests, 0 failures

Randomized with seed 723440
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test it in the browser, we can edit the Elm &lt;code&gt;Commands&lt;/code&gt; module and
simply set a hardcoded value for the &lt;code&gt;recaptcha_token&lt;/code&gt; parameter:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/token-error.gif"
alt="Token error" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;However, wait a minute. If the token is invalid, there is no current way
of resetting the widget again, so the user is not able to resubmit the
form. Let&amp;#39;s fix this.&lt;/p&gt;

&lt;h3&gt;Resetting the token on error&lt;/h3&gt;

&lt;p&gt;Luckily for us, the widget has a &lt;code&gt;reset&lt;/code&gt; function and we
can call it through an Elm port. Let&amp;#39;s edit the &lt;code&gt;Ports&lt;/code&gt; module and add
a new outgoing port:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Ports.elm

port module Ports exposing (..)

-- OUT PORTS


-- ...


port resetRecaptcha : () -&amp;gt; Cmd msg


-- ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to subscribe to the new port and call the widget&amp;#39;s &lt;code&gt;reset&lt;/code&gt;
function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/javascript/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

window.onloadCallback = () =&amp;gt; {
  const formContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

  if (formContainer) {
    const app = Elm.Main.embed(formContainer);
    let recaptcha;

    // ...

    app.ports.resetRecaptcha.subscribe(() =&amp;gt; {
      grecaptcha.reset(recaptcha);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we have to trigger the &lt;code&gt;resetRecaptcha&lt;/code&gt; wherever we need, so
let&amp;#39;s do it on any response error that we receive from the server:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    -- ...

      SubscribeResponse (Err (BadStatus response)) -&amp;gt;
          case Decode.decodeString validationErrorsDecoder response.body of
              Ok validationErrors -&amp;gt;
                  { model | subscribeForm = Invalid { formFields | recaptchaToken = Nothing } validationErrors } ! [ Ports.resetRecaptcha () ]

              Err error -&amp;gt;
                  { model | subscribeForm = Errored { formFields | recaptchaToken = Nothing } &amp;quot;Oops! Something went wrong!&amp;quot; } ! [ Ports.resetRecaptcha () ]

      SubscribeResponse (Err error) -&amp;gt;
          { model | subscribeForm = Errored { formFields | recaptchaToken = Nothing } &amp;quot;Oops! Something went wrong!&amp;quot; } ! [ Ports.resetRecaptcha () ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s jump back to the browser and check that it actually is working fine:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/token-reset.gif"
alt="Token reset" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;The widget is reset as expected, allowing the user to click it again.
Let&amp;#39;s remove the hardcoded value from the &lt;code&gt;recaptcha_token&lt;/code&gt; on the post
parameters and test that everything works fine and the lead subscribes
successfully:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/final-result.gif"
alt="Final result" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;And there we go. Our very basic landing page is ready for deployment and
subscribing new leads, without making us worry about spambots. I hope you
have enjoyed these series as much as I have enjoyed doing them. See you
next time, and don&amp;#39;t forget to check the code from this part
&lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-3"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix &amp; Elm landing page (pt.2)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/12/23/phoenix-elm-landing-page-pt-2/"/>
    <id>http://codeloveandboards.com/blog/2017/12/23/phoenix-elm-landing-page-pt-2/</id>
    <published>2017-12-24T07:44:00Z</published>
    <updated>2018-04-12T17:19:06+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix &amp; Elm landing page&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"&gt;Bootstrapping the project and the basic API functionality to save our first leads&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/"&gt;Building the landing page UI and the basic Elm subscription form&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"&gt;Adding Google reCAPTCHA support to avoid spambots&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In the &lt;a href="/blog/2017/12/01/phoenix-elm-landing-page-pt-1/"&gt;previous part&lt;/a&gt; of the series we created the project for our
brand new landing page, we generated the migration for the leads table, we
implemented the logic for saving them into the database, and we also added
some tests to ensure that everything was working fine. Now we can focus on
the front-end side of the project, which consists of a &lt;strong&gt;Phoenix&lt;/strong&gt; template,
an &lt;strong&gt;Elm&lt;/strong&gt; form, and some &lt;strong&gt;Sass&lt;/strong&gt; love. Let&amp;#39;s do this!&lt;/p&gt;

&lt;h2&gt;A little bit of clean up&lt;/h2&gt;

&lt;p&gt;Before going any further, let&amp;#39;s do a clean up emptying or removing some of
the files generated by &lt;strong&gt;Phoenix&lt;/strong&gt;. These changes include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Removing &lt;code&gt;assets/css/phoenix.css&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Removing &lt;code&gt;assets/js/socket.js&lt;/code&gt; as we are not using sockets this time.&lt;/li&gt;
&lt;li&gt;Removing &lt;code&gt;assets/static/images/phoenix.png&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from removing these extra files that we do not need anymore, we are
also going to edit some of the existing ones. First of all, let&amp;#39;s update
the main layout template and remove all the default &lt;strong&gt;Phoenix&lt;/strong&gt; HTML elements:&lt;/p&gt;

&lt;pre&gt;&lt;code class="eex"&gt;# lib/landing_page_web/templates/layout/app.html.eex

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;

    &amp;lt;title&amp;gt;Hello Landing Page!&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/css/app.css&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body class=&amp;quot;landing-page&amp;quot;&amp;gt;
    &amp;lt;%= render(@view_module, @view_template, assigns) %&amp;gt;
    &amp;lt;script src=&amp;quot;&amp;lt;%= static_path(@conn, &amp;quot;/js/app.js&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to edit the &lt;code&gt;index.html&lt;/code&gt; template to add the basic structure
of the landing page:&lt;/p&gt;

&lt;pre&gt;&lt;code class="eex"&gt;# lib/landing_page_web/templates/page/index.html.eex

&amp;lt;div class=&amp;quot;main-wrapper&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;hero&amp;quot;&amp;gt;
      &amp;lt;h1 class=&amp;quot;title&amp;quot;&amp;gt;Phoenix &amp;amp; Elm landing page&amp;lt;/h1&amp;gt;
      &amp;lt;p class=&amp;quot;subtitle&amp;quot;&amp;gt;
        Real use case of building a landing page using &amp;lt;strong&amp;gt;Phoenix&amp;lt;/strong&amp;gt; and &amp;lt;strong&amp;gt;Elm&amp;lt;/strong&amp;gt;,
        following some common patterns and best practices.
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;scroll-to&amp;quot;&amp;gt;
      &amp;lt;a class=&amp;quot;icon&amp;quot;&amp;gt;
        &amp;lt;i class=&amp;quot;fa fa-chevron-down&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;
      &amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;right&amp;quot; id=&amp;quot;subscribe_form&amp;quot;&amp;gt;
    &amp;lt;section class=&amp;quot;section&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;container is-fluid&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;form_container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having deleted all the extra files and the layout template ready, we are
in a good position to add some styling.&lt;/p&gt;

&lt;h2&gt;Adding styles with Sass and Bulma&lt;/h2&gt;

&lt;p&gt;I have started using &lt;a href="https://bulma.io/"&gt;Bulma&lt;/a&gt; like a month ago, and
I love the results so far. It is a pretty slick looking CSS framework,
based on &lt;strong&gt;flexbox&lt;/strong&gt; and which is very easy to customize using &lt;strong&gt;Sass&lt;/strong&gt;.
Let&amp;#39;s install everything we need to use &lt;strong&gt;Bulma&lt;/strong&gt; and &lt;strong&gt;Sass&lt;/strong&gt; with
&lt;strong&gt;Brunch&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ cd assets
$ npm install node-sass sass-brunch --save-dev
...
...
$ npm install bulma normalize-scss --save
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing the needed modules, we have to edit Brunch&amp;#39;s
configuration file to add support for Sass:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/brunch-config.js

exports.config = {
  // See http://brunch.io/#documentation for docs.
  // ...

  // Configure your plugins
  plugins: {
    // ...

    sass: {
      mode: &amp;#39;native&amp;#39;,
      sourceMapEmbed: true,
      options: {
        includePaths: [
          &amp;#39;node_modules/normalize-scss/sass/&amp;#39;,
          &amp;#39;node_modules/bulma/&amp;#39;,
        ],
      },
    },
  },

//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another tool that I often use to organize my styles files is
&lt;a href="https://github.com/jasonreece/css-burrito"&gt;css-burrito&lt;/a&gt;, which generates
a very convenient structure of &lt;strong&gt;Sass&lt;/strong&gt; files to help you have a well and
organized &lt;strong&gt;Sass&lt;/strong&gt; architecture based on modules. I am not going to dive
deeper into the implementation details, but here you
can find the resulting files. After adding the style files, and restarting
the &lt;strong&gt;Phoenix&lt;/strong&gt; server, we can visit
&lt;a href="http://localhost:4000"&gt;http://localhost:4000&lt;/a&gt; and see the following:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/plain-html.jpg"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Not looking bad at all! However, what about the subscription form?&lt;/p&gt;

&lt;h2&gt;Adding Elm support&lt;/h2&gt;

&lt;p&gt;Adding &lt;strong&gt;Elm&lt;/strong&gt; to the project is pretty straightforward. Before going any
further, make sure you visit &lt;a href="http://elm-lang.org/"&gt;Elm&amp;#39;s official site&lt;/a&gt;
and follow the install instructions for your current platform. Once you
have sorted that out, let&amp;#39;s continue by adding &lt;strong&gt;Elm&lt;/strong&gt;, and its &lt;strong&gt;Brunch&lt;/strong&gt;
support to the project:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ cd assets
$ mkdir elm
$ cd elm
$ elm package install elm-lang/html -y
.
..
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last command installs the basic &lt;strong&gt;Elm&lt;/strong&gt; packages and generates the initial
file structure and configuration file that we need to update to make it
look like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;// assets/elm/elm-package.json

{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;summary&amp;quot;: &amp;quot;Repo for my Phoenix and Elm landing page series&amp;quot;,
  &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/bigardone/phoenix-and-elm-landing-page.git&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;BSD3&amp;quot;,
  &amp;quot;source-directories&amp;quot;: [&amp;quot;src&amp;quot;],
  &amp;quot;exposed-modules&amp;quot;: [],
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;elm-lang/core&amp;quot;: &amp;quot;5.1.1 &amp;lt;= v &amp;lt; 6.0.0&amp;quot;,
    &amp;quot;elm-lang/html&amp;quot;: &amp;quot;2.0.0 &amp;lt;= v &amp;lt; 3.0.0&amp;quot;
  },
  &amp;quot;elm-version&amp;quot;: &amp;quot;0.18.0 &amp;lt;= v &amp;lt; 0.19.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need to install &lt;strong&gt;Brunch&amp;#39;s Elm&lt;/strong&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ cd assets
$ npm install --save-dev elm-brunch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When working with &lt;strong&gt;Elm&lt;/strong&gt;, something that I usually do is to create an src
folder inside &lt;code&gt;assets/elm&lt;/code&gt; where I put there all my &lt;strong&gt;Elm&lt;/strong&gt; source files. The
reason for this is that I sometimes install third-party libraries, and
I like to separate them from my source files, so I place them in an
&lt;code&gt;assets/elm/vendor&lt;/code&gt; folder. Therefore, don&amp;#39;t forget to change the
&lt;code&gt;&amp;quot;source-directories&amp;quot;: [&amp;quot;src&amp;quot;]&lt;/code&gt; line, otherwise your &lt;strong&gt;Elm&lt;/strong&gt; files are not going
to compile at all. We still have to make &lt;strong&gt;Brunch&lt;/strong&gt; detect and build &lt;strong&gt;Elm&lt;/strong&gt;
files, so let&amp;#39;s edit the &lt;strong&gt;Brunch&lt;/strong&gt; configuration file once more:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/brunch-config.js

exports.config = {
  // See http://brunch.io/#documentation for docs.
  // ...

  // Phoenix paths configuration
  paths: {
    // Dependencies and current project directories to watch
    watched: [&amp;#39;static&amp;#39;, &amp;#39;css&amp;#39;, &amp;#39;js&amp;#39;, &amp;#39;vendor&amp;#39;, &amp;#39;elm&amp;#39;],
    // ...
  },

  // Configure your plugins
  plugins: {
    // ...

    elmBrunch: {
      mainModules: [&amp;#39;src/Main.elm&amp;#39;],
      elmFolder: &amp;#39;elm&amp;#39;,
      outputFolder: &amp;#39;../js/elm&amp;#39;,
      makeParameters: [&amp;#39;--warn&amp;#39;, &amp;#39;--debug&amp;#39;],
    },
  },

//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test that everything is working fine, let&amp;#39;s create simple main Elm
module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

module Main exposing (main)

import Html exposing (Html)


main : Html msg
main =
    Html.text &amp;quot;Hello, Elm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, we have to embed the generated javascript by &lt;strong&gt;Elm&lt;/strong&gt; in the
&lt;code&gt;index.html&lt;/code&gt; template, so let&amp;#39;s edit the main &lt;code&gt;app.js&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="js"&gt;// assets/js/app.js

import Elm from &amp;#39;./elm/main&amp;#39;;

const elmContainer = document.querySelector(&amp;#39;#form_container&amp;#39;);

if (elmContainer) {
  const app = Elm.Main.embed(elmContainer);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After &lt;strong&gt;Brunch&lt;/strong&gt; finishes compiling the assets, we can see the &lt;code&gt;Hello,
Elm!&lt;/code&gt; message on the right section of the landing page, yay!&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/hello-elm.jpg"
alt="Navigation flow" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h2&gt;The subscription form&lt;/h2&gt;

&lt;p&gt;The subscription form we need consists of two fields, one for the lead&amp;#39;s
full name and another one for the email. Knowing this, let&amp;#39;s start by
defining any &lt;strong&gt;Elm&lt;/strong&gt; application core element, the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Model.elm

module Model exposing (..)

import Dict exposing (Dict)


type alias FormFields =
    { fullName : String
    , email : String
    }


type alias ValidationErrors =
    Dict String (List String)


type SubscribeForm
    = Editing FormFields
    | Saving FormFields
    | Invalid FormFields ValidationErrors
    | Errored FormFields String
    | Success


type alias Model =
    { subscribeForm : SubscribeForm }


extractFormFields : SubscribeForm -&amp;gt; FormFields
extractFormFields subscribeForm =
    case subscribeForm of
        Editing ff -&amp;gt;
            ff

        Saving ff -&amp;gt;
            ff

        Invalid ff _ -&amp;gt;
            ff

        Errored ff _ -&amp;gt;
            ff

        Success -&amp;gt;
            emptyFormFields


emptyFormFields : FormFields
emptyFormFields =
    { fullName = &amp;quot;&amp;quot;
    , email = &amp;quot;&amp;quot;
    }


extractValidationErrors : SubscribeForm -&amp;gt; ValidationErrors
extractValidationErrors subscribeForm =
    case subscribeForm of
        Invalid _ validationErrors -&amp;gt;
            validationErrors

        _ -&amp;gt;
            emptyValidationErrors


emptyValidationErrors : ValidationErrors
emptyValidationErrors =
    Dict.empty


initialModel : Model
initialModel =
    { subscribeForm = Editing emptyFormFields }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Model&lt;/code&gt; consists of a record with a &lt;code&gt;subscribeForm&lt;/code&gt; key, which is
a &lt;strong&gt;union type&lt;/strong&gt; representing the form&amp;#39;s current state which can be one of
the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Editing&lt;/code&gt; is the initial state when the user is typing on its controls.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Saving&lt;/code&gt; is when the user submits the form, and the Http request with
the data is sent to the backend.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Invalid&lt;/code&gt; means that there are validation errors or something went wrong
while saving the data.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Errored&lt;/code&gt; for the cases where there is an error not related to
validation.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Success&lt;/code&gt; represents that everything went fine, and the lead&amp;#39;s data has
been saved into the database.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on the form&amp;#39;s current state, &lt;code&gt;SubscribeForm&lt;/code&gt; might have
a &lt;code&gt;FormFields&lt;/code&gt; record with the current values inserted by the user, and
a &lt;code&gt;ValidationErrors&lt;/code&gt; type, which consists of a &lt;code&gt;Dict&lt;/code&gt; of validation errors by
field, or a &lt;code&gt;String&lt;/code&gt; containing an error message, which is the case of
&lt;code&gt;Errored&lt;/code&gt;. But why are we defining the model like this? If you are new to
&lt;strong&gt;Elm&lt;/strong&gt;, and not very familiar with &lt;strong&gt;union types&lt;/strong&gt;, you might have probably
defined the model something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;type Status
    = Editing
    | Saving
    | Invalid
    | Errored
    | Success

type alias Model =
    { formFields : FormFields
    , validationErrors : Dict String (List String)
    , error: String
    , status : Status
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach is completely fine, until you realize that it can drive to
&lt;strong&gt;inconsistent states&lt;/strong&gt;, like having a &lt;code&gt;Success&lt;/code&gt; state with a nonempty &lt;code&gt;Dict&lt;/code&gt; of
&lt;code&gt;validationErrors&lt;/code&gt; or with an error message string, and you have to make an
extra effort to prevent the impossible states, or states that don&amp;#39;t make
sense at all. Union types are a very convenient way of avoiding these
situations by making the model data depend on the type, &lt;a href="https://www.youtube.com/watch?v=IcgmSRJHu_8"&gt;making impossible
states impossible&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once the model is defined, let&amp;#39;s continue by implementing the view to
represent the model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

import Dict exposing (Dict)
import Html exposing (Html, form)
import Html.Attributes as Html
import Html.Events as Html
import Messages exposing (Msg(..))
import Model exposing (..)


view : Model -&amp;gt; Html Msg
view { subscribeForm } =
    case subscribeForm of
        Success -&amp;gt;
            Html.div
                [ Html.class &amp;quot;success-message&amp;quot; ]
                [ Html.div
                    [ Html.class &amp;quot;icon is-large&amp;quot; ]
                    [ Html.i
                        [ Html.class &amp;quot;fa fa-3x fa-heart&amp;quot; ]
                        []
                    ]
                , Html.h2
                    []
                    [ Html.text &amp;quot;You have subscribed with success&amp;quot; ]
                , Html.p
                    []
                    [ Html.text &amp;quot;We will keep you updated with the latest news&amp;quot; ]
                ]

        _ -&amp;gt;
            formView subscribeForm


formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
    let
        { fullName, email } =
            extractFormFields subscribeForm

        saving =
            case subscribeForm of
                Saving _ -&amp;gt;
                    True

                _ -&amp;gt;
                    False

        invalid =
            case subscribeForm of
                Invalid _ _ -&amp;gt;
                    True

                _ -&amp;gt;
                    False

        buttonDisabled =
            fullName == &amp;quot;&amp;quot; || email == &amp;quot;&amp;quot; || saving || invalid
    in
        Html.div
            [ Html.class &amp;quot;content&amp;quot; ]
            [ Html.h3
                []
                [ Html.text &amp;quot;Want to know more?&amp;quot; ]
            , Html.p
                []
                [ Html.text &amp;quot;Subscribe to stay updated&amp;quot; ]
            , formError subscribeForm
            , form
                [ Html.onSubmit HandleFormSubmit ]
                [ Html.div
                    [ Html.class &amp;quot;field&amp;quot; ]
                    [ Html.div
                        [ Html.class &amp;quot;control&amp;quot; ]
                        [ Html.input
                            [ Html.classList
                                [ ( &amp;quot;input is-medium&amp;quot;, True )
                                ]
                            , Html.placeholder &amp;quot;My name is...&amp;quot;
                            , Html.required True
                            , Html.value fullName
                            , Html.onInput HandleFullNameInput
                            ]
                            []
                        ]
                    ]
                , Html.div
                    [ Html.class &amp;quot;field&amp;quot; ]
                    [ Html.div
                        [ Html.class &amp;quot;control&amp;quot; ]
                        [ Html.input
                            [ Html.classList
                                [ ( &amp;quot;input is-medium&amp;quot;, True )
                                ]
                            , Html.type_ &amp;quot;email&amp;quot;
                            , Html.placeholder &amp;quot;My email address is...&amp;quot;
                            , Html.required True
                            , Html.value email
                            , Html.onInput HandleEmailInput
                            ]
                            []
                        ]
                    ]
                , Html.div
                    [ Html.class &amp;quot;field&amp;quot; ]
                    [ Html.div
                        [ Html.class &amp;quot;control&amp;quot; ]
                        [ Html.button
                            [ Html.class &amp;quot;button is-primary is-medium&amp;quot;
                            , Html.disabled buttonDisabled
                            ]
                            [ Html.span
                                [ Html.class &amp;quot;icon&amp;quot; ]
                                [ Html.i
                                    [ Html.classList
                                        [ ( &amp;quot;fa fa-check&amp;quot;, not saving )
                                        , ( &amp;quot;fa fa-circle-o-notch fa-spin&amp;quot;, saving )
                                        ]
                                    ]
                                    []
                                ]
                            , Html.span
                                []
                                [ Html.text &amp;quot;Subscribe me&amp;quot; ]
                            ]
                        ]
                    ]
                ]
            ]


formError : SubscribeForm -&amp;gt; Html Msg
formError subscribeForm =
    case subscribeForm of
        Errored _ message -&amp;gt;
            Html.div
                [ Html.class &amp;quot;notification is-danger fade-in&amp;quot; ]
                [ Html.text message ]

        _ -&amp;gt;
            Html.text &amp;quot;&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;view&lt;/code&gt; function receives the &lt;code&gt;Model&lt;/code&gt; and depending on the value of
&lt;code&gt;subscribeForm&lt;/code&gt; it renders a success message or the form using the
&lt;code&gt;formView&lt;/code&gt; function. This function starts by extracting the
current &lt;code&gt;formFields&lt;/code&gt; values and checking if the form is &lt;code&gt;saving&lt;/code&gt; or &lt;code&gt;invalid&lt;/code&gt;.
With these four values, we define the &lt;code&gt;buttonDisabled&lt;/code&gt; value, to disable the
submit button if any of the fields are empty or the form is currently
invalid or saving the data. Inside the &lt;code&gt;in&lt;/code&gt; block, it renders the form,
which has the following peculiarities which are worth mentioning:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It sends a &lt;code&gt;HandleFormSubmit&lt;/code&gt; message when submitted.&lt;/li&gt;
&lt;li&gt;It sends a &lt;code&gt;HandleFullNameInput&lt;/code&gt; message when the &lt;code&gt;fullName&lt;/code&gt; input
changes.&lt;/li&gt;
&lt;li&gt;Same happens for the &lt;code&gt;email&lt;/code&gt; input, but with a &lt;code&gt;HandleEmailInput&lt;/code&gt;
message.&lt;/li&gt;
&lt;li&gt;The submit button is styled and disabled depending on the current state
of &lt;code&gt;subscribeForm&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;formError&lt;/code&gt; function renders a message box with the error when the
form state happens to be &lt;code&gt;Errored&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have not defined yet the messages that we are using in the view for
handling input changes and the form submission, so let&amp;#39;s go ahead and
create the messages module to define them:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Messages.elm

module Messages exposing (Msg(..))

import Dict exposing (Dict)
import Http


type Msg
    = HandleFullNameInput String
    | HandleEmailInput String
    | HandleFormSubmit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;#39;s create the update module, which handles messages updating the
application model:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

import Messages exposing (Msg(..))
import Model exposing (..)


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    let
        subscribeForm =
            model.subscribeForm

        formFields =
            extractFormFields model.subscribeForm
    in
        case msg of
            HandleFullNameInput value -&amp;gt;
                { model | subscribeForm = Editing { formFields | fullName = value } } ! []

            HandleEmailInput value -&amp;gt;
                { model | subscribeForm = Editing { formFields | email = value } } ! []

            HandleFormSubmit -&amp;gt;
                { model | subscribeForm = Saving formFields } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the update function receives either a &lt;code&gt;HandleFullNameInput&lt;/code&gt; or
a &lt;code&gt;HandleEmailInput&lt;/code&gt;, it sets the &lt;code&gt;subscribeForm&lt;/code&gt; to &lt;code&gt;Editing&lt;/code&gt; applying the
current value of the corresponding input. This approach is going to be
very convenient while dealing with validation errors as we are going to
see in a minute. On the other hand, &lt;code&gt;HandleFormSubmit&lt;/code&gt; sets the state to
&lt;code&gt;Saving&lt;/code&gt; which we are using in the &lt;code&gt;View&lt;/code&gt; module to add a spinner and disable
the submit button.&lt;/p&gt;

&lt;p&gt;Last but not least, let&amp;#39;s change the main module to tie everything
together:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Main.elm

module Main exposing (main)

import Html exposing (Html)
import Messages exposing (Msg(..))
import Model exposing (..)
import Update exposing (update)
import View exposing (view)


main : Program Never Model Msg
main =
    Html.program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


init : ( Model, Cmd Msg )
init =
    initialModel ! []


subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Sub.none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything should be compiling successfully now, so jumping back to the
browser we should see the subscription form rendering and ready to send
leads subscriptions:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/subscription-form.gif"
alt="Subscription form" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h2&gt;Form submission and error handling&lt;/h2&gt;

&lt;p&gt;The form is submitted using an HTTP request, and for that, we need to
install &lt;a href="http://package.elm-lang.org/packages/elm-lang/http/latest"&gt;Elm&amp;#39;s HTTP
package&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ cd assets/elm
$ elm package install elm-lang/http -y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As an HTTP request involves &lt;strong&gt;side effects&lt;/strong&gt;, we have to manage them in Elm
using &lt;code&gt;Commands&lt;/code&gt;, so let&amp;#39;s create the command for posting the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Commands.elm

import Http
import Json.Decode as JD
import Json.Encode as JE
import Decoders exposing (responseDecoder)
import Messages exposing (Msg(..))
import Model exposing (SubscribeForm(..), FormFields)


subscribe : SubscribeForm -&amp;gt; Cmd Msg
subscribe subscribeForm =
    case subscribeForm of
        Saving formFields -&amp;gt;
            Http.send SubscribeResponse (post formFields)

        _ -&amp;gt;
            Cmd.none


post : FormFields -&amp;gt; Http.Request Bool
post formFields =
    Http.request
        { method = &amp;quot;POST&amp;quot;
        , headers = []
        , url = &amp;quot;/api/v1/leads&amp;quot;
        , body = Http.jsonBody (encodeModel formFields)
        , expect = Http.expectJson responseDecoder
        , timeout = Nothing
        , withCredentials = False
        }


encodeModel : FormFields -&amp;gt; JD.Value
encodeModel { fullName, email } =
    JE.object
        [ ( &amp;quot;lead&amp;quot;
          , JE.object
                [ ( &amp;quot;full_name&amp;quot;, JE.string fullName )
                , ( &amp;quot;email&amp;quot;, JE.string email )
                ]
          )
        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;subscribe&lt;/code&gt; function we can find another example of how convenient
are union types. We want to post the data only when the form&amp;#39;s status is
&lt;code&gt;Saving&lt;/code&gt; and not when there are validation errors for instance. &lt;code&gt;Http.send&lt;/code&gt;
receives the &lt;code&gt;SubscribeForm&lt;/code&gt; message, used to handle the result and the post
request. This request consists of a record that has all the details of the
request, including the &lt;code&gt;JSON&lt;/code&gt; body which is the encoded form fields, and the
logic to handle the expected response in the expect field, in our case
a &lt;code&gt;JSON&lt;/code&gt; decoder &lt;code&gt;responseDecoder&lt;/code&gt; that we have to create:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Decoders.elm

module Decoders exposing (..)

import Json.Decode as Decode
import Model exposing (ValidationErrors)


responseDecoder : Decode.Decoder Bool
responseDecoder =
    Decode.succeed True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we do not care about the payload that the &lt;code&gt;LeadController&lt;/code&gt; is returning
once the lead subscribes successfully, the &lt;code&gt;responseDecoder&lt;/code&gt; function
decodes anything received into a &lt;code&gt;True&lt;/code&gt; value. Next step for handling the
response is to add the &lt;code&gt;SubscribeResponse&lt;/code&gt; message to the &lt;code&gt;Messages&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Messages.elm

module Messages exposing (Msg(..))

import Dict exposing (Dict)
import Http


type Msg
    = HandleFullNameInput String
    | HandleEmailInput String
    | HandleFormSubmit
    | SubscribeResponse (Result Http.Error Bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And, of course, the necessary handle clause in the &lt;code&gt;Update.update&lt;/code&gt;
function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Update.elm

module Update exposing (update)

-- ...

update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    let
        subscribeForm =
            model.subscribeForm

        formFields =
            extractFormFields model.subscribeForm
    in
        case msg of
            -- ...

            SubscribeResponse (Ok result) -&amp;gt;
                { model | subscribeForm = Success } ! []

            SubscribeResponse (Err (BadStatus response)) -&amp;gt;
                case Decode.decodeString validationErrorsDecoder response.body of
                    Ok validationErrors -&amp;gt;
                        { model | subscribeForm = Invalid formFields validationErrors } ! []

                    Err error -&amp;gt;
                        { model | subscribeForm = Errored formFields &amp;quot;Oops! Something went wrong!&amp;quot; } ! []

            SubscribeResponse (Err error) -&amp;gt;
                { model | subscribeForm = Errored formFields &amp;quot;Oops! Something went wrong!&amp;quot; } ! []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt; of the form post can be either an &lt;code&gt;Ok True&lt;/code&gt;, meaning that
everything went fine setting the &lt;code&gt;subscribeForm&lt;/code&gt; to &lt;code&gt;Success&lt;/code&gt;, or an
&lt;code&gt;Http.Error&lt;/code&gt;, which is another union type describing the reason for the
error. In our case, we only want to handle validation errors, so it
patterns matches against &lt;code&gt;BadStatus&lt;/code&gt; response, using the
&lt;code&gt;validationErrorsDecoder&lt;/code&gt; to decode response which is the error list
returned by the &lt;code&gt;LandingPageWeb.FallbackController&lt;/code&gt; that we created in the
previous part. If there is any other sort of error, it sets the form to
&lt;code&gt;Errored&lt;/code&gt; with a custom error message. To make it work properly, let&amp;#39;s
implement the missing &lt;code&gt;validationErrorsDecoder&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/Decoders.elm

module Decoders exposing (..)

import Json.Decode as Decode
import Model exposing (ValidationErrors)

-- ...

validationErrorsDecoder : Decode.Decoder ValidationErrors
validationErrorsDecoder =
    Decode.dict &amp;lt;| Decode.list Decode.string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new decoder transforms the response into a &lt;code&gt;ValidationErrors&lt;/code&gt; which is
a &lt;code&gt;Dict&lt;/code&gt; where its keys are field names, and the values are a list of
errors, that we can now render in the view:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elm"&gt;-- assets/elm/src/View.elm

module View exposing (view)

-- ...

formView : SubscribeForm -&amp;gt; Html Msg
formView subscribeForm =
    let
        validationErrors =
            extractValidationErrors subscribeForm

        -- ...
    in
        -- ...

        , form
            [ Html.onSubmit HandleFormSubmit ]
            [ Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.div
                    [ Html.class &amp;quot;control&amp;quot; ]
                    [ Html.input
                        [ Html.classList
                            [ ( &amp;quot;input is-medium&amp;quot;, True )
                            , ( &amp;quot;is-danger&amp;quot;, Dict.member &amp;quot;full_name&amp;quot; validationErrors )
                            ]
                        , Html.placeholder &amp;quot;My name is...&amp;quot;
                        , Html.required True
                        , Html.value fullName
                        , Html.onInput HandleFullNameInput
                        ]
                        []
                    , validationErrorView &amp;quot;full_name&amp;quot; validationErrors
                    ]
                ]
            , Html.div
                [ Html.class &amp;quot;field&amp;quot; ]
                [ Html.div
                    [ Html.class &amp;quot;control&amp;quot; ]
                    [ Html.input
                                [ Html.classList
                                    [ ( &amp;quot;input is-medium&amp;quot;, True )
                                    , ( &amp;quot;is-danger&amp;quot;, Dict.member &amp;quot;email&amp;quot; validationErrors )
                                    ]
                                , Html.type_ &amp;quot;email&amp;quot;
                                , Html.placeholder &amp;quot;My email address is...&amp;quot;
                                , Html.required True
                                , Html.value email
                                , Html.onInput HandleEmailInput
                                ]
                                []
                            , validationErrorView &amp;quot;email&amp;quot; validationErrors
                            ]
                      ]

                      -- ...


validationErrorView : String -&amp;gt; ValidationErrors -&amp;gt; Html Msg
validationErrorView key validationErrors =
    case Dict.get key validationErrors of
        Just error -&amp;gt;
            error
                |&amp;gt; List.map Html.text
                |&amp;gt; Html.p
                    [ Html.class &amp;quot;help is-danger&amp;quot; ]

        Nothing -&amp;gt;
            Html.text &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;extractValidationErrors&lt;/code&gt; helper function from the &lt;code&gt;Model&lt;/code&gt; module,
it gets the possible &lt;code&gt;validationErrors&lt;/code&gt; and not only sets an is-danger class
to the fields when it happens to have errors but calls &lt;code&gt;validationErrorView&lt;/code&gt;
to render them.&lt;/p&gt;

&lt;h2&gt;The final result&lt;/h2&gt;

&lt;p&gt;It is time to test out our work so far. Let&amp;#39;s jump back to the browser and
try to subscribe using valid values:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/success-message.gif"
alt="Success message" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;Submitting the form returns a &lt;code&gt;200&lt;/code&gt; success message which changes the
&lt;code&gt;subscribeForm&lt;/code&gt; to &lt;code&gt;Success&lt;/code&gt;, displaying the success message. Next, let&amp;#39;s
try subscribing again using the same email:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/validation-error.gif"
alt="Validation errors" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;This time the server returns a &lt;code&gt;422&lt;/code&gt; unprocessable entity status, with an
error message for the &lt;code&gt;email&lt;/code&gt; field, as it is already taken, cool!
Finally, let&amp;#39;s try to stop the Phoenix server and submit the form once
more to simulate an unexpected response:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/unknown-error.gif"
alt="Unknown error" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;p&gt;As the server is down, the request fails, rendering the generic error message
that we have previously set for nonvalidation errors.&lt;/p&gt;

&lt;p&gt;Our new landing page is looking pretty good so far, though we haven&amp;#39;t finished
yet. In the next episode, we are going to add some protection against spam
bots using &lt;a href="https://developers.google.com/recaptcha/"&gt;Googles reCAPTCHA&lt;/a&gt;,
which not only implies using an external javascript library from our Elm
code but consuming a third party API from our backend. In the meantime,
you can check out the source code of the part
&lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-2"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Merry Christmas and Happy New Coding Year!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Phoenix &amp; Elm landing page (pt.1)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"/>
    <id>http://codeloveandboards.com/blog/2017/12/02/phoenix-elm-landing-page-pt-1/</id>
    <published>2017-12-02T08:00:00Z</published>
    <updated>2018-01-14T08:25:16+01:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;div class="index"&gt;
  &lt;p&gt;This post belongs to the &lt;strong&gt;Phoenix &amp; Elm landing page&lt;/strong&gt; series.&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/02/phoenix-elm-landing-page-pt-1/"&gt;Bootstrapping the project and the basic API functionality to save our first leads&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2017/12/23/phoenix-elm-landing-page-pt-2/"&gt;Building the landing page UI and the basic Elm subscription form&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="/blog/2018/01/06/phoenix-elm-landing-page-pt-3/"&gt;Adding Google reCAPTCHA support to avoid spambots&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;

  &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page" target="_blank"&gt;&lt;i class="fa fa-github"&gt;&lt;/i&gt; Source code&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;In these series, we are going to cover some common patterns and best practices related to using &lt;strong&gt;Phoenix&lt;/strong&gt; and &lt;strong&gt;Elm&lt;/strong&gt; to build a simple landing page with a subscription form. The primary goal is to achieve the following list of tasks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a new &lt;strong&gt;Phoenix&lt;/strong&gt; project.&lt;/li&gt;
&lt;li&gt;Add a new &lt;strong&gt;Phoenix&lt;/strong&gt; context for marketing leads.&lt;/li&gt;
&lt;li&gt;Add an &lt;strong&gt;API&lt;/strong&gt; endpoint to insert a lead&amp;#39;s data into the database.&lt;/li&gt;
&lt;li&gt;Build the landing page template using &lt;strong&gt;Phoenix&lt;/strong&gt; and &lt;a href="https://bulma.io/"&gt;Bulma&lt;/a&gt; as our CSS framework of choice.&lt;/li&gt;
&lt;li&gt;Add &lt;strong&gt;Elm&lt;/strong&gt; to the project and build a subscription form that points to the API endpoint described previously.&lt;/li&gt;
&lt;li&gt;Add &lt;a href="https://developers.google.com/recaptcha/"&gt;Google&amp;#39;s reCAPTCHA&lt;/a&gt; widget to the &lt;strong&gt;Elm&lt;/strong&gt; subscription form, and how to render it and how to handle a visitor&amp;#39;s &lt;strong&gt;reCAPTCHA&lt;/strong&gt; response.&lt;/li&gt;
&lt;li&gt;Build an HTTP client using &lt;a href="https://github.com/edgurgel/httpoison"&gt;HTTPoison&lt;/a&gt; to verify the token received by the &lt;strong&gt;reCAPTCHA&lt;/strong&gt; widget against &lt;strong&gt;Google&amp;#39;s reCAPTCHA API&lt;/strong&gt; from our backend.&lt;/li&gt;
&lt;li&gt;Add tests covering the subscription process using &lt;strong&gt;mocks&lt;/strong&gt; for the HTTP clients.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that we have detailed what we need let&amp;#39;s get cracking!&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/blog/phoenix-elm-landing-page/landing-page.jpg" alt="Landing page" style="background: #fff;" /&gt;&lt;/p&gt;

&lt;h3&gt;Creating the Phoenix project&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s start by bootstrapping a new &lt;strong&gt;Phoenix&lt;/strong&gt; project as we usually do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phx.new landing_page
* creating landing_page/config/config.exs
* creating landing_page/config/dev.exs
* creating landing_page/config/prod.exs
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the task finishes, we can go to the generated project folder and create the database:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd landing_page
$ mix ecto.create
The database for LandingPage.Repo has already been created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to start working on the backend.&lt;/p&gt;

&lt;h3&gt;The Marketing context and Lead schema&lt;/h3&gt;

&lt;p&gt;Before continuing, let&amp;#39;s stop for a second and think about what is the primary goal of our future landing page. The principal goal is not only to be the temporally home site of our awesome new product that we are working on but to let potential leads subscribe so we can take any marketing or business decision that we might need, like for instance sending them the latest news and promotions via email campaigns. Having this in mind, we can identify a &lt;code&gt;Marketing&lt;/code&gt; context and a &lt;code&gt;leads&lt;/code&gt; table for the database, so let&amp;#39;s create both of them using the new &lt;strong&gt;Phoenix&lt;/strong&gt; context generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phx.gen.context Marketing Lead leads full_name:string email:string
* creating lib/landing_page/marketing/lead.ex
* creating priv/repo/migrations/20171202101203_create_leads.exs
* creating lib/landing_page/marketing/marketing.ex
* injecting lib/landing_page/marketing/marketing.ex
* creating test/landing_page/marketing/marketing_test.exs
* injecting test/landing_page/marketing/marketing_test.exs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before running the migrations task, we need to tweak the migration file just created to add a &lt;code&gt;unique&lt;/code&gt; index to the &lt;code&gt;email&lt;/code&gt; column, because we do not want leads subscribing multiple times with the same &lt;code&gt;email&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# priv/repo/migrations/20171201145808_create_leads.exs

defmodule LandingPage.Repo.Migrations.CreateLeads do
  use Ecto.Migration

  def change do
    create table(:leads) do
      add(:full_name, :string, null: false)
      add(:email, :string, null: false)

      timestamps()
    end

    create(unique_index(:leads, [:email]))
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run the migrations task to create the table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mix ecto.migrate
[info] == Running LandingPage.Repo.Migrations.CreateLeads.change/0 forward
[info] create table leads
[info] create index leads_email_index
[info] == Migrated in 0.0s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also have to add the necessary validation rules and constraints to the &lt;code&gt;Lead&lt;/code&gt; schema module, so let&amp;#39;s edit it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page/marketing/lead.ex

defmodule LandingPage.Marketing.Lead do
  use Ecto.Schema
  import Ecto.Changeset
  alias LandingPage.Marketing.Lead

  @derive {Poison.Encoder, only: [:full_name, :email]}

  schema &amp;quot;leads&amp;quot; do
    field(:email, :string)
    field(:full_name, :string)

    timestamps()
  end

  @doc false
  def changeset(%Lead{} = lead, attrs) do
    lead
    |&amp;gt; cast(attrs, [:full_name, :email])
    |&amp;gt; validate_required([:full_name, :email])
    |&amp;gt; unique_constraint(:email)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from adding the &lt;code&gt;unique_constraint&lt;/code&gt; check function, we are also adding the &lt;code&gt;@derive&lt;/code&gt; clause specifying the fields we want to return when a &lt;code&gt;%Lead{}&lt;/code&gt; struct is automatically encoded by &lt;strong&gt;Poison&lt;/strong&gt;, which is very convenient while developing &lt;strong&gt;JSON APIs&lt;/strong&gt;, as we are going to see in a minute.&lt;/p&gt;

&lt;h3&gt;The API endpoint and saving leads&lt;/h3&gt;

&lt;p&gt;Now that our context and schema are ready to start saving leads, let&amp;#39;s add the new &lt;strong&gt;route&lt;/strong&gt; that we are going to use for this purpose:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/router.ex

defmodule LandingPageWeb.Router do
  use LandingPageWeb, :router

    # ...

  # Other scopes may use custom stacks.
  scope &amp;quot;/api&amp;quot;, LandingPageWeb do
    pipe_through(:api)

    scope &amp;quot;/v1&amp;quot;, V1 do
      post(&amp;quot;/leads&amp;quot;, LeadController, :create)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s continue with a more test-driven approach and create a new test file that covers how we expect the controller to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# test/landing_page_web/controllers/v1/lead_controller_test.exs

defmodule LandingPageWeb.V1.LeadControllerTest do
  use LandingPageWeb.ConnCase

  describe &amp;quot;POST /api/v1/leads&amp;quot; do
    test &amp;quot;returns error response with invalid parms&amp;quot;, %{conn: conn} do
      conn = post(conn, lead_path(conn, :create), %{&amp;quot;lead&amp;quot; =&amp;gt; %{}})

      assert json_response(conn, 422) == %{
               &amp;quot;full_name&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;],
               &amp;quot;email&amp;quot; =&amp;gt; [&amp;quot;can&amp;#39;t be blank&amp;quot;]
             }
    end

    test &amp;quot;returns success response with valid params&amp;quot;, %{conn: conn} do
      params = %{
        &amp;quot;lead&amp;quot; =&amp;gt; %{&amp;quot;full_name&amp;quot; =&amp;gt; &amp;quot;John&amp;quot;, &amp;quot;email&amp;quot; =&amp;gt; &amp;quot;foo@bar.com&amp;quot;}
      }

      conn = post(conn, lead_path(conn, :create), params)
      assert json_response(conn, 200) == params[&amp;quot;lead&amp;quot;]
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is a very basic test, but it pretty much covers what we need at the moment. If the &lt;code&gt;lead&lt;/code&gt; parameter is invalid, it should return a &lt;code&gt;422&lt;/code&gt; response (unprocessable entity) along with the validation errors. On the other hand, if the sent parameters are correct, it will return a success response along with the inserted data. Let&amp;#39;s run the &lt;code&gt;mix test&lt;/code&gt; task and see what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix test test/landing_page_web/controllers/v1/lead_controller_test.exs


  1) test POST /api/v1/leads returns success response with valid params (LandingPageWeb.V1.LeadControllerTest)
     test/landing_page_web/controllers/v1/lead_controller_test.exs:14
     ** (UndefinedFunctionError) function LandingPageWeb.V1.LeadController.init/1 is undefined (module LandingPageWeb.V1.LeadController is not available)
     code: conn = post(conn, lead_path(conn, :create), params)
     stacktrace:
       LandingPageWeb.V1.LeadController.init(:create)
       (landing_page) lib/landing_page_web/router.ex:1: anonymous fn/1 in LandingPageWeb.Router.__match_route__/4
       (phoenix) lib/phoenix/router.ex:278: Phoenix.Router.__call__/1
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.plug_builder_call/2
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.call/2
       (phoenix) lib/phoenix/test/conn_test.ex:224: Phoenix.ConnTest.dispatch/5
       test/landing_page_web/controllers/v1/lead_controller_test.exs:19: (test)



  2) test POST /api/v1/leads returns error response with invalid parms (LandingPageWeb.V1.LeadControllerTest)
     test/landing_page_web/controllers/v1/lead_controller_test.exs:5
     ** (UndefinedFunctionError) function LandingPageWeb.V1.LeadController.init/1 is undefined (module LandingPageWeb.V1.LeadController is not available)
     code: conn = post(conn, lead_path(conn, :create), %{&amp;quot;lead&amp;quot; =&amp;gt; %{}})
     stacktrace:
       LandingPageWeb.V1.LeadController.init(:create)
       (landing_page) lib/landing_page_web/router.ex:1: anonymous fn/1 in LandingPageWeb.Router.__match_route__/4
       (phoenix) lib/phoenix/router.ex:278: Phoenix.Router.__call__/1
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.plug_builder_call/2
       (landing_page) lib/landing_page_web/endpoint.ex:1: LandingPageWeb.Endpoint.call/2
       (phoenix) lib/phoenix/test/conn_test.ex:224: Phoenix.ConnTest.dispatch/5
       test/landing_page_web/controllers/v1/lead_controller_test.exs:6: (test)



Finished in 0.09 seconds
2 tests, 2 failures

Randomized with seed 665970
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As expected, the test is failing because we have not created the controller module yet, so let&amp;#39;s add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/v1/lead_controller.ex

defmodule LandingPageWeb.V1.LeadController do
  use LandingPageWeb, :controller

  alias LandingPage.Marketing

  plug(:scrub_params, &amp;quot;lead&amp;quot;)

  def create(conn, %{&amp;quot;lead&amp;quot; =&amp;gt; params}) do
    with {:ok, lead} &amp;lt;- Marketing.create_lead(params) do
      json(conn, lead)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the &lt;code&gt;scrub_params&lt;/code&gt; plug to check if the lead parameter is present and to convert any of its empty keys to nil values. To create the lead, we are using &lt;code&gt;Marketing.create_lead&lt;/code&gt;, which we created before while generating the context. However, we are only pattern matching against the successful &lt;code&gt;{:ok, lead}&lt;/code&gt; response, and there might be validation errors, throwing a runtime error due to the missing pattern matching against &lt;code&gt;{:error, _}&lt;/code&gt;. So what is the reason for doing it like so? Simply because we want to introduce the new &lt;code&gt;Phoenix.Controller.action_fallback/1&lt;/code&gt; macro, which registers a &lt;code&gt;plug&lt;/code&gt; to call as a fallback when an action doesn&amp;#39;t return a valid &lt;code&gt;%Plug.Conn{}&lt;/code&gt; structure. In our particular case, if there is any validation error, it returns a &lt;code&gt;{:error, %Ecto.Changeset{}}&lt;/code&gt; that we need to handle, so let&amp;#39;s setup the fallback controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web.ex

defmodule LandingPageWeb do
# ...

  def controller do
    quote do
      use Phoenix.Controller, namespace: LandingPageWeb
      import Plug.Conn
      import LandingPageWeb.Router.Helpers
      import LandingPageWeb.Gettext

      action_fallback(LandingPageWeb.FallbackController)
    end
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding &lt;code&gt;action_fallback&lt;/code&gt; to the main &lt;code&gt;LandingPageWeb&lt;/code&gt; module makes it available to all of the controllers, but we also have to create the &lt;code&gt;FallbackController&lt;/code&gt; plug module itself, implementing the &lt;code&gt;call/2&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/controllers/fallback_controller.ex

defmodule LandingPageWeb.FallbackController do
  use LandingPageWeb, :controller

  def call(conn, {:error, %Ecto.Changeset{} = changeset}) do
    conn
    |&amp;gt; put_status(:unprocessable_entity)
    |&amp;gt; render(LandingPageWeb.ErrorView, &amp;quot;error.json&amp;quot;, changeset: changeset)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it receives an error with a &lt;code&gt;changeset&lt;/code&gt;, it sets the &lt;code&gt;unprocessable_entity&lt;/code&gt; status to the connection and renders the &lt;code&gt;error.json&lt;/code&gt; template from the &lt;code&gt;LandingPageWeb.ErrorView&lt;/code&gt; module that we also need to implement in the existing module:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# lib/landing_page_web/views/error_view.ex

defmodule LandingPageWeb.ErrorView do
  use LandingPageWeb, :view

  import LandingPageWeb.ErrorHelpers

  # ...

  def render(&amp;quot;error.json&amp;quot;, %{changeset: changeset}) do
    Ecto.Changeset.traverse_errors(changeset, &amp;amp;translate_error/1)
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calling Ectos&amp;#39;s &lt;code&gt;traverse_errors&lt;/code&gt; using the &lt;code&gt;translate_errors&lt;/code&gt; from the &lt;code&gt;ErrorHelpers&lt;/code&gt; module, returns the list of changeset errors we have described in the controller&amp;#39;s test. Let&amp;#39;s rerun the test task to verify that we are good to go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix test test/landing_page_web/controllers/v1/lead_controller_test.exs
..
Finished in 0.1 seconds
2 tests, 0 failures

Randomized with seed 304229
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome, all test are passing, and the controller is working as we initially planned. In regards to the back-end we have everything that we need, for now, so in the next part we will focus on the front-end side, install all dependencies that we need such as &lt;strong&gt;Elm&lt;/strong&gt; and &lt;strong&gt;Bulma&lt;/strong&gt;, building the basic layout and the subscription form to start saving the first leads. In the meantime, you can check out the source code of what we have done so far &lt;a href="https://github.com/bigardone/phoenix-and-elm-landing-page/tree/tutorial/part-1"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Migrating ActiveRecord STI to Ecto (pt. 1)</title>
    <link rel="alternate" href="http://codeloveandboards.com/blog/2017/10/03/migrating-activerecord-sti-to-ecto/"/>
    <id>http://codeloveandboards.com/blog/2017/10/03/migrating-activerecord-sti-to-ecto/</id>
    <published>2017-10-04T06:01:00Z</published>
    <updated>2017-10-06T10:40:14+02:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;From ActiveRecord STI to Ecto embedded schemas&lt;/h2&gt;

&lt;p&gt;Almost three years have passed since I wrote a post about &lt;a href="/blog/2015/01/11/rails-sti-with-postgresql-hstore"&gt;Rails STI with
PostgreSQL hstore&lt;/a&gt;. At
that time I was building a platform called &lt;a href="https://eventos.talentoit.org/"&gt;Eventos Talento
IT&lt;/a&gt; which started as a place where
developers could participate in raffles to win tickets for tech events, but we
have ended up raffling books and courses as well. In the mentioned post,
I explain how to achieve &lt;strong&gt;STI&lt;/strong&gt; in &lt;strong&gt;Rails&lt;/strong&gt; and &lt;strong&gt;PostgreSQL&lt;/strong&gt; thanks to
Postgres&amp;#39;s &lt;strong&gt;hstore&lt;/strong&gt; type. After these years, we want to make some
improvements in the platform, so instead of updating the old codebase, I can&amp;#39;t
resist redoing everything in &lt;strong&gt;Elixir&lt;/strong&gt; and, of course, &lt;strong&gt;Elm&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;After taking a look at the original &lt;strong&gt;Rails&lt;/strong&gt; project and recalling the schema
and models, I have encountered the first problem in regards to migrating
ActiveRecord models to Ecto schemas, inheritance. In the old &lt;strong&gt;Rails&lt;/strong&gt; project
we have the following models:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/item.rb

# == Schema Information
#
# Table name: items
#
#  id          :integer          not null, primary key
#  name        :string           not null
#  description :text
#  site_url    :string
#  image       :string
#  raffle_date :date
#  raffled_at  :datetime
#  created_at  :datetime         not null
#  updated_at  :datetime         not null
#  type        :string           not null
#  data        :hstore
#
# Indexes
#
#  index_items_on_data  (data)
#

class Item &amp;lt; ActiveRecord::Base
  # Validations
  validates :name, :raffle_date, presence: true
end

# app/models/book.rb

class Book &amp;lt; Item
  store_accessor :data, :author

  # Validations
  validates :author, presence: true
end

# app/models/event.rb

class Event &amp;lt; Item
  store_accessor :data, :start_date, :end_date, :location

  # Validations
  validates :start_date, :end_date, :location, presence: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Item&lt;/code&gt; model has the basic structure with the shared fields for &lt;code&gt;Book&lt;/code&gt; and
&lt;code&gt;Event&lt;/code&gt;, and the field &lt;code&gt;type&lt;/code&gt; specifies which item type is going to be. Both
&lt;code&gt;Event&lt;/code&gt; and &lt;code&gt;Book&lt;/code&gt; inherit from &lt;code&gt;Item&lt;/code&gt; defining their specific fields in
the &lt;code&gt;store_accessor&lt;/code&gt; function and their validation rules, which will be
checked along with the common rules when needed. In regards to &lt;strong&gt;Rails&lt;/strong&gt; and
&lt;strong&gt;ActiveRecord&lt;/strong&gt;, this is pretty much it, thanks to a lot of black magic going
on in the background. So, how can we achieve something similar with &lt;strong&gt;Ecto&lt;/strong&gt;?&lt;/p&gt;

&lt;h3&gt;Defining the table&lt;/h3&gt;

&lt;p&gt;Let&amp;#39;s start by preparing the new schema table to mirror. To make this work
correctly it, is essential that the field &lt;code&gt;type&lt;/code&gt; is adequately defined and it
only contains the values that we need. Of course, there are multiple ways of
achieving this, but last week my good friend
&lt;a href="https://oscardearriba.com/"&gt;Oscar&lt;/a&gt; told me about the
&lt;a href="https://github.com/gjaldon/ecto_enum"&gt;EctoEnum&lt;/a&gt; library, which adds support
for enums in &lt;strong&gt;Ecto&lt;/strong&gt; schemas, and looks like an excellent opportunity for
trying it out. To install it we need to add it in the &lt;code&gt;mix.exs&lt;/code&gt; file of the
project:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# mix.exs

defmodule TalentoItSchema.Mixfile do
  use Mix.Project

  # ...

  defp deps do
    [
      ...
      {:ecto_enum, &amp;quot;~&amp;gt; 1.0&amp;quot;}
    ]
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we have to create a module to define our different enums:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# talento_it_schema/lib/talento_it_schema/ecto_enums.ex

defmodule TalentoItSchema.EctoEnums do
  import EctoEnum

  defenum ItemTypeEnum, :item_type, [:book, :event]

  def item_type_book, do: :book

  def item_type_event, do: :event
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;defenum&lt;/code&gt; macro, we are setting a new &lt;code&gt;ItemTypeEnum&lt;/code&gt; enum that maps
a new Postgres &lt;code&gt;item_type&lt;/code&gt; enum that will have &lt;code&gt;book&lt;/code&gt; or &lt;code&gt;event&lt;/code&gt; as valid
values. Now we have to create both the enum type and the table, so let&amp;#39;s create
the migration file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/priv/repo/migrations/123456789_create_raffle_items.exs

dule TalentoItSchema.Repo.Migrations.CreateRaffleItems do
  use Ecto.Migration

  alias TalentoItSchema.EctoEnums.ItemTypeEnum

  def change do
    ItemTypeEnum.create_type()

    create table(:raffle_items) do
      add :type, :item_type, null: false
      add :name, :string, null: false
      add :description, :string
      add :site_url, :string
      add :image, :string
      add :raffle_date, :date
      add :raffled_at, :utc_datetime
      add :data, :map

      timestamps()
    end

    create index(:raffle_items, [:type])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ItemTypeEnum.create_type()&lt;/code&gt; is a helper function that comes with &lt;strong&gt;EctoEnum&lt;/strong&gt;
to create the new enum type in Postgres. Also note that the &lt;code&gt;data&lt;/code&gt; column is of
type &lt;code&gt;map&lt;/code&gt;, and will store the specific data for books and events. Let&amp;#39;s run
the migration and &lt;code&gt;run mix ecto.dump&lt;/code&gt; to check in the generated file how it
creates this new type:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;-- talento_it_schema/priv/repo/structure.sql

-- ...

--
-- Name: item_type; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE item_type AS ENUM (
    &amp;#39;book&amp;#39;,
    &amp;#39;event&amp;#39;
);

-- ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;#39;s move on the schema module to set it up correctly:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/lib/talento_it_schame/raffle/item.ex

defmodule TalentoItSchema.Raffle.Item do
  use Ecto.Schema
  import Ecto.Changeset

  alias TalentoItSchema.{
    EctoEnums,
    EctoEnums.ItemTypeEnum
  }

  schema &amp;quot;raffle_items&amp;quot; do
    field :name, :string
    field :description, :string
    field :site_url, :string
    field :image, :string
    field :raffle_date, :date
    field :raffled_at, :utc_datetime
    field :type, ItemTypeEnum
    field :data, :map

    timestamps()
  end

  @fields ~w(type name description site_url image raffle_date raffled_at data)a
  @required_fields ~w(type name data)a

  @doc false
  def changeset(%Item{} = item, attrs) do
    item
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@required_fields)
  end

  # ...

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we have set the type of the &lt;code&gt;:type&lt;/code&gt; field to &lt;code&gt;ItemTypeEnum&lt;/code&gt;,
which takes care of validating that the passed attributes only contain allowed
values, in this particular case any of &lt;code&gt;[:book, :event, &amp;quot;book&amp;quot;, &amp;quot;event&amp;quot;]&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt;Item.changeset(%Item{}, %{type: &amp;quot;IVALID&amp;quot;, name: &amp;quot;Foo&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;},
 errors: [type: {&amp;quot;is invalid&amp;quot;,
   [type: TalentoItSchema.EctoEnums.ItemTypeEnum, validation: :cast]}],
 data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: false&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Item.changeset(%Item{}, %{type: &amp;quot;book&amp;quot;, name: &amp;quot;Foo&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;, type: :book},
 errors: [], data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Until this point, we have covered the basic &lt;code&gt;Item&lt;/code&gt; attributes and validations,
but how can we do something similar to the old &lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Event&lt;/code&gt; &lt;strong&gt;Rails&lt;/strong&gt;
models to define specific attributes and validations? One of my favorite things
about &lt;code&gt;Ecto&lt;/code&gt; (and &lt;code&gt;Elixir&lt;/code&gt; in general) is that there is no hidden magic behind.
Its explicitness forces you to write more code, but on the other hand, it gives
you the freedom to solve problems in many different ways.&lt;/p&gt;

&lt;h3&gt;Ecto embedded schemas&lt;/h3&gt;

&lt;p&gt;After doing some research and watching &lt;a href="https://github.com/darinwilson"&gt;Darin
Wilson&amp;#39;s&lt;/a&gt; talk on &lt;a href="https://elixirconf.com/"&gt;ElixirConf
2017&lt;/a&gt; called &lt;a href="https://www.youtube.com/watch?v=YQxopjai0CU"&gt;Thinking in
Ecto&lt;/a&gt;, I have decided to use
Ecto&amp;#39;s
&lt;a href="https://hexdocs.pm/ecto/Ecto.Schema.html#embedded_schema/1"&gt;embedded_schema&lt;/a&gt;.
An embedded schema is essentially a schema which doesn&amp;#39;t point to any
particular data source. It can&amp;#39;t be queried or persisted, but, on the other
hand, it lets you define its structure, types and validation rules, which is
very suitable for our needs. Let&amp;#39;s create the embedded schemas for both the
&lt;code&gt;Book&lt;/code&gt; and &lt;code&gt;Event&lt;/code&gt; modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/lib/talento_it_schema/raffle/item/book.ex

defmodule TalentoItSchema.Raffle.Item.Book do
  use Ecto.Schema
  import Ecto.Changeset

  embedded_schema do
    field :author, :string
  end

  @fields ~w(author)a

  def changeset(attrs), do: changeset(%__MODULE__{}, attrs)
  def changeset(%__MODULE__{} = book, attrs) do
    book
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@fields)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# talento_it_schema/lib/talento_it_schema/raffle/item/event.ex

defmodule TalentoItSchema.Raffle.Item.Event do
  use Ecto.Schema
  import Ecto.Changeset

  embedded_schema do
    field :start_date, :date
    field :end_date, :date
    field :location, :string
  end

  @fields ~w(start_date end_date location)a

  def changeset(attrs), do: changeset(%__MODULE__{}, attrs)
  def changeset(%__MODULE__{} = event, attrs) do
    event
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@fields)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like in the old &lt;strong&gt;Rails&lt;/strong&gt; models, the &lt;code&gt;Book&lt;/code&gt; embed schema contains an
&lt;code&gt;author&lt;/code&gt; key with a required &lt;code&gt;string&lt;/code&gt; value. Same happens with &lt;code&gt;Event&lt;/code&gt;, but
it has &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt;, both of them &lt;code&gt;date&lt;/code&gt; fields, and
&lt;code&gt;location&lt;/code&gt; which is a string, all of them mandatory. Going back to &lt;code&gt;IEx&lt;/code&gt;, we
can check that everything works as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; Book.changeset(%{})
#Ecto.Changeset&amp;lt;action: nil, changes: %{},
 errors: [author: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}],
 data: #TalentoItSchema.Raffle.Item.Book&amp;lt;&amp;gt;, valid?: false&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Event.changeset(%{})
#Ecto.Changeset&amp;lt;action: nil, changes: %{},
 errors: [start_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  end_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  location: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}],
 data: #TalentoItSchema.Raffle.Item.Event&amp;lt;&amp;gt;, valid?: false&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! Now we just need a way of making the &lt;code&gt;Item.changeset/2&lt;/code&gt; function call
the respective &lt;code&gt;changeset&lt;/code&gt; functions of the embedded schemas modules, depending
of course on the &lt;code&gt;type&lt;/code&gt; enum previously defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class="elixir"&gt;# talento_it_schema/lib/talento_it_schame/raffle/item.ex

defmodule TalentoItSchema.Raffle.Item do
  use Ecto.Schema
  import Ecto.Changeset

  alias TalentoItSchema.{
    EctoEnums,
    EctoEnums.ItemTypeEnum,
    Raffle.Item.Book,
    Raffle.Item.Event
  }

  # ...

  @doc false
  def changeset(%Item{} = item, attrs) do
    item
    |&amp;gt; cast(attrs, @fields)
    |&amp;gt; validate_required(@required_fields)
    |&amp;gt; validate_data
  end

  defp validate_data(changeset) do
    changeset
    |&amp;gt; build_data_changeset
    |&amp;gt; case do
      %{valid?: true} -&amp;gt;
        changeset

      %{errors: errors} -&amp;gt;
        add_data_errors(changeset, errors)
    end
  end

  defp build_data_changeset(changeset) do
    data = get_field(changeset, :data)
    type = get_field(changeset, :type)

    cond do
      type == EctoEnums.item_type_book() -&amp;gt;
        Book.changeset(data)

      type == EctoEnums.item_type_event() -&amp;gt;
        Event.changeset(data)

      true -&amp;gt;
        changeset
    end
  end

  defp add_data_errors(changeset, errors) do
    Enum.reduce(errors, changeset, fn {key, {message, meta}}, acc -&amp;gt; add_error(acc, key, message, meta) end)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;changeset&lt;/code&gt; pipeline we have added a call to a new &lt;code&gt;validate_data/1&lt;/code&gt;
function, which receives the current &lt;code&gt;changeset&lt;/code&gt; and depending on the &lt;code&gt;type&lt;/code&gt;
enum value, calls the specific &lt;code&gt;Book&lt;/code&gt; or &lt;code&gt;Event&lt;/code&gt; module &lt;code&gt;changeset/1&lt;/code&gt;
function passing the &lt;code&gt;data&lt;/code&gt; map values. If the resulting changeset is valid,
then it returns it. Otherwise, it calls the &lt;code&gt;add_data_errors/2&lt;/code&gt;, adding the
embedded errors to the &lt;code&gt;Item&lt;/code&gt; changeset. Let&amp;#39;s jump back to the interactive
shell and try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;book&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;, type: :book},
 errors: [author: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}],
 data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: false&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;event&amp;quot;, data: %{}})
#Ecto.Changeset&amp;lt;action: nil, changes: %{data: %{}, name: &amp;quot;Foo&amp;quot;, type: :event},
 errors: [location: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  end_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]},
  start_date: {&amp;quot;can&amp;#39;t be blank&amp;quot;, [validation: :required]}], data:
  #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: false&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validations seem to be working just fine, let&amp;#39;s check out some valid data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Interactive Elixir (1.5.1) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;book&amp;quot;, data: %{author: &amp;quot;Foo&amp;quot;}})
#Ecto.Changeset&amp;lt;action: nil,
 changes: %{data: %{author: &amp;quot;Foo&amp;quot;}, name: &amp;quot;Foo&amp;quot;, type: :book}, errors: [],
 data: #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: true&amp;gt;
iex(2)&amp;gt;
nil
iex(3)&amp;gt; Item.changeset(%Item{}, %{name: &amp;quot;Foo&amp;quot;, type: &amp;quot;event&amp;quot;, data: %{start_date: &amp;quot;2017-10-05&amp;quot;, end_date: &amp;quot;2017-10-07&amp;quot;, location: &amp;quot;Foo&amp;quot;}})
#Ecto.Changeset&amp;lt;action: nil,
 changes: %{data: %{end_date: &amp;quot;2017-10-07&amp;quot;, location: &amp;quot;Foo&amp;quot;,
     start_date: &amp;quot;2017-10-05&amp;quot;}, name: &amp;quot;Foo&amp;quot;, type: :event}, errors: [], data:
 #TalentoItSchema.Raffle.Item&amp;lt;&amp;gt;, valid?: true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works as expected, yay! However, we need a proper and reliable way of
testing this functionality correctly instead of trying it out in the
interactive shell. Speaking of which, I have started using &lt;a href="http://propertesting.com/"&gt;property-based
testing&lt;/a&gt; in the new project, and I&amp;#39;m very pleased
with the results so far. On the next part I would like to write about it,
and add some tests to what we have done today. In the meantime, what do you
think about the solution so far? Have you happened to run into a similar
problem? How did you solved it?&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
  </entry>
</feed>
